Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    A_LAST
    COMMENT
    A_IMAGE
    INTERFACE
    SYNCHRONIZED
    A_FIRST
    A_VAL
    A_VALUE
    A_LENGTH
    A_POS
    OVERRIDING
    A_RANGE

Grammar

Rule 0     S' -> start_symbol
Rule 1     start_symbol -> compilation
Rule 2     pragma -> PRAGMA ID ;
Rule 3     pragma -> PRAGMA simple_name ( pragma_arg_s ) ;
Rule 4     pragma_arg_s -> pragma_arg
Rule 5     pragma_arg_s -> pragma_arg_s , pragma_arg
Rule 6     pragma_arg -> expression
Rule 7     pragma_arg -> simple_name ARROW expression
Rule 8     pragma_s -> <empty>
Rule 9     pragma_s -> pragma_s pragma
Rule 10    decl -> object_decl
Rule 11    decl -> number_decl
Rule 12    decl -> type_decl
Rule 13    decl -> subtype_decl
Rule 14    decl -> pkg_decl
Rule 15    decl -> task_decl
Rule 16    decl -> prot_decl
Rule 17    decl -> exception_decl
Rule 18    decl -> rename_decl
Rule 19    decl -> generic_decl
Rule 20    decl -> body_stub
Rule 21    decl -> error ;
Rule 22    decl -> subprog_decl
Rule 23    object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ;
Rule 24    def_id_s -> def_id
Rule 25    def_id_s -> def_id_s , def_id
Rule 26    def_id -> ID
Rule 27    object_qualifier_opt -> <empty>
Rule 28    object_qualifier_opt -> ALIASED
Rule 29    object_qualifier_opt -> CONSTANT
Rule 30    object_qualifier_opt -> ALIASED CONSTANT
Rule 31    object_subtype_def -> subtype_ind
Rule 32    object_subtype_def -> array_type
Rule 33    init_opt -> <empty>
Rule 34    init_opt -> ASSIGNMENT expression
Rule 35    number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ;
Rule 36    type_decl -> TYPE ID discrim_part_opt type_completion ;
Rule 37    discrim_part_opt -> <empty>
Rule 38    discrim_part_opt -> discrim_part
Rule 39    discrim_part_opt -> ( BOX )
Rule 40    type_completion -> <empty>
Rule 41    type_completion -> IS type_def
Rule 42    type_def -> enumeration_type
Rule 43    type_def -> integer_type
Rule 44    type_def -> real_type
Rule 45    type_def -> array_type
Rule 46    type_def -> record_type
Rule 47    type_def -> access_type
Rule 48    type_def -> derived_type
Rule 49    type_def -> private_type
Rule 50    subtype_decl -> SUBTYPE ID IS subtype_ind ;
Rule 51    subtype_ind -> name constraint
Rule 52    subtype_ind -> name
Rule 53    constraint -> range_constraint
Rule 54    constraint -> decimal_digits_constraint
Rule 55    decimal_digits_constraint -> DIGITS expression range_constr_opt
Rule 56    derived_type -> NEW subtype_ind
Rule 57    derived_type -> NEW subtype_ind WITH PRIVATE
Rule 58    derived_type -> NEW subtype_ind WITH record_def
Rule 59    derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
Rule 60    derived_type -> ABSTRACT NEW subtype_ind WITH record_def
Rule 61    range_constraint -> RANGE range
Rule 62    range -> simple_expression DOUBLEDOT simple_expression
Rule 63    range -> name SINGLEQUOTE RANGE
Rule 64    range -> name SINGLEQUOTE RANGE ( expression )
Rule 65    enumeration_type -> ( enum_id_s )
Rule 66    enum_id_s -> enum_id
Rule 67    enum_id_s -> enum_id_s , enum_id
Rule 68    enum_id -> ID
Rule 69    enum_id -> CHARLITERAL
Rule 70    integer_type -> range_spec
Rule 71    integer_type -> MOD expression
Rule 72    range_spec -> range_constraint
Rule 73    range_spec_opt -> <empty>
Rule 74    range_spec_opt -> range_spec
Rule 75    real_type -> float_type
Rule 76    real_type -> fixed_type
Rule 77    float_type -> DIGITS expression range_spec_opt
Rule 78    fixed_type -> DELTA expression range_spec
Rule 79    fixed_type -> DELTA expression DIGITS expression range_spec_opt
Rule 80    array_type -> unconstr_array_type
Rule 81    array_type -> constr_array_type
Rule 82    unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def
Rule 83    constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def
Rule 84    component_subtype_def -> aliased_opt subtype_ind
Rule 85    aliased_opt -> <empty>
Rule 86    aliased_opt -> ALIASED
Rule 87    index_s -> index
Rule 88    index_s -> index_s , index
Rule 89    index -> name RANGE BOX
Rule 90    iter_index_constraint -> ( iter_discrete_range_s )
Rule 91    iter_discrete_range_s -> discrete_range
Rule 92    iter_discrete_range_s -> iter_discrete_range_s , discrete_range
Rule 93    discrete_range -> name range_constr_opt
Rule 94    discrete_range -> range
Rule 95    range_constr_opt -> <empty>
Rule 96    range_constr_opt -> range_constraint
Rule 97    record_type -> tagged_opt limited_opt record_def
Rule 98    record_def -> RECORD pragma_s comp_list END RECORD
Rule 99    record_def -> NuLL RECORD
Rule 100   tagged_opt -> <empty>
Rule 101   tagged_opt -> TAGGED
Rule 102   tagged_opt -> ABSTRACT TAGGED
Rule 103   comp_list -> comp_decl_s variant_part_opt
Rule 104   comp_list -> variant_part pragma_s
Rule 105   comp_list -> NuLL ; pragma_s
Rule 106   comp_decl_s -> comp_decl
Rule 107   comp_decl_s -> comp_decl_s pragma_s comp_decl
Rule 108   variant_part_opt -> pragma_s
Rule 109   variant_part_opt -> pragma_s variant_part pragma_s
Rule 110   comp_decl -> def_id_s : component_subtype_def init_opt ;
Rule 111   comp_decl -> error ;
Rule 112   discrim_part -> ( discrim_spec_s )
Rule 113   discrim_spec_s -> discrim_spec
Rule 114   discrim_spec_s -> discrim_spec_s ; discrim_spec
Rule 115   discrim_spec -> def_id_s : access_opt mark init_opt
Rule 116   discrim_spec -> error
Rule 117   access_opt -> <empty>
Rule 118   access_opt -> ACCESS
Rule 119   variant_part -> CASE simple_name IS pragma_s variant_s END CASE ;
Rule 120   variant_s -> variant
Rule 121   variant_s -> variant_s variant
Rule 122   variant -> WHEN choice_s ARROW pragma_s comp_list
Rule 123   choice_s -> choice
Rule 124   choice_s -> choice_s | choice
Rule 125   choice -> expression
Rule 126   choice -> discrete_with_range
Rule 127   choice -> OTHERS
Rule 128   discrete_with_range -> name range_constraint
Rule 129   discrete_with_range -> range
Rule 130   access_type -> ACCESS subtype_ind
Rule 131   access_type -> ACCESS CONSTANT subtype_ind
Rule 132   access_type -> ACCESS ALL subtype_ind
Rule 133   access_type -> ACCESS prot_opt PROCEDURE formal_part_opt
Rule 134   access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
Rule 135   prot_opt -> <empty>
Rule 136   prot_opt -> PROTECTED
Rule 137   decl_part -> <empty>
Rule 138   decl_part -> decl_item_or_body_s1
Rule 139   decl_item_s -> <empty>
Rule 140   decl_item_s -> decl_item_s1
Rule 141   decl_item_s1 -> decl_item
Rule 142   decl_item_s1 -> decl_item_s1 decl_item
Rule 143   decl_item -> decl
Rule 144   decl_item -> use_clause
Rule 145   decl_item -> rep_spec
Rule 146   decl_item -> pragma
Rule 147   decl_item_or_body_s1 -> decl_item_or_body
Rule 148   decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body
Rule 149   decl_item_or_body -> body
Rule 150   decl_item_or_body -> decl_item
Rule 151   body -> subprog_body
Rule 152   body -> pkg_body
Rule 153   body -> task_body
Rule 154   body -> prot_body
Rule 155   name -> simple_name
Rule 156   name -> indexed_comp
Rule 157   name -> selected_comp
Rule 158   name -> attribute
Rule 159   name -> operator_symbol
Rule 160   mark -> simple_name
Rule 161   mark -> mark SINGLEQUOTE attribute_id
Rule 162   mark -> mark . simple_name
Rule 163   simple_name -> ID
Rule 164   compound_name -> simple_name
Rule 165   compound_name -> compound_name . simple_name
Rule 166   c_name_list -> compound_name
Rule 167   c_name_list -> c_name_list , compound_name
Rule 168   used_char -> CHARLITERAL
Rule 169   operator_symbol -> STRLITERAL
Rule 170   indexed_comp -> name ( value_s )
Rule 171   value_s -> value
Rule 172   value_s -> value_s , value
Rule 173   value -> expression
Rule 174   value -> comp_assoc
Rule 175   value -> discrete_with_range
Rule 176   value -> error
Rule 177   selected_comp -> name . simple_name
Rule 178   selected_comp -> name . used_char
Rule 179   selected_comp -> name . operator_symbol
Rule 180   selected_comp -> name . ALL
Rule 181   attribute -> name SINGLEQUOTE attribute_id
Rule 182   attribute_id -> ID
Rule 183   attribute_id -> DIGITS
Rule 184   attribute_id -> DELTA
Rule 185   attribute_id -> ACCESS
Rule 186   numeric_lit -> NUMLITERAL_BASE_INT
Rule 187   numeric_lit -> NUMLITERAL_BASE_FLOAT
Rule 188   numeric_lit -> NUMLITERAL_INT
Rule 189   numeric_lit -> NUMLITERAL_FLOAT
Rule 190   literal -> numeric_lit
Rule 191   literal -> used_char
Rule 192   literal -> NuLL
Rule 193   aggregate -> ( comp_assoc )
Rule 194   aggregate -> ( value_s_2 )
Rule 195   aggregate -> ( expression WITH value_s )
Rule 196   aggregate -> ( expression WITH NuLL RECORD )
Rule 197   aggregate -> ( NuLL RECORD )
Rule 198   value_s_2 -> value , value
Rule 199   value_s_2 -> value_s_2 , value
Rule 200   comp_assoc -> choice_s ARROW expression
Rule 201   expression -> relation
Rule 202   expression -> expression logical m relation
Rule 203   expression -> expression short_circuit m relation
Rule 204   logical -> AND
Rule 205   logical -> OR
Rule 206   logical -> XOR
Rule 207   short_circuit -> AND THEN
Rule 208   short_circuit -> OR ELSE
Rule 209   relation -> simple_expression
Rule 210   relation -> simple_expression relational simple_expression
Rule 211   relation -> simple_expression membership range
Rule 212   relation -> simple_expression membership name
Rule 213   relational -> =
Rule 214   relational -> NOTEQUAL
Rule 215   relational -> <
Rule 216   relational -> LEQUAL
Rule 217   relational -> >
Rule 218   relational -> GEQUAL
Rule 219   membership -> IN
Rule 220   membership -> NOT IN
Rule 221   simple_expression -> unary term
Rule 222   simple_expression -> term
Rule 223   simple_expression -> simple_expression adding term
Rule 224   unary -> +
Rule 225   unary -> -
Rule 226   adding -> +
Rule 227   adding -> -
Rule 228   adding -> &
Rule 229   term -> factor
Rule 230   term -> term multiplying factor
Rule 231   multiplying -> *
Rule 232   multiplying -> /
Rule 233   multiplying -> MOD
Rule 234   multiplying -> REM
Rule 235   factor -> primary
Rule 236   factor -> NOT primary
Rule 237   factor -> primary DOUBLESTAR primary
Rule 238   factor -> ABS primary
Rule 239   primary -> literal
Rule 240   primary -> name
Rule 241   primary -> allocator
Rule 242   primary -> qualified
Rule 243   primary -> parenthesized_primary
Rule 244   parenthesized_primary -> aggregate
Rule 245   parenthesized_primary -> ( expression )
Rule 246   qualified -> name SINGLEQUOTE parenthesized_primary
Rule 247   allocator -> NEW name
Rule 248   allocator -> NEW qualified
Rule 249   statement_s -> statement
Rule 250   statement_s -> statement_s m statement
Rule 251   statement -> unlabeled
Rule 252   statement -> label statement
Rule 253   unlabeled -> simple_stmt
Rule 254   unlabeled -> compound_stmt
Rule 255   unlabeled -> pragma
Rule 256   simple_stmt -> null_stmt
Rule 257   simple_stmt -> assign_stmt
Rule 258   simple_stmt -> exit_stmt
Rule 259   simple_stmt -> return_stmt
Rule 260   simple_stmt -> goto_stmt
Rule 261   simple_stmt -> procedure_call
Rule 262   simple_stmt -> delay_stmt
Rule 263   simple_stmt -> abort_stmt
Rule 264   simple_stmt -> raise_stmt
Rule 265   simple_stmt -> code_stmt
Rule 266   simple_stmt -> requeue_stmt
Rule 267   simple_stmt -> error ;
Rule 268   compound_stmt -> if_stmt
Rule 269   compound_stmt -> case_stmt
Rule 270   compound_stmt -> loop_stmt
Rule 271   compound_stmt -> block
Rule 272   compound_stmt -> accept_stmt
Rule 273   compound_stmt -> select_stmt
Rule 274   label -> LEFTLABEL ID RIGHTLABEL
Rule 275   null_stmt -> NuLL ;
Rule 276   assign_stmt -> name ASSIGNMENT expression ;
Rule 277   if_stmt -> IF cond_clause_s else_opt END IF ;
Rule 278   cond_clause_s -> cond_clause
Rule 279   cond_clause_s -> cond_clause ELSIF m cond_clause_s
Rule 280   cond_clause -> cond_part m statement_s n
Rule 281   cond_part -> condition THEN
Rule 282   condition -> expression
Rule 283   else_opt -> <empty>
Rule 284   else_opt -> ELSE m statement_s
Rule 285   case_stmt -> case_hdr pragma_s alternative_s END CASE ;
Rule 286   case_hdr -> CASE expression IS
Rule 287   alternative_s -> <empty>
Rule 288   alternative_s -> alternative_s alternative
Rule 289   alternative -> WHEN choice_s ARROW statement_s
Rule 290   loop_stmt -> label_opt iteration m basic_loop id_opt ;
Rule 291   label_opt -> <empty>
Rule 292   label_opt -> ID :
Rule 293   iteration -> <empty>
Rule 294   iteration -> WHILE m condition
Rule 295   iteration -> iter_part reverse_opt discrete_range
Rule 296   iter_part -> FOR ID IN
Rule 297   reverse_opt -> <empty>
Rule 298   reverse_opt -> REVERSE
Rule 299   basic_loop -> LOOP statement_s END LOOP
Rule 300   id_opt -> <empty>
Rule 301   id_opt -> designator
Rule 302   block -> label_opt block_decl block_body END id_opt ;
Rule 303   block_decl -> <empty>
Rule 304   block_decl -> DECLARE decl_part
Rule 305   block_body -> BEGIN handled_stmt_s
Rule 306   handled_stmt_s -> statement_s except_handler_part_opt
Rule 307   except_handler_part_opt -> <empty>
Rule 308   except_handler_part_opt -> except_handler_part
Rule 309   exit_stmt -> EXIT name_opt when_opt ;
Rule 310   name_opt -> <empty>
Rule 311   name_opt -> name
Rule 312   when_opt -> <empty>
Rule 313   when_opt -> WHEN condition
Rule 314   return_stmt -> RETURN ;
Rule 315   return_stmt -> RETURN expression ;
Rule 316   goto_stmt -> GOTO name ;
Rule 317   subprog_decl -> subprog_spec ;
Rule 318   subprog_decl -> generic_subp_inst ;
Rule 319   subprog_decl -> subprog_spec_is_push ABSTRACT ;
Rule 320   subprog_spec -> PROCEDURE compound_name formal_part_opt
Rule 321   subprog_spec -> FUNCTION designator formal_part_opt RETURN name
Rule 322   subprog_spec -> FUNCTION designator
Rule 323   designator -> compound_name
Rule 324   designator -> STRLITERAL
Rule 325   formal_part_opt -> <empty>
Rule 326   formal_part_opt -> formal_part
Rule 327   formal_part -> ( param_s )
Rule 328   param_s -> param
Rule 329   param_s -> param_s ; param
Rule 330   param -> def_id_s : mode mark init_opt
Rule 331   param -> error
Rule 332   mode -> <empty>
Rule 333   mode -> IN
Rule 334   mode -> OUT
Rule 335   mode -> IN OUT
Rule 336   mode -> ACCESS
Rule 337   subprog_spec_is_push -> subprog_spec IS
Rule 338   subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ;
Rule 339   procedure_call -> name ;
Rule 340   pkg_decl -> pkg_spec ;
Rule 341   pkg_decl -> generic_pkg_inst ;
Rule 342   pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt
Rule 343   private_part -> <empty>
Rule 344   private_part -> PRIVATE decl_item_s
Rule 345   c_id_opt -> <empty>
Rule 346   c_id_opt -> compound_name
Rule 347   pkg_start -> PACKAGE BODY compound_name IS
Rule 348   pkg_body -> pkg_start decl_part body_opt END c_id_opt ;
Rule 349   body_opt -> <empty>
Rule 350   body_opt -> block_body
Rule 351   private_type -> tagged_opt limited_opt PRIVATE
Rule 352   limited_opt -> <empty>
Rule 353   limited_opt -> LIMITED
Rule 354   use_clause -> USE name_s ;
Rule 355   use_clause -> USE TYPE name_s ;
Rule 356   name_s -> name
Rule 357   name_s -> name_s , name
Rule 358   rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ;
Rule 359   rename_decl -> def_id_s : EXCEPTION renames ;
Rule 360   rename_decl -> rename_unit
Rule 361   rename_unit -> PACKAGE compound_name renames ;
Rule 362   rename_unit -> subprog_spec renames ;
Rule 363   rename_unit -> generic_formal_part PACKAGE compound_name renames ;
Rule 364   rename_unit -> generic_formal_part subprog_spec renames ;
Rule 365   renames -> RENAMES name
Rule 366   task_decl -> task_spec ;
Rule 367   task_spec -> TASK simple_name task_def
Rule 368   task_spec -> TASK TYPE simple_name discrim_part_opt task_def
Rule 369   task_def -> <empty>
Rule 370   task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt
Rule 371   task_private_opt -> <empty>
Rule 372   task_private_opt -> PRIVATE entry_decl_s rep_spec_s
Rule 373   task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ;
Rule 374   prot_decl -> prot_spec ;
Rule 375   prot_spec -> PROTECTED ID prot_def
Rule 376   prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def
Rule 377   prot_def -> IS prot_op_decl_s prot_private_opt END id_opt
Rule 378   prot_private_opt -> <empty>
Rule 379   prot_private_opt -> PRIVATE prot_elem_decl_s
Rule 380   prot_op_decl_s -> <empty>
Rule 381   prot_op_decl_s -> prot_op_decl_s prot_op_decl
Rule 382   prot_op_decl -> entry_decl
Rule 383   prot_op_decl -> subprog_spec ;
Rule 384   prot_op_decl -> rep_spec
Rule 385   prot_op_decl -> pragma
Rule 386   prot_elem_decl_s -> <empty>
Rule 387   prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl
Rule 388   prot_elem_decl -> prot_op_decl
Rule 389   prot_elem_decl -> comp_decl
Rule 390   prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
Rule 391   prot_op_body_s -> pragma_s
Rule 392   prot_op_body_s -> prot_op_body_s prot_op_body pragma_s
Rule 393   prot_op_body -> entry_body
Rule 394   prot_op_body -> subprog_body
Rule 395   prot_op_body -> subprog_spec ;
Rule 396   entry_decl_s -> pragma_s
Rule 397   entry_decl_s -> entry_decl_s entry_decl pragma_s
Rule 398   entry_decl -> ENTRY ID formal_part_opt ;
Rule 399   entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt ;
Rule 400   entry_body -> ENTRY ID formal_part_opt WHEN condition entry_body_part
Rule 401   entry_body -> ENTRY ID ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
Rule 402   entry_body_part -> ;
Rule 403   entry_body_part -> IS decl_part block_body END id_opt ;
Rule 404   rep_spec_s -> <empty>
Rule 405   rep_spec_s -> rep_spec_s rep_spec pragma_s
Rule 406   entry_call -> procedure_call
Rule 407   accept_stmt -> accept_hdr ;
Rule 408   accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ;
Rule 409   accept_hdr -> ACCEPT entry_name formal_part_opt
Rule 410   entry_name -> simple_name
Rule 411   entry_name -> entry_name ( expression )
Rule 412   delay_stmt -> DELAY expression ;
Rule 413   delay_stmt -> DELAY UNTIL expression ;
Rule 414   select_stmt -> select_wait
Rule 415   select_stmt -> async_select
Rule 416   select_stmt -> timed_entry_call
Rule 417   select_stmt -> cond_entry_call
Rule 418   select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ;
Rule 419   guarded_select_alt -> select_alt
Rule 420   guarded_select_alt -> WHEN condition ARROW select_alt
Rule 421   or_select -> <empty>
Rule 422   or_select -> or_select OR guarded_select_alt
Rule 423   select_alt -> accept_stmt stmts_opt
Rule 424   select_alt -> delay_stmt stmts_opt
Rule 425   select_alt -> TERMINATE ;
Rule 426   delay_or_entry_alt -> delay_stmt stmts_opt
Rule 427   delay_or_entry_alt -> entry_call stmts_opt
Rule 428   async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
Rule 429   timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
Rule 430   cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
Rule 431   stmts_opt -> <empty>
Rule 432   stmts_opt -> statement_s
Rule 433   abort_stmt -> ABORT name_s ;
Rule 434   compilation -> <empty>
Rule 435   compilation -> compilation comp_unit
Rule 436   compilation -> pragma pragma_s
Rule 437   comp_unit -> context_spec private_opt unit pragma_s
Rule 438   comp_unit -> private_opt unit pragma_s
Rule 439   private_opt -> <empty>
Rule 440   private_opt -> PRIVATE
Rule 441   context_spec -> with_clause use_clause_opt
Rule 442   context_spec -> context_spec with_clause use_clause_opt
Rule 443   context_spec -> context_spec pragma
Rule 444   with_clause -> WITH c_name_list ;
Rule 445   use_clause_opt -> <empty>
Rule 446   use_clause_opt -> use_clause_opt use_clause
Rule 447   unit -> pkg_decl
Rule 448   unit -> pkg_body
Rule 449   unit -> subprog_body
Rule 450   unit -> subunit
Rule 451   unit -> generic_decl
Rule 452   unit -> rename_unit
Rule 453   unit -> subprog_decl
Rule 454   subunit -> SEPARATE ( compound_name ) subunit_body
Rule 455   subunit_body -> subprog_body
Rule 456   subunit_body -> pkg_body
Rule 457   subunit_body -> task_body
Rule 458   subunit_body -> prot_body
Rule 459   body_stub -> TASK BODY simple_name IS SEPARATE ;
Rule 460   body_stub -> PACKAGE BODY compound_name IS SEPARATE ;
Rule 461   body_stub -> subprog_spec IS SEPARATE ;
Rule 462   body_stub -> PROTECTED BODY simple_name IS SEPARATE ;
Rule 463   exception_decl -> def_id_s : EXCEPTION ;
Rule 464   except_handler_part -> EXCEPTION exception_handler
Rule 465   except_handler_part -> except_handler_part exception_handler
Rule 466   exception_handler -> WHEN except_choice_s ARROW statement_s
Rule 467   exception_handler -> WHEN ID : except_choice_s ARROW statement_s
Rule 468   except_choice_s -> except_choice
Rule 469   except_choice_s -> except_choice_s | except_choice
Rule 470   except_choice -> name
Rule 471   except_choice -> OTHERS
Rule 472   raise_stmt -> RAISE name_opt ;
Rule 473   requeue_stmt -> REQUEUE name ;
Rule 474   requeue_stmt -> REQUEUE name WITH ABORT ;
Rule 475   generic_decl -> generic_formal_part subprog_spec ;
Rule 476   generic_decl -> generic_formal_part pkg_spec ;
Rule 477   generic_formal_part -> GENERIC
Rule 478   generic_formal_part -> generic_formal_part generic_formal
Rule 479   generic_formal -> param ;
Rule 480   generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ;
Rule 481   generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ;
Rule 482   generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ;
Rule 483   generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ;
Rule 484   generic_formal -> WITH PACKAGE simple_name IS NEW name ;
Rule 485   generic_formal -> use_clause
Rule 486   generic_discrim_part_opt -> <empty>
Rule 487   generic_discrim_part_opt -> discrim_part
Rule 488   generic_discrim_part_opt -> ( BOX )
Rule 489   subp_default -> <empty>
Rule 490   subp_default -> IS name
Rule 491   subp_default -> IS BOX
Rule 492   generic_type_def -> ( BOX )
Rule 493   generic_type_def -> RANGE BOX
Rule 494   generic_type_def -> MOD BOX
Rule 495   generic_type_def -> DELTA BOX
Rule 496   generic_type_def -> DELTA BOX DIGITS BOX
Rule 497   generic_type_def -> DIGITS BOX
Rule 498   generic_type_def -> array_type
Rule 499   generic_type_def -> access_type
Rule 500   generic_type_def -> private_type
Rule 501   generic_type_def -> generic_derived_type
Rule 502   generic_derived_type -> NEW subtype_ind
Rule 503   generic_derived_type -> NEW subtype_ind WITH PRIVATE
Rule 504   generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
Rule 505   generic_subp_inst -> subprog_spec IS generic_inst
Rule 506   generic_pkg_inst -> PACKAGE compound_name IS generic_inst
Rule 507   generic_inst -> NEW name
Rule 508   rep_spec -> attrib_def
Rule 509   rep_spec -> record_type_spec
Rule 510   rep_spec -> address_spec
Rule 511   attrib_def -> FOR mark USE expression ;
Rule 512   record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
Rule 513   align_opt -> <empty>
Rule 514   align_opt -> AT MOD expression ;
Rule 515   comp_loc_s -> <empty>
Rule 516   comp_loc_s -> comp_loc_s mark AT expression RANGE range ;
Rule 517   address_spec -> FOR mark USE AT expression ;
Rule 518   code_stmt -> qualified ;
Rule 519   m -> <empty>
Rule 520   n -> <empty>

Terminals, with rules where they appear

&                    : 228
(                    : 3 39 64 65 82 90 112 170 193 194 195 196 197 245 327 399 401 411 454 483 488 492
)                    : 3 39 64 65 82 90 112 170 193 194 195 196 197 245 327 399 401 411 454 483 488 492
*                    : 231
+                    : 224 226
,                    : 5 25 67 88 92 167 172 198 199 357
-                    : 225 227
.                    : 162 165 177 178 179 180
/                    : 232
:                    : 23 35 110 115 292 330 358 359 463 467
;                    : 2 3 21 23 35 36 50 105 110 111 114 119 267 275 276 277 285 290 302 309 314 315 316 317 318 319 329 338 339 340 341 348 354 355 358 359 361 362 363 364 366 373 374 383 390 395 398 399 402 403 407 408 412 413 418 425 428 429 430 433 444 459 460 461 462 463 472 473 474 475 476 479 480 481 482 483 484 511 512 514 516 517 518
<                    : 215
=                    : 213
>                    : 217
ABORT                : 428 433 474
ABS                  : 238
ABSTRACT             : 59 60 102 319 504
ACCEPT               : 409
ACCESS               : 118 130 131 132 133 134 185 336
ALIASED              : 28 30 86
ALL                  : 132 180
AND                  : 204 207
ARRAY                : 82 83
ARROW                : 7 122 200 289 420 466 467
ASSIGNMENT           : 34 35 276
AT                   : 514 516 517
A_FIRST              : 
A_IMAGE              : 
A_LAST               : 
A_LENGTH             : 
A_POS                : 
A_RANGE              : 
A_VAL                : 
A_VALUE              : 
BEGIN                : 305
BODY                 : 347 373 390 459 460 462
BOX                  : 39 89 483 488 491 492 493 494 495 496 496 497
CASE                 : 119 119 285 286
CHARLITERAL          : 69 168
COMMENT              : 
CONSTANT             : 29 30 35 131
DECLARE              : 304
DELAY                : 412 413
DELTA                : 78 79 184 495 496
DIGITS               : 55 77 79 183 496 497
DO                   : 408
DOUBLEDOT            : 62
DOUBLESTAR           : 237
ELSE                 : 208 284 430
ELSIF                : 279
END                  : 98 119 277 285 299 302 338 342 348 370 373 377 390 403 408 418 428 429 430 512
ENTRY                : 398 399 400 401
EXCEPTION            : 359 463 464
EXIT                 : 309
FOR                  : 296 511 512 517
FUNCTION             : 134 321 322 482
GENERIC              : 477
GEQUAL               : 218
GOTO                 : 316
ID                   : 2 26 36 50 68 163 182 274 292 296 375 398 399 400 401 467
IF                   : 277 277
IN                   : 219 220 296 333 335
INTERFACE            : 
IS                   : 41 50 119 286 337 342 347 370 373 377 390 403 459 460 461 462 480 483 484 490 491 505 506
LEFTLABEL            : 274
LEQUAL               : 216
LIMITED              : 353
LOOP                 : 299 299
MOD                  : 71 233 494 514
NEW                  : 56 57 58 59 60 247 248 483 484 502 503 504 507
NOT                  : 220 236
NOTEQUAL             : 214
NUMLITERAL_BASE_FLOAT : 187
NUMLITERAL_BASE_INT  : 186
NUMLITERAL_FLOAT     : 189
NUMLITERAL_INT       : 188
NuLL                 : 99 105 192 196 197 275
OF                   : 82 83
OR                   : 205 208 422 429
OTHERS               : 127 471
OUT                  : 334 335
OVERRIDING           : 
PACKAGE              : 342 347 361 363 460 483 484 506
PRAGMA               : 2 3
PRIVATE              : 57 59 344 351 372 379 440 503 504
PROCEDURE            : 133 320 481
PROTECTED            : 136 375 376 390 462
RAISE                : 472
RANGE                : 61 63 64 89 493 516
RECORD               : 98 98 99 196 197 512 512
REM                  : 234
RENAMES              : 365
REQUEUE              : 473 474
RETURN               : 134 314 315 321 482
REVERSE              : 298
RIGHTLABEL           : 274
SELECT               : 418 418 428 428 429 429 430 430
SEPARATE             : 454 459 460 461 462
SINGLEQUOTE          : 63 64 161 181 246
STRLITERAL           : 169 324
SUBTYPE              : 50
SYNCHRONIZED         : 
TAGGED               : 101 102
TASK                 : 367 368 373 459
TERMINATE            : 425
THEN                 : 207 281 428
TYPE                 : 36 355 368 376 480
UNTIL                : 413
USE                  : 354 355 511 512 517
WHEN                 : 122 289 313 400 401 420 466 467
WHILE                : 294
WITH                 : 57 58 59 60 195 196 444 474 481 482 483 484 503 504
XOR                  : 206
error                : 21 111 116 176 267 331
|                    : 124 469

Nonterminals, with rules where they appear

abort_stmt           : 263
accept_hdr           : 407 408
accept_stmt          : 272 423
access_opt           : 115
access_type          : 47 499
adding               : 223
address_spec         : 510
aggregate            : 244
aliased_opt          : 84
align_opt            : 512
allocator            : 241
alternative          : 288
alternative_s        : 285 288
array_type           : 32 45 498
assign_stmt          : 257
async_select         : 415
attrib_def           : 508
attribute            : 158
attribute_id         : 161 181
basic_loop           : 290
block                : 271
block_body           : 302 338 350 373 403
block_decl           : 302
body                 : 149
body_opt             : 348
body_stub            : 20
c_id_opt             : 342 348
c_name_list          : 167 444
case_hdr             : 285
case_stmt            : 269
choice               : 123 124
choice_s             : 122 124 200 289
code_stmt            : 265
comp_assoc           : 174 193
comp_decl            : 106 107 389
comp_decl_s          : 103 107
comp_list            : 98 122
comp_loc_s           : 512 516
comp_unit            : 435
compilation          : 1 435
component_subtype_def : 82 83 110
compound_name        : 165 166 167 320 323 342 346 347 361 363 454 460 506
compound_stmt        : 254
cond_clause          : 278 279
cond_clause_s        : 277 279
cond_entry_call      : 417
cond_part            : 280
condition            : 281 294 313 400 401 420
constr_array_type    : 81
constraint           : 51
context_spec         : 437 442 443
decimal_digits_constraint : 54
decl                 : 143
decl_item            : 141 142 150
decl_item_or_body    : 147 148
decl_item_or_body_s1 : 138 148
decl_item_s          : 342 344
decl_item_s1         : 140 142
decl_part            : 304 338 348 373 403
def_id               : 24 25
def_id_s             : 23 25 35 110 115 330 358 359 463
delay_or_entry_alt   : 428
delay_stmt           : 262 424 426 429
derived_type         : 48
designator           : 301 321 322 482
discrete_range       : 91 92 295 399 401
discrete_with_range  : 126 175
discrim_part         : 38 487
discrim_part_opt     : 36 368 376
discrim_spec         : 113 114
discrim_spec_s       : 112 114
else_opt             : 277 418
entry_body           : 393
entry_body_part      : 400 401
entry_call           : 427 429 430
entry_decl           : 382 397
entry_decl_s         : 370 372 397
entry_name           : 409 411
enum_id              : 66 67
enum_id_s            : 65 67
enumeration_type     : 42
except_choice        : 468 469
except_choice_s      : 466 467 469
except_handler_part  : 308 465
except_handler_part_opt : 306
exception_decl       : 17
exception_handler    : 464 465
exit_stmt            : 258
expression           : 6 7 34 35 55 64 71 77 78 79 79 125 173 195 196 200 202 203 245 276 282 286 315 411 412 413 511 514 516 517
factor               : 229 230
fixed_type           : 76
float_type           : 75
formal_part          : 326
formal_part_opt      : 133 134 320 321 398 399 400 401 409 481 482
generic_decl         : 19 451
generic_derived_type : 501
generic_discrim_part_opt : 480
generic_formal       : 478
generic_formal_part  : 363 364 475 476 478
generic_inst         : 505 506
generic_pkg_inst     : 341
generic_subp_inst    : 318
generic_type_def     : 480
goto_stmt            : 260
guarded_select_alt   : 418 422
handled_stmt_s       : 305 408
id_opt               : 290 302 338 370 373 377 390 403 408
if_stmt              : 268
index                : 87 88
index_s              : 82 88
indexed_comp         : 156
init_opt             : 23 110 115 330
integer_type         : 43
iter_discrete_range_s : 90 92
iter_index_constraint : 83
iter_part            : 295 401
iteration            : 290
label                : 252
label_opt            : 290 302
limited_opt          : 97 351
literal              : 239
logical              : 202
loop_stmt            : 270
m                    : 202 203 250 279 280 284 290 294
mark                 : 115 134 161 162 330 511 512 516 517
membership           : 211 212
mode                 : 330
multiplying          : 230
n                    : 280
name                 : 51 52 63 64 89 93 128 170 177 178 179 180 181 212 240 246 247 276 311 316 321 339 356 357 365 470 473 474 482 483 484 490 507
name_opt             : 309 472
name_s               : 354 355 357 433
null_stmt            : 256
number_decl          : 11
numeric_lit          : 190
object_decl          : 10
object_qualifier_opt : 23 358
object_subtype_def   : 23
operator_symbol      : 159 179
or_select            : 418 422
param                : 328 329 479
param_s              : 327 329
parenthesized_primary : 243 246
pkg_body             : 152 448 456
pkg_decl             : 14 447
pkg_spec             : 340 476
pkg_start            : 348
pragma               : 9 146 255 385 436 443
pragma_arg           : 4 5
pragma_arg_s         : 3 5
pragma_s             : 9 98 104 105 107 108 109 109 119 122 285 391 392 396 397 405 436 437 438
primary              : 235 236 237 237 238
private_opt          : 437 438
private_part         : 342
private_type         : 49 500
procedure_call       : 261 406
prot_body            : 154 458
prot_decl            : 16
prot_def             : 375 376
prot_elem_decl       : 387
prot_elem_decl_s     : 379 387
prot_op_body         : 392
prot_op_body_s       : 390 392
prot_op_decl         : 381 388
prot_op_decl_s       : 377 381
prot_opt             : 133 134
prot_private_opt     : 377
prot_spec            : 374
qualified            : 242 248 518
raise_stmt           : 264
range                : 61 94 129 211 516
range_constr_opt     : 55 93
range_constraint     : 53 72 96 128
range_spec           : 70 74 78
range_spec_opt       : 77 79
real_type            : 44
record_def           : 58 60 97
record_type          : 46
record_type_spec     : 509
relation             : 201 202 203
relational           : 210
rename_decl          : 18
rename_unit          : 360 452
renames              : 358 359 361 362 363 364
rep_spec             : 145 384 405
rep_spec_s           : 370 372 405
requeue_stmt         : 266
return_stmt          : 259
reverse_opt          : 295
select_alt           : 419 420
select_stmt          : 273
select_wait          : 414
selected_comp        : 157
short_circuit        : 203
simple_expression    : 62 62 209 210 210 211 212 223
simple_name          : 3 7 119 155 160 162 164 165 177 367 368 373 376 390 410 459 462 480 481 483 484
simple_stmt          : 253
start_symbol         : 0
statement            : 249 250 252
statement_s          : 250 280 284 289 299 306 428 430 432 466 467
stmts_opt            : 423 424 426 427 429 429 430
subp_default         : 481 482
subprog_body         : 151 394 449 455
subprog_decl         : 22 453
subprog_spec         : 317 337 362 364 383 395 461 475 505
subprog_spec_is_push : 319 338
subtype_decl         : 13
subtype_ind          : 31 50 56 57 58 59 60 84 130 131 132 358 502 503 504
subunit              : 450
subunit_body         : 454
tagged_opt           : 97 351
task_body            : 153 457
task_decl            : 15
task_def             : 367 368
task_private_opt     : 370
task_spec            : 366
term                 : 221 222 223 230
timed_entry_call     : 416
type_completion      : 36
type_decl            : 12
type_def             : 41
unary                : 221
unconstr_array_type  : 80
unit                 : 437 438
unlabeled            : 251
use_clause           : 144 446 485
use_clause_opt       : 441 442 446
used_char            : 178 191
value                : 171 172 198 198 199
value_s              : 170 172 195
value_s_2            : 194 199
variant              : 120 121
variant_part         : 104 109
variant_part_opt     : 103
variant_s            : 119 121
when_opt             : 309
with_clause          : 441 442

Parsing method: LALR

state 0

    (0) S' -> . start_symbol
    (1) start_symbol -> . compilation
    (434) compilation -> .
    (435) compilation -> . compilation comp_unit
    (436) compilation -> . pragma pragma_s
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 434 (compilation -> .)
    WITH            reduce using rule 434 (compilation -> .)
    SEPARATE        reduce using rule 434 (compilation -> .)
    PACKAGE         reduce using rule 434 (compilation -> .)
    GENERIC         reduce using rule 434 (compilation -> .)
    PROCEDURE       reduce using rule 434 (compilation -> .)
    FUNCTION        reduce using rule 434 (compilation -> .)
    $end            reduce using rule 434 (compilation -> .)
    PRAGMA          shift and go to state 4

    start_symbol                   shift and go to state 1
    compilation                    shift and go to state 3
    pragma                         shift and go to state 2

state 1

    (0) S' -> start_symbol .



state 2

    (436) compilation -> pragma . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 5

state 3

    (1) start_symbol -> compilation .
    (435) compilation -> compilation . comp_unit
    (437) comp_unit -> . context_spec private_opt unit pragma_s
    (438) comp_unit -> . private_opt unit pragma_s
    (441) context_spec -> . with_clause use_clause_opt
    (442) context_spec -> . context_spec with_clause use_clause_opt
    (443) context_spec -> . context_spec pragma
    (439) private_opt -> .
    (440) private_opt -> . PRIVATE
    (444) with_clause -> . WITH c_name_list ;

    $end            reduce using rule 1 (start_symbol -> compilation .)
    SEPARATE        reduce using rule 439 (private_opt -> .)
    PACKAGE         reduce using rule 439 (private_opt -> .)
    GENERIC         reduce using rule 439 (private_opt -> .)
    PROCEDURE       reduce using rule 439 (private_opt -> .)
    FUNCTION        reduce using rule 439 (private_opt -> .)
    PRIVATE         shift and go to state 7
    WITH            shift and go to state 11

    context_spec                   shift and go to state 6
    with_clause                    shift and go to state 8
    private_opt                    shift and go to state 9
    comp_unit                      shift and go to state 10

state 4

    (2) pragma -> PRAGMA . ID ;
    (3) pragma -> PRAGMA . simple_name ( pragma_arg_s ) ;
    (163) simple_name -> . ID

    ID              shift and go to state 12

    simple_name                    shift and go to state 13

state 5

    (436) compilation -> pragma pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 436 (compilation -> pragma pragma_s .)
    WITH            reduce using rule 436 (compilation -> pragma pragma_s .)
    SEPARATE        reduce using rule 436 (compilation -> pragma pragma_s .)
    PACKAGE         reduce using rule 436 (compilation -> pragma pragma_s .)
    GENERIC         reduce using rule 436 (compilation -> pragma pragma_s .)
    PROCEDURE       reduce using rule 436 (compilation -> pragma pragma_s .)
    FUNCTION        reduce using rule 436 (compilation -> pragma pragma_s .)
    $end            reduce using rule 436 (compilation -> pragma pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 6

    (437) comp_unit -> context_spec . private_opt unit pragma_s
    (442) context_spec -> context_spec . with_clause use_clause_opt
    (443) context_spec -> context_spec . pragma
    (439) private_opt -> .
    (440) private_opt -> . PRIVATE
    (444) with_clause -> . WITH c_name_list ;
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    SEPARATE        reduce using rule 439 (private_opt -> .)
    PACKAGE         reduce using rule 439 (private_opt -> .)
    GENERIC         reduce using rule 439 (private_opt -> .)
    PROCEDURE       reduce using rule 439 (private_opt -> .)
    FUNCTION        reduce using rule 439 (private_opt -> .)
    PRIVATE         shift and go to state 7
    WITH            shift and go to state 11
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 15
    with_clause                    shift and go to state 16
    private_opt                    shift and go to state 17

state 7

    (440) private_opt -> PRIVATE .

    SEPARATE        reduce using rule 440 (private_opt -> PRIVATE .)
    PACKAGE         reduce using rule 440 (private_opt -> PRIVATE .)
    GENERIC         reduce using rule 440 (private_opt -> PRIVATE .)
    PROCEDURE       reduce using rule 440 (private_opt -> PRIVATE .)
    FUNCTION        reduce using rule 440 (private_opt -> PRIVATE .)


state 8

    (441) context_spec -> with_clause . use_clause_opt
    (445) use_clause_opt -> .
    (446) use_clause_opt -> . use_clause_opt use_clause

    USE             reduce using rule 445 (use_clause_opt -> .)
    PRIVATE         reduce using rule 445 (use_clause_opt -> .)
    WITH            reduce using rule 445 (use_clause_opt -> .)
    PRAGMA          reduce using rule 445 (use_clause_opt -> .)
    SEPARATE        reduce using rule 445 (use_clause_opt -> .)
    PACKAGE         reduce using rule 445 (use_clause_opt -> .)
    GENERIC         reduce using rule 445 (use_clause_opt -> .)
    PROCEDURE       reduce using rule 445 (use_clause_opt -> .)
    FUNCTION        reduce using rule 445 (use_clause_opt -> .)

    use_clause_opt                 shift and go to state 18

state 9

    (438) comp_unit -> private_opt . unit pragma_s
    (447) unit -> . pkg_decl
    (448) unit -> . pkg_body
    (449) unit -> . subprog_body
    (450) unit -> . subunit
    (451) unit -> . generic_decl
    (452) unit -> . rename_unit
    (453) unit -> . subprog_decl
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (348) pkg_body -> . pkg_start decl_part body_opt END c_id_opt ;
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (454) subunit -> . SEPARATE ( compound_name ) subunit_body
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (347) pkg_start -> . PACKAGE BODY compound_name IS
    (337) subprog_spec_is_push -> . subprog_spec IS
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (505) generic_subp_inst -> . subprog_spec IS generic_inst

    SEPARATE        shift and go to state 20
    PACKAGE         shift and go to state 28
    GENERIC         shift and go to state 21
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37

    subprog_body                   shift and go to state 19
    subprog_decl                   shift and go to state 22
    unit                           shift and go to state 23
    subprog_spec_is_push           shift and go to state 24
    generic_decl                   shift and go to state 25
    subprog_spec                   shift and go to state 26
    subunit                        shift and go to state 27
    generic_subp_inst              shift and go to state 29
    rename_unit                    shift and go to state 30
    pkg_decl                       shift and go to state 32
    pkg_start                      shift and go to state 33
    generic_formal_part            shift and go to state 34
    generic_pkg_inst               shift and go to state 35
    pkg_body                       shift and go to state 36
    pkg_spec                       shift and go to state 38

state 10

    (435) compilation -> compilation comp_unit .

    PRIVATE         reduce using rule 435 (compilation -> compilation comp_unit .)
    WITH            reduce using rule 435 (compilation -> compilation comp_unit .)
    SEPARATE        reduce using rule 435 (compilation -> compilation comp_unit .)
    PACKAGE         reduce using rule 435 (compilation -> compilation comp_unit .)
    GENERIC         reduce using rule 435 (compilation -> compilation comp_unit .)
    PROCEDURE       reduce using rule 435 (compilation -> compilation comp_unit .)
    FUNCTION        reduce using rule 435 (compilation -> compilation comp_unit .)
    $end            reduce using rule 435 (compilation -> compilation comp_unit .)


state 11

    (444) with_clause -> WITH . c_name_list ;
    (166) c_name_list -> . compound_name
    (167) c_name_list -> . c_name_list , compound_name
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    c_name_list                    shift and go to state 39
    compound_name                  shift and go to state 40
    simple_name                    shift and go to state 42

state 12

    (2) pragma -> PRAGMA ID . ;
    (163) simple_name -> ID .

    ;               shift and go to state 43
    (               reduce using rule 163 (simple_name -> ID .)


state 13

    (3) pragma -> PRAGMA simple_name . ( pragma_arg_s ) ;

    (               shift and go to state 44


state 14

    (9) pragma_s -> pragma_s pragma .

    PRAGMA          reduce using rule 9 (pragma_s -> pragma_s pragma .)
    ENTRY           reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PRIVATE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    FOR             reduce using rule 9 (pragma_s -> pragma_s pragma .)
    END             reduce using rule 9 (pragma_s -> pragma_s pragma .)
    WHEN            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    WITH            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    SEPARATE        reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PACKAGE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    GENERIC         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PROCEDURE       reduce using rule 9 (pragma_s -> pragma_s pragma .)
    FUNCTION        reduce using rule 9 (pragma_s -> pragma_s pragma .)
    $end            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    NuLL            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    CASE            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    error           reduce using rule 9 (pragma_s -> pragma_s pragma .)
    ID              reduce using rule 9 (pragma_s -> pragma_s pragma .)


state 15

    (443) context_spec -> context_spec pragma .

    PRIVATE         reduce using rule 443 (context_spec -> context_spec pragma .)
    WITH            reduce using rule 443 (context_spec -> context_spec pragma .)
    PRAGMA          reduce using rule 443 (context_spec -> context_spec pragma .)
    SEPARATE        reduce using rule 443 (context_spec -> context_spec pragma .)
    PACKAGE         reduce using rule 443 (context_spec -> context_spec pragma .)
    GENERIC         reduce using rule 443 (context_spec -> context_spec pragma .)
    PROCEDURE       reduce using rule 443 (context_spec -> context_spec pragma .)
    FUNCTION        reduce using rule 443 (context_spec -> context_spec pragma .)


state 16

    (442) context_spec -> context_spec with_clause . use_clause_opt
    (445) use_clause_opt -> .
    (446) use_clause_opt -> . use_clause_opt use_clause

    USE             reduce using rule 445 (use_clause_opt -> .)
    PRIVATE         reduce using rule 445 (use_clause_opt -> .)
    WITH            reduce using rule 445 (use_clause_opt -> .)
    PRAGMA          reduce using rule 445 (use_clause_opt -> .)
    SEPARATE        reduce using rule 445 (use_clause_opt -> .)
    PACKAGE         reduce using rule 445 (use_clause_opt -> .)
    GENERIC         reduce using rule 445 (use_clause_opt -> .)
    PROCEDURE       reduce using rule 445 (use_clause_opt -> .)
    FUNCTION        reduce using rule 445 (use_clause_opt -> .)

    use_clause_opt                 shift and go to state 45

state 17

    (437) comp_unit -> context_spec private_opt . unit pragma_s
    (447) unit -> . pkg_decl
    (448) unit -> . pkg_body
    (449) unit -> . subprog_body
    (450) unit -> . subunit
    (451) unit -> . generic_decl
    (452) unit -> . rename_unit
    (453) unit -> . subprog_decl
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (348) pkg_body -> . pkg_start decl_part body_opt END c_id_opt ;
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (454) subunit -> . SEPARATE ( compound_name ) subunit_body
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (347) pkg_start -> . PACKAGE BODY compound_name IS
    (337) subprog_spec_is_push -> . subprog_spec IS
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (505) generic_subp_inst -> . subprog_spec IS generic_inst

    SEPARATE        shift and go to state 20
    PACKAGE         shift and go to state 28
    GENERIC         shift and go to state 21
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37

    subprog_body                   shift and go to state 19
    subprog_decl                   shift and go to state 22
    unit                           shift and go to state 46
    subprog_spec_is_push           shift and go to state 24
    generic_decl                   shift and go to state 25
    subprog_spec                   shift and go to state 26
    subunit                        shift and go to state 27
    generic_subp_inst              shift and go to state 29
    rename_unit                    shift and go to state 30
    pkg_decl                       shift and go to state 32
    pkg_start                      shift and go to state 33
    generic_formal_part            shift and go to state 34
    generic_pkg_inst               shift and go to state 35
    pkg_body                       shift and go to state 36
    pkg_spec                       shift and go to state 38

state 18

    (441) context_spec -> with_clause use_clause_opt .
    (446) use_clause_opt -> use_clause_opt . use_clause
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;

    PRIVATE         reduce using rule 441 (context_spec -> with_clause use_clause_opt .)
    WITH            reduce using rule 441 (context_spec -> with_clause use_clause_opt .)
    PRAGMA          reduce using rule 441 (context_spec -> with_clause use_clause_opt .)
    SEPARATE        reduce using rule 441 (context_spec -> with_clause use_clause_opt .)
    PACKAGE         reduce using rule 441 (context_spec -> with_clause use_clause_opt .)
    GENERIC         reduce using rule 441 (context_spec -> with_clause use_clause_opt .)
    PROCEDURE       reduce using rule 441 (context_spec -> with_clause use_clause_opt .)
    FUNCTION        reduce using rule 441 (context_spec -> with_clause use_clause_opt .)
    USE             shift and go to state 47

    use_clause                     shift and go to state 48

state 19

    (449) unit -> subprog_body .

    PRAGMA          reduce using rule 449 (unit -> subprog_body .)
    PRIVATE         reduce using rule 449 (unit -> subprog_body .)
    WITH            reduce using rule 449 (unit -> subprog_body .)
    SEPARATE        reduce using rule 449 (unit -> subprog_body .)
    PACKAGE         reduce using rule 449 (unit -> subprog_body .)
    GENERIC         reduce using rule 449 (unit -> subprog_body .)
    PROCEDURE       reduce using rule 449 (unit -> subprog_body .)
    FUNCTION        reduce using rule 449 (unit -> subprog_body .)
    $end            reduce using rule 449 (unit -> subprog_body .)


state 20

    (454) subunit -> SEPARATE . ( compound_name ) subunit_body

    (               shift and go to state 49


state 21

    (477) generic_formal_part -> GENERIC .

    PACKAGE         reduce using rule 477 (generic_formal_part -> GENERIC .)
    PROCEDURE       reduce using rule 477 (generic_formal_part -> GENERIC .)
    FUNCTION        reduce using rule 477 (generic_formal_part -> GENERIC .)
    TYPE            reduce using rule 477 (generic_formal_part -> GENERIC .)
    WITH            reduce using rule 477 (generic_formal_part -> GENERIC .)
    error           reduce using rule 477 (generic_formal_part -> GENERIC .)
    USE             reduce using rule 477 (generic_formal_part -> GENERIC .)
    ID              reduce using rule 477 (generic_formal_part -> GENERIC .)


state 22

    (453) unit -> subprog_decl .

    PRAGMA          reduce using rule 453 (unit -> subprog_decl .)
    PRIVATE         reduce using rule 453 (unit -> subprog_decl .)
    WITH            reduce using rule 453 (unit -> subprog_decl .)
    SEPARATE        reduce using rule 453 (unit -> subprog_decl .)
    PACKAGE         reduce using rule 453 (unit -> subprog_decl .)
    GENERIC         reduce using rule 453 (unit -> subprog_decl .)
    PROCEDURE       reduce using rule 453 (unit -> subprog_decl .)
    FUNCTION        reduce using rule 453 (unit -> subprog_decl .)
    $end            reduce using rule 453 (unit -> subprog_decl .)


state 23

    (438) comp_unit -> private_opt unit . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 50

state 24

    (338) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
    (319) subprog_decl -> subprog_spec_is_push . ABSTRACT ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (348) pkg_body -> . pkg_start decl_part body_opt END c_id_opt ;
    (373) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (390) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (337) subprog_spec_is_push -> . subprog_spec IS
    (347) pkg_start -> . PACKAGE BODY compound_name IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (26) def_id -> . ID

    ABSTRACT        shift and go to state 81
    BEGIN           reduce using rule 137 (decl_part -> .)
    TASK            shift and go to state 68
    PROTECTED       shift and go to state 52
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    PACKAGE         shift and go to state 73
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 64
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    GENERIC         shift and go to state 21
    ID              shift and go to state 91

    decl                           shift and go to state 51
    subprog_body                   shift and go to state 60
    task_decl                      shift and go to state 61
    type_decl                      shift and go to state 57
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 62
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    subprog_spec_is_push           shift and go to state 24
    decl_part                      shift and go to state 55
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    def_id                         shift and go to state 88
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 86
    def_id_s                       shift and go to state 87
    decl_item_or_body_s1           shift and go to state 72
    decl_item                      shift and go to state 54
    task_spec                      shift and go to state 66
    body                           shift and go to state 63
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    pkg_spec                       shift and go to state 38
    rename_decl                    shift and go to state 89
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 75
    rename_unit                    shift and go to state 90
    generic_formal_part            shift and go to state 34
    subprog_decl                   shift and go to state 59
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    pkg_start                      shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 25

    (451) unit -> generic_decl .

    PRAGMA          reduce using rule 451 (unit -> generic_decl .)
    PRIVATE         reduce using rule 451 (unit -> generic_decl .)
    WITH            reduce using rule 451 (unit -> generic_decl .)
    SEPARATE        reduce using rule 451 (unit -> generic_decl .)
    PACKAGE         reduce using rule 451 (unit -> generic_decl .)
    GENERIC         reduce using rule 451 (unit -> generic_decl .)
    PROCEDURE       reduce using rule 451 (unit -> generic_decl .)
    FUNCTION        reduce using rule 451 (unit -> generic_decl .)
    $end            reduce using rule 451 (unit -> generic_decl .)


state 26

    (362) rename_unit -> subprog_spec . renames ;
    (317) subprog_decl -> subprog_spec . ;
    (337) subprog_spec_is_push -> subprog_spec . IS
    (505) generic_subp_inst -> subprog_spec . IS generic_inst
    (365) renames -> . RENAMES name

    ;               shift and go to state 97
    IS              shift and go to state 96
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 27

    (450) unit -> subunit .

    PRAGMA          reduce using rule 450 (unit -> subunit .)
    PRIVATE         reduce using rule 450 (unit -> subunit .)
    WITH            reduce using rule 450 (unit -> subunit .)
    SEPARATE        reduce using rule 450 (unit -> subunit .)
    PACKAGE         reduce using rule 450 (unit -> subunit .)
    GENERIC         reduce using rule 450 (unit -> subunit .)
    PROCEDURE       reduce using rule 450 (unit -> subunit .)
    FUNCTION        reduce using rule 450 (unit -> subunit .)
    $end            reduce using rule 450 (unit -> subunit .)


state 28

    (361) rename_unit -> PACKAGE . compound_name renames ;
    (342) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (347) pkg_start -> PACKAGE . BODY compound_name IS
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    BODY            shift and go to state 98
    ID              shift and go to state 41

    simple_name                    shift and go to state 42
    compound_name                  shift and go to state 99

state 29

    (318) subprog_decl -> generic_subp_inst . ;

    ;               shift and go to state 100


state 30

    (452) unit -> rename_unit .

    PRAGMA          reduce using rule 452 (unit -> rename_unit .)
    PRIVATE         reduce using rule 452 (unit -> rename_unit .)
    WITH            reduce using rule 452 (unit -> rename_unit .)
    SEPARATE        reduce using rule 452 (unit -> rename_unit .)
    PACKAGE         reduce using rule 452 (unit -> rename_unit .)
    GENERIC         reduce using rule 452 (unit -> rename_unit .)
    PROCEDURE       reduce using rule 452 (unit -> rename_unit .)
    FUNCTION        reduce using rule 452 (unit -> rename_unit .)
    $end            reduce using rule 452 (unit -> rename_unit .)


state 31

    (320) subprog_spec -> PROCEDURE . compound_name formal_part_opt
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    compound_name                  shift and go to state 101
    simple_name                    shift and go to state 42

state 32

    (447) unit -> pkg_decl .

    PRAGMA          reduce using rule 447 (unit -> pkg_decl .)
    PRIVATE         reduce using rule 447 (unit -> pkg_decl .)
    WITH            reduce using rule 447 (unit -> pkg_decl .)
    SEPARATE        reduce using rule 447 (unit -> pkg_decl .)
    PACKAGE         reduce using rule 447 (unit -> pkg_decl .)
    GENERIC         reduce using rule 447 (unit -> pkg_decl .)
    PROCEDURE       reduce using rule 447 (unit -> pkg_decl .)
    FUNCTION        reduce using rule 447 (unit -> pkg_decl .)
    $end            reduce using rule 447 (unit -> pkg_decl .)


state 33

    (348) pkg_body -> pkg_start . decl_part body_opt END c_id_opt ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (348) pkg_body -> . pkg_start decl_part body_opt END c_id_opt ;
    (373) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (390) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (337) subprog_spec_is_push -> . subprog_spec IS
    (347) pkg_start -> . PACKAGE BODY compound_name IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (26) def_id -> . ID

    BEGIN           reduce using rule 137 (decl_part -> .)
    END             reduce using rule 137 (decl_part -> .)
    TASK            shift and go to state 68
    PROTECTED       shift and go to state 52
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    PACKAGE         shift and go to state 73
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 64
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    GENERIC         shift and go to state 21
    ID              shift and go to state 91

    decl                           shift and go to state 51
    subprog_body                   shift and go to state 60
    task_decl                      shift and go to state 61
    type_decl                      shift and go to state 57
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 62
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    pkg_start                      shift and go to state 33
    decl_part                      shift and go to state 102
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    def_id                         shift and go to state 88
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 86
    def_id_s                       shift and go to state 87
    decl_item_or_body_s1           shift and go to state 72
    decl_item                      shift and go to state 54
    task_spec                      shift and go to state 66
    body                           shift and go to state 63
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    pkg_spec                       shift and go to state 38
    rename_decl                    shift and go to state 89
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 75
    rename_unit                    shift and go to state 90
    generic_formal_part            shift and go to state 34
    subprog_decl                   shift and go to state 59
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    subprog_spec_is_push           shift and go to state 24
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 34

    (475) generic_decl -> generic_formal_part . subprog_spec ;
    (476) generic_decl -> generic_formal_part . pkg_spec ;
    (363) rename_unit -> generic_formal_part . PACKAGE compound_name renames ;
    (364) rename_unit -> generic_formal_part . subprog_spec renames ;
    (478) generic_formal_part -> generic_formal_part . generic_formal
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (479) generic_formal -> . param ;
    (480) generic_formal -> . TYPE simple_name generic_discrim_part_opt IS generic_type_def ;
    (481) generic_formal -> . WITH PROCEDURE simple_name formal_part_opt subp_default ;
    (482) generic_formal -> . WITH FUNCTION designator formal_part_opt RETURN name subp_default ;
    (483) generic_formal -> . WITH PACKAGE simple_name IS NEW name ( BOX ) ;
    (484) generic_formal -> . WITH PACKAGE simple_name IS NEW name ;
    (485) generic_formal -> . use_clause
    (330) param -> . def_id_s : mode mark init_opt
    (331) param -> . error
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . ID

    PACKAGE         shift and go to state 107
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    TYPE            shift and go to state 112
    WITH            shift and go to state 103
    error           shift and go to state 110
    USE             shift and go to state 47
    ID              shift and go to state 91

    param                          shift and go to state 104
    subprog_spec                   shift and go to state 105
    def_id_s                       shift and go to state 106
    def_id                         shift and go to state 88
    generic_formal                 shift and go to state 108
    use_clause                     shift and go to state 109
    pkg_spec                       shift and go to state 111

state 35

    (341) pkg_decl -> generic_pkg_inst . ;

    ;               shift and go to state 113


state 36

    (448) unit -> pkg_body .

    PRAGMA          reduce using rule 448 (unit -> pkg_body .)
    PRIVATE         reduce using rule 448 (unit -> pkg_body .)
    WITH            reduce using rule 448 (unit -> pkg_body .)
    SEPARATE        reduce using rule 448 (unit -> pkg_body .)
    PACKAGE         reduce using rule 448 (unit -> pkg_body .)
    GENERIC         reduce using rule 448 (unit -> pkg_body .)
    PROCEDURE       reduce using rule 448 (unit -> pkg_body .)
    FUNCTION        reduce using rule 448 (unit -> pkg_body .)
    $end            reduce using rule 448 (unit -> pkg_body .)


state 37

    (321) subprog_spec -> FUNCTION . designator formal_part_opt RETURN name
    (322) subprog_spec -> FUNCTION . designator
    (323) designator -> . compound_name
    (324) designator -> . STRLITERAL
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    STRLITERAL      shift and go to state 114
    ID              shift and go to state 41

    compound_name                  shift and go to state 116
    designator                     shift and go to state 115
    simple_name                    shift and go to state 42

state 38

    (340) pkg_decl -> pkg_spec . ;

    ;               shift and go to state 117


state 39

    (444) with_clause -> WITH c_name_list . ;
    (167) c_name_list -> c_name_list . , compound_name

    ;               shift and go to state 118
    ,               shift and go to state 119


state 40

    (166) c_name_list -> compound_name .
    (165) compound_name -> compound_name . . simple_name

    ;               reduce using rule 166 (c_name_list -> compound_name .)
    ,               reduce using rule 166 (c_name_list -> compound_name .)
    .               shift and go to state 120


state 41

    (163) simple_name -> ID .

    SINGLEQUOTE     reduce using rule 163 (simple_name -> ID .)
    (               reduce using rule 163 (simple_name -> ID .)
    .               reduce using rule 163 (simple_name -> ID .)
    RANGE           reduce using rule 163 (simple_name -> ID .)
    )               reduce using rule 163 (simple_name -> ID .)
    ,               reduce using rule 163 (simple_name -> ID .)
    DOUBLESTAR      reduce using rule 163 (simple_name -> ID .)
    *               reduce using rule 163 (simple_name -> ID .)
    /               reduce using rule 163 (simple_name -> ID .)
    MOD             reduce using rule 163 (simple_name -> ID .)
    REM             reduce using rule 163 (simple_name -> ID .)
    DOUBLEDOT       reduce using rule 163 (simple_name -> ID .)
    +               reduce using rule 163 (simple_name -> ID .)
    -               reduce using rule 163 (simple_name -> ID .)
    &               reduce using rule 163 (simple_name -> ID .)
    ARROW           reduce using rule 163 (simple_name -> ID .)
    =               reduce using rule 163 (simple_name -> ID .)
    NOTEQUAL        reduce using rule 163 (simple_name -> ID .)
    <               reduce using rule 163 (simple_name -> ID .)
    LEQUAL          reduce using rule 163 (simple_name -> ID .)
    >               reduce using rule 163 (simple_name -> ID .)
    GEQUAL          reduce using rule 163 (simple_name -> ID .)
    IN              reduce using rule 163 (simple_name -> ID .)
    NOT             reduce using rule 163 (simple_name -> ID .)
    AND             reduce using rule 163 (simple_name -> ID .)
    OR              reduce using rule 163 (simple_name -> ID .)
    XOR             reduce using rule 163 (simple_name -> ID .)
    AT              reduce using rule 163 (simple_name -> ID .)
    ASSIGNMENT      reduce using rule 163 (simple_name -> ID .)
    ;               reduce using rule 163 (simple_name -> ID .)
    THEN            reduce using rule 163 (simple_name -> ID .)
    WITH            reduce using rule 163 (simple_name -> ID .)
    |               reduce using rule 163 (simple_name -> ID .)
    IS              reduce using rule 163 (simple_name -> ID .)
    LOOP            reduce using rule 163 (simple_name -> ID .)
    DIGITS          reduce using rule 163 (simple_name -> ID .)
    RENAMES         reduce using rule 163 (simple_name -> ID .)
    WHEN            reduce using rule 163 (simple_name -> ID .)
    DO              reduce using rule 163 (simple_name -> ID .)
    RETURN          reduce using rule 163 (simple_name -> ID .)
    USE             reduce using rule 163 (simple_name -> ID .)


state 42

    (164) compound_name -> simple_name .

    IS              reduce using rule 164 (compound_name -> simple_name .)
    .               reduce using rule 164 (compound_name -> simple_name .)
    RENAMES         reduce using rule 164 (compound_name -> simple_name .)
    ;               reduce using rule 164 (compound_name -> simple_name .)
    (               reduce using rule 164 (compound_name -> simple_name .)
    RETURN          reduce using rule 164 (compound_name -> simple_name .)
    ,               reduce using rule 164 (compound_name -> simple_name .)
    )               reduce using rule 164 (compound_name -> simple_name .)


state 43

    (2) pragma -> PRAGMA ID ; .

    error           reduce using rule 2 (pragma -> PRAGMA ID ; .)
    USE             reduce using rule 2 (pragma -> PRAGMA ID ; .)
    PRAGMA          reduce using rule 2 (pragma -> PRAGMA ID ; .)
    TYPE            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    SUBTYPE         reduce using rule 2 (pragma -> PRAGMA ID ; .)
    TASK            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    PACKAGE         reduce using rule 2 (pragma -> PRAGMA ID ; .)
    PROTECTED       reduce using rule 2 (pragma -> PRAGMA ID ; .)
    FOR             reduce using rule 2 (pragma -> PRAGMA ID ; .)
    GENERIC         reduce using rule 2 (pragma -> PRAGMA ID ; .)
    PROCEDURE       reduce using rule 2 (pragma -> PRAGMA ID ; .)
    FUNCTION        reduce using rule 2 (pragma -> PRAGMA ID ; .)
    ID              reduce using rule 2 (pragma -> PRAGMA ID ; .)
    PRIVATE         reduce using rule 2 (pragma -> PRAGMA ID ; .)
    END             reduce using rule 2 (pragma -> PRAGMA ID ; .)
    ENTRY           reduce using rule 2 (pragma -> PRAGMA ID ; .)
    LEFTLABEL       reduce using rule 2 (pragma -> PRAGMA ID ; .)
    NuLL            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    EXIT            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    RETURN          reduce using rule 2 (pragma -> PRAGMA ID ; .)
    GOTO            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    DELAY           reduce using rule 2 (pragma -> PRAGMA ID ; .)
    ABORT           reduce using rule 2 (pragma -> PRAGMA ID ; .)
    RAISE           reduce using rule 2 (pragma -> PRAGMA ID ; .)
    REQUEUE         reduce using rule 2 (pragma -> PRAGMA ID ; .)
    IF              reduce using rule 2 (pragma -> PRAGMA ID ; .)
    CASE            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    ACCEPT          reduce using rule 2 (pragma -> PRAGMA ID ; .)
    SELECT          reduce using rule 2 (pragma -> PRAGMA ID ; .)
    STRLITERAL      reduce using rule 2 (pragma -> PRAGMA ID ; .)
    WHILE           reduce using rule 2 (pragma -> PRAGMA ID ; .)
    DECLARE         reduce using rule 2 (pragma -> PRAGMA ID ; .)
    LOOP            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    BEGIN           reduce using rule 2 (pragma -> PRAGMA ID ; .)
    WHEN            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    WITH            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    SEPARATE        reduce using rule 2 (pragma -> PRAGMA ID ; .)
    $end            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    OR              reduce using rule 2 (pragma -> PRAGMA ID ; .)
    ELSE            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    EXCEPTION       reduce using rule 2 (pragma -> PRAGMA ID ; .)
    THEN            reduce using rule 2 (pragma -> PRAGMA ID ; .)
    ELSIF           reduce using rule 2 (pragma -> PRAGMA ID ; .)


state 44

    (3) pragma -> PRAGMA simple_name ( . pragma_arg_s ) ;
    (4) pragma_arg_s -> . pragma_arg
    (5) pragma_arg_s -> . pragma_arg_s , pragma_arg
    (6) pragma_arg -> . expression
    (7) pragma_arg -> . simple_name ARROW expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (163) simple_name -> . ID
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    ID              shift and go to state 41
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    pragma_arg                     shift and go to state 124
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 132
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    pragma_arg_s                   shift and go to state 140
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    used_char                      shift and go to state 146
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 154

state 45

    (442) context_spec -> context_spec with_clause use_clause_opt .
    (446) use_clause_opt -> use_clause_opt . use_clause
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;

    PRIVATE         reduce using rule 442 (context_spec -> context_spec with_clause use_clause_opt .)
    WITH            reduce using rule 442 (context_spec -> context_spec with_clause use_clause_opt .)
    PRAGMA          reduce using rule 442 (context_spec -> context_spec with_clause use_clause_opt .)
    SEPARATE        reduce using rule 442 (context_spec -> context_spec with_clause use_clause_opt .)
    PACKAGE         reduce using rule 442 (context_spec -> context_spec with_clause use_clause_opt .)
    GENERIC         reduce using rule 442 (context_spec -> context_spec with_clause use_clause_opt .)
    PROCEDURE       reduce using rule 442 (context_spec -> context_spec with_clause use_clause_opt .)
    FUNCTION        reduce using rule 442 (context_spec -> context_spec with_clause use_clause_opt .)
    USE             shift and go to state 47

    use_clause                     shift and go to state 48

state 46

    (437) comp_unit -> context_spec private_opt unit . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 156

state 47

    (354) use_clause -> USE . name_s ;
    (355) use_clause -> USE . TYPE name_s ;
    (356) name_s -> . name
    (357) name_s -> . name_s , name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    TYPE            shift and go to state 159
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name_s                         shift and go to state 157
    name                           shift and go to state 158
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 48

    (446) use_clause_opt -> use_clause_opt use_clause .

    USE             reduce using rule 446 (use_clause_opt -> use_clause_opt use_clause .)
    PRIVATE         reduce using rule 446 (use_clause_opt -> use_clause_opt use_clause .)
    WITH            reduce using rule 446 (use_clause_opt -> use_clause_opt use_clause .)
    PRAGMA          reduce using rule 446 (use_clause_opt -> use_clause_opt use_clause .)
    SEPARATE        reduce using rule 446 (use_clause_opt -> use_clause_opt use_clause .)
    PACKAGE         reduce using rule 446 (use_clause_opt -> use_clause_opt use_clause .)
    GENERIC         reduce using rule 446 (use_clause_opt -> use_clause_opt use_clause .)
    PROCEDURE       reduce using rule 446 (use_clause_opt -> use_clause_opt use_clause .)
    FUNCTION        reduce using rule 446 (use_clause_opt -> use_clause_opt use_clause .)


state 49

    (454) subunit -> SEPARATE ( . compound_name ) subunit_body
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    compound_name                  shift and go to state 161
    simple_name                    shift and go to state 42

state 50

    (438) comp_unit -> private_opt unit pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 438 (comp_unit -> private_opt unit pragma_s .)
    WITH            reduce using rule 438 (comp_unit -> private_opt unit pragma_s .)
    SEPARATE        reduce using rule 438 (comp_unit -> private_opt unit pragma_s .)
    PACKAGE         reduce using rule 438 (comp_unit -> private_opt unit pragma_s .)
    GENERIC         reduce using rule 438 (comp_unit -> private_opt unit pragma_s .)
    PROCEDURE       reduce using rule 438 (comp_unit -> private_opt unit pragma_s .)
    FUNCTION        reduce using rule 438 (comp_unit -> private_opt unit pragma_s .)
    $end            reduce using rule 438 (comp_unit -> private_opt unit pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 51

    (143) decl_item -> decl .

    TASK            reduce using rule 143 (decl_item -> decl .)
    PROTECTED       reduce using rule 143 (decl_item -> decl .)
    error           reduce using rule 143 (decl_item -> decl .)
    USE             reduce using rule 143 (decl_item -> decl .)
    PRAGMA          reduce using rule 143 (decl_item -> decl .)
    PACKAGE         reduce using rule 143 (decl_item -> decl .)
    TYPE            reduce using rule 143 (decl_item -> decl .)
    SUBTYPE         reduce using rule 143 (decl_item -> decl .)
    FOR             reduce using rule 143 (decl_item -> decl .)
    PROCEDURE       reduce using rule 143 (decl_item -> decl .)
    FUNCTION        reduce using rule 143 (decl_item -> decl .)
    GENERIC         reduce using rule 143 (decl_item -> decl .)
    ID              reduce using rule 143 (decl_item -> decl .)
    BEGIN           reduce using rule 143 (decl_item -> decl .)
    END             reduce using rule 143 (decl_item -> decl .)
    PRIVATE         reduce using rule 143 (decl_item -> decl .)


state 52

    (390) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt ;
    (462) body_stub -> PROTECTED . BODY simple_name IS SEPARATE ;
    (375) prot_spec -> PROTECTED . ID prot_def
    (376) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def

    BODY            shift and go to state 162
    ID              shift and go to state 164
    TYPE            shift and go to state 163


state 53

    (510) rep_spec -> address_spec .

    error           reduce using rule 510 (rep_spec -> address_spec .)
    USE             reduce using rule 510 (rep_spec -> address_spec .)
    PRAGMA          reduce using rule 510 (rep_spec -> address_spec .)
    TYPE            reduce using rule 510 (rep_spec -> address_spec .)
    SUBTYPE         reduce using rule 510 (rep_spec -> address_spec .)
    TASK            reduce using rule 510 (rep_spec -> address_spec .)
    PACKAGE         reduce using rule 510 (rep_spec -> address_spec .)
    PROTECTED       reduce using rule 510 (rep_spec -> address_spec .)
    FOR             reduce using rule 510 (rep_spec -> address_spec .)
    GENERIC         reduce using rule 510 (rep_spec -> address_spec .)
    PROCEDURE       reduce using rule 510 (rep_spec -> address_spec .)
    FUNCTION        reduce using rule 510 (rep_spec -> address_spec .)
    ID              reduce using rule 510 (rep_spec -> address_spec .)
    END             reduce using rule 510 (rep_spec -> address_spec .)
    BEGIN           reduce using rule 510 (rep_spec -> address_spec .)
    ENTRY           reduce using rule 510 (rep_spec -> address_spec .)
    PRIVATE         reduce using rule 510 (rep_spec -> address_spec .)


state 54

    (150) decl_item_or_body -> decl_item .

    TASK            reduce using rule 150 (decl_item_or_body -> decl_item .)
    PROTECTED       reduce using rule 150 (decl_item_or_body -> decl_item .)
    error           reduce using rule 150 (decl_item_or_body -> decl_item .)
    USE             reduce using rule 150 (decl_item_or_body -> decl_item .)
    PRAGMA          reduce using rule 150 (decl_item_or_body -> decl_item .)
    PACKAGE         reduce using rule 150 (decl_item_or_body -> decl_item .)
    TYPE            reduce using rule 150 (decl_item_or_body -> decl_item .)
    SUBTYPE         reduce using rule 150 (decl_item_or_body -> decl_item .)
    FOR             reduce using rule 150 (decl_item_or_body -> decl_item .)
    PROCEDURE       reduce using rule 150 (decl_item_or_body -> decl_item .)
    FUNCTION        reduce using rule 150 (decl_item_or_body -> decl_item .)
    GENERIC         reduce using rule 150 (decl_item_or_body -> decl_item .)
    ID              reduce using rule 150 (decl_item_or_body -> decl_item .)
    BEGIN           reduce using rule 150 (decl_item_or_body -> decl_item .)
    END             reduce using rule 150 (decl_item_or_body -> decl_item .)


state 55

    (338) subprog_body -> subprog_spec_is_push decl_part . block_body END id_opt ;
    (305) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 165

    block_body                     shift and go to state 166

state 56

    (16) decl -> prot_decl .

    TASK            reduce using rule 16 (decl -> prot_decl .)
    PROTECTED       reduce using rule 16 (decl -> prot_decl .)
    error           reduce using rule 16 (decl -> prot_decl .)
    USE             reduce using rule 16 (decl -> prot_decl .)
    PRAGMA          reduce using rule 16 (decl -> prot_decl .)
    PACKAGE         reduce using rule 16 (decl -> prot_decl .)
    TYPE            reduce using rule 16 (decl -> prot_decl .)
    SUBTYPE         reduce using rule 16 (decl -> prot_decl .)
    FOR             reduce using rule 16 (decl -> prot_decl .)
    PROCEDURE       reduce using rule 16 (decl -> prot_decl .)
    FUNCTION        reduce using rule 16 (decl -> prot_decl .)
    GENERIC         reduce using rule 16 (decl -> prot_decl .)
    ID              reduce using rule 16 (decl -> prot_decl .)
    BEGIN           reduce using rule 16 (decl -> prot_decl .)
    END             reduce using rule 16 (decl -> prot_decl .)
    PRIVATE         reduce using rule 16 (decl -> prot_decl .)


state 57

    (12) decl -> type_decl .

    TASK            reduce using rule 12 (decl -> type_decl .)
    PROTECTED       reduce using rule 12 (decl -> type_decl .)
    error           reduce using rule 12 (decl -> type_decl .)
    USE             reduce using rule 12 (decl -> type_decl .)
    PRAGMA          reduce using rule 12 (decl -> type_decl .)
    PACKAGE         reduce using rule 12 (decl -> type_decl .)
    TYPE            reduce using rule 12 (decl -> type_decl .)
    SUBTYPE         reduce using rule 12 (decl -> type_decl .)
    FOR             reduce using rule 12 (decl -> type_decl .)
    PROCEDURE       reduce using rule 12 (decl -> type_decl .)
    FUNCTION        reduce using rule 12 (decl -> type_decl .)
    GENERIC         reduce using rule 12 (decl -> type_decl .)
    ID              reduce using rule 12 (decl -> type_decl .)
    BEGIN           reduce using rule 12 (decl -> type_decl .)
    END             reduce using rule 12 (decl -> type_decl .)
    PRIVATE         reduce using rule 12 (decl -> type_decl .)


state 58

    (14) decl -> pkg_decl .

    TASK            reduce using rule 14 (decl -> pkg_decl .)
    PROTECTED       reduce using rule 14 (decl -> pkg_decl .)
    error           reduce using rule 14 (decl -> pkg_decl .)
    USE             reduce using rule 14 (decl -> pkg_decl .)
    PRAGMA          reduce using rule 14 (decl -> pkg_decl .)
    PACKAGE         reduce using rule 14 (decl -> pkg_decl .)
    TYPE            reduce using rule 14 (decl -> pkg_decl .)
    SUBTYPE         reduce using rule 14 (decl -> pkg_decl .)
    FOR             reduce using rule 14 (decl -> pkg_decl .)
    PROCEDURE       reduce using rule 14 (decl -> pkg_decl .)
    FUNCTION        reduce using rule 14 (decl -> pkg_decl .)
    GENERIC         reduce using rule 14 (decl -> pkg_decl .)
    ID              reduce using rule 14 (decl -> pkg_decl .)
    BEGIN           reduce using rule 14 (decl -> pkg_decl .)
    END             reduce using rule 14 (decl -> pkg_decl .)
    PRIVATE         reduce using rule 14 (decl -> pkg_decl .)


state 59

    (22) decl -> subprog_decl .

    TASK            reduce using rule 22 (decl -> subprog_decl .)
    PROTECTED       reduce using rule 22 (decl -> subprog_decl .)
    error           reduce using rule 22 (decl -> subprog_decl .)
    USE             reduce using rule 22 (decl -> subprog_decl .)
    PRAGMA          reduce using rule 22 (decl -> subprog_decl .)
    PACKAGE         reduce using rule 22 (decl -> subprog_decl .)
    TYPE            reduce using rule 22 (decl -> subprog_decl .)
    SUBTYPE         reduce using rule 22 (decl -> subprog_decl .)
    FOR             reduce using rule 22 (decl -> subprog_decl .)
    PROCEDURE       reduce using rule 22 (decl -> subprog_decl .)
    FUNCTION        reduce using rule 22 (decl -> subprog_decl .)
    GENERIC         reduce using rule 22 (decl -> subprog_decl .)
    ID              reduce using rule 22 (decl -> subprog_decl .)
    BEGIN           reduce using rule 22 (decl -> subprog_decl .)
    END             reduce using rule 22 (decl -> subprog_decl .)
    PRIVATE         reduce using rule 22 (decl -> subprog_decl .)


state 60

    (151) body -> subprog_body .

    TASK            reduce using rule 151 (body -> subprog_body .)
    PROTECTED       reduce using rule 151 (body -> subprog_body .)
    error           reduce using rule 151 (body -> subprog_body .)
    USE             reduce using rule 151 (body -> subprog_body .)
    PRAGMA          reduce using rule 151 (body -> subprog_body .)
    PACKAGE         reduce using rule 151 (body -> subprog_body .)
    TYPE            reduce using rule 151 (body -> subprog_body .)
    SUBTYPE         reduce using rule 151 (body -> subprog_body .)
    FOR             reduce using rule 151 (body -> subprog_body .)
    PROCEDURE       reduce using rule 151 (body -> subprog_body .)
    FUNCTION        reduce using rule 151 (body -> subprog_body .)
    GENERIC         reduce using rule 151 (body -> subprog_body .)
    ID              reduce using rule 151 (body -> subprog_body .)
    BEGIN           reduce using rule 151 (body -> subprog_body .)
    END             reduce using rule 151 (body -> subprog_body .)


state 61

    (15) decl -> task_decl .

    TASK            reduce using rule 15 (decl -> task_decl .)
    PROTECTED       reduce using rule 15 (decl -> task_decl .)
    error           reduce using rule 15 (decl -> task_decl .)
    USE             reduce using rule 15 (decl -> task_decl .)
    PRAGMA          reduce using rule 15 (decl -> task_decl .)
    PACKAGE         reduce using rule 15 (decl -> task_decl .)
    TYPE            reduce using rule 15 (decl -> task_decl .)
    SUBTYPE         reduce using rule 15 (decl -> task_decl .)
    FOR             reduce using rule 15 (decl -> task_decl .)
    PROCEDURE       reduce using rule 15 (decl -> task_decl .)
    FUNCTION        reduce using rule 15 (decl -> task_decl .)
    GENERIC         reduce using rule 15 (decl -> task_decl .)
    ID              reduce using rule 15 (decl -> task_decl .)
    BEGIN           reduce using rule 15 (decl -> task_decl .)
    END             reduce using rule 15 (decl -> task_decl .)
    PRIVATE         reduce using rule 15 (decl -> task_decl .)


state 62

    (13) decl -> subtype_decl .

    TASK            reduce using rule 13 (decl -> subtype_decl .)
    PROTECTED       reduce using rule 13 (decl -> subtype_decl .)
    error           reduce using rule 13 (decl -> subtype_decl .)
    USE             reduce using rule 13 (decl -> subtype_decl .)
    PRAGMA          reduce using rule 13 (decl -> subtype_decl .)
    PACKAGE         reduce using rule 13 (decl -> subtype_decl .)
    TYPE            reduce using rule 13 (decl -> subtype_decl .)
    SUBTYPE         reduce using rule 13 (decl -> subtype_decl .)
    FOR             reduce using rule 13 (decl -> subtype_decl .)
    PROCEDURE       reduce using rule 13 (decl -> subtype_decl .)
    FUNCTION        reduce using rule 13 (decl -> subtype_decl .)
    GENERIC         reduce using rule 13 (decl -> subtype_decl .)
    ID              reduce using rule 13 (decl -> subtype_decl .)
    BEGIN           reduce using rule 13 (decl -> subtype_decl .)
    END             reduce using rule 13 (decl -> subtype_decl .)
    PRIVATE         reduce using rule 13 (decl -> subtype_decl .)


state 63

    (149) decl_item_or_body -> body .

    TASK            reduce using rule 149 (decl_item_or_body -> body .)
    PROTECTED       reduce using rule 149 (decl_item_or_body -> body .)
    error           reduce using rule 149 (decl_item_or_body -> body .)
    USE             reduce using rule 149 (decl_item_or_body -> body .)
    PRAGMA          reduce using rule 149 (decl_item_or_body -> body .)
    PACKAGE         reduce using rule 149 (decl_item_or_body -> body .)
    TYPE            reduce using rule 149 (decl_item_or_body -> body .)
    SUBTYPE         reduce using rule 149 (decl_item_or_body -> body .)
    FOR             reduce using rule 149 (decl_item_or_body -> body .)
    PROCEDURE       reduce using rule 149 (decl_item_or_body -> body .)
    FUNCTION        reduce using rule 149 (decl_item_or_body -> body .)
    GENERIC         reduce using rule 149 (decl_item_or_body -> body .)
    ID              reduce using rule 149 (decl_item_or_body -> body .)
    BEGIN           reduce using rule 149 (decl_item_or_body -> body .)
    END             reduce using rule 149 (decl_item_or_body -> body .)


state 64

    (511) attrib_def -> FOR . mark USE expression ;
    (512) record_type_spec -> FOR . mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> FOR . mark USE AT expression ;
    (160) mark -> . simple_name
    (161) mark -> . mark SINGLEQUOTE attribute_id
    (162) mark -> . mark . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    mark                           shift and go to state 167
    simple_name                    shift and go to state 168

state 65

    (10) decl -> object_decl .

    TASK            reduce using rule 10 (decl -> object_decl .)
    PROTECTED       reduce using rule 10 (decl -> object_decl .)
    error           reduce using rule 10 (decl -> object_decl .)
    USE             reduce using rule 10 (decl -> object_decl .)
    PRAGMA          reduce using rule 10 (decl -> object_decl .)
    PACKAGE         reduce using rule 10 (decl -> object_decl .)
    TYPE            reduce using rule 10 (decl -> object_decl .)
    SUBTYPE         reduce using rule 10 (decl -> object_decl .)
    FOR             reduce using rule 10 (decl -> object_decl .)
    PROCEDURE       reduce using rule 10 (decl -> object_decl .)
    FUNCTION        reduce using rule 10 (decl -> object_decl .)
    GENERIC         reduce using rule 10 (decl -> object_decl .)
    ID              reduce using rule 10 (decl -> object_decl .)
    BEGIN           reduce using rule 10 (decl -> object_decl .)
    END             reduce using rule 10 (decl -> object_decl .)
    PRIVATE         reduce using rule 10 (decl -> object_decl .)


state 66

    (366) task_decl -> task_spec . ;

    ;               shift and go to state 169


state 67

    (144) decl_item -> use_clause .

    TASK            reduce using rule 144 (decl_item -> use_clause .)
    PROTECTED       reduce using rule 144 (decl_item -> use_clause .)
    error           reduce using rule 144 (decl_item -> use_clause .)
    USE             reduce using rule 144 (decl_item -> use_clause .)
    PRAGMA          reduce using rule 144 (decl_item -> use_clause .)
    PACKAGE         reduce using rule 144 (decl_item -> use_clause .)
    TYPE            reduce using rule 144 (decl_item -> use_clause .)
    SUBTYPE         reduce using rule 144 (decl_item -> use_clause .)
    FOR             reduce using rule 144 (decl_item -> use_clause .)
    PROCEDURE       reduce using rule 144 (decl_item -> use_clause .)
    FUNCTION        reduce using rule 144 (decl_item -> use_clause .)
    GENERIC         reduce using rule 144 (decl_item -> use_clause .)
    ID              reduce using rule 144 (decl_item -> use_clause .)
    BEGIN           reduce using rule 144 (decl_item -> use_clause .)
    END             reduce using rule 144 (decl_item -> use_clause .)
    PRIVATE         reduce using rule 144 (decl_item -> use_clause .)


state 68

    (373) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt ;
    (459) body_stub -> TASK . BODY simple_name IS SEPARATE ;
    (367) task_spec -> TASK . simple_name task_def
    (368) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
    (163) simple_name -> . ID

    BODY            shift and go to state 170
    TYPE            shift and go to state 171
    ID              shift and go to state 41

    simple_name                    shift and go to state 172

state 69

    (509) rep_spec -> record_type_spec .

    error           reduce using rule 509 (rep_spec -> record_type_spec .)
    USE             reduce using rule 509 (rep_spec -> record_type_spec .)
    PRAGMA          reduce using rule 509 (rep_spec -> record_type_spec .)
    TYPE            reduce using rule 509 (rep_spec -> record_type_spec .)
    SUBTYPE         reduce using rule 509 (rep_spec -> record_type_spec .)
    TASK            reduce using rule 509 (rep_spec -> record_type_spec .)
    PACKAGE         reduce using rule 509 (rep_spec -> record_type_spec .)
    PROTECTED       reduce using rule 509 (rep_spec -> record_type_spec .)
    FOR             reduce using rule 509 (rep_spec -> record_type_spec .)
    GENERIC         reduce using rule 509 (rep_spec -> record_type_spec .)
    PROCEDURE       reduce using rule 509 (rep_spec -> record_type_spec .)
    FUNCTION        reduce using rule 509 (rep_spec -> record_type_spec .)
    ID              reduce using rule 509 (rep_spec -> record_type_spec .)
    END             reduce using rule 509 (rep_spec -> record_type_spec .)
    BEGIN           reduce using rule 509 (rep_spec -> record_type_spec .)
    ENTRY           reduce using rule 509 (rep_spec -> record_type_spec .)
    PRIVATE         reduce using rule 509 (rep_spec -> record_type_spec .)


state 70

    (19) decl -> generic_decl .

    TASK            reduce using rule 19 (decl -> generic_decl .)
    PROTECTED       reduce using rule 19 (decl -> generic_decl .)
    error           reduce using rule 19 (decl -> generic_decl .)
    USE             reduce using rule 19 (decl -> generic_decl .)
    PRAGMA          reduce using rule 19 (decl -> generic_decl .)
    PACKAGE         reduce using rule 19 (decl -> generic_decl .)
    TYPE            reduce using rule 19 (decl -> generic_decl .)
    SUBTYPE         reduce using rule 19 (decl -> generic_decl .)
    FOR             reduce using rule 19 (decl -> generic_decl .)
    PROCEDURE       reduce using rule 19 (decl -> generic_decl .)
    FUNCTION        reduce using rule 19 (decl -> generic_decl .)
    GENERIC         reduce using rule 19 (decl -> generic_decl .)
    ID              reduce using rule 19 (decl -> generic_decl .)
    BEGIN           reduce using rule 19 (decl -> generic_decl .)
    END             reduce using rule 19 (decl -> generic_decl .)
    PRIVATE         reduce using rule 19 (decl -> generic_decl .)


state 71

    (508) rep_spec -> attrib_def .

    error           reduce using rule 508 (rep_spec -> attrib_def .)
    USE             reduce using rule 508 (rep_spec -> attrib_def .)
    PRAGMA          reduce using rule 508 (rep_spec -> attrib_def .)
    TYPE            reduce using rule 508 (rep_spec -> attrib_def .)
    SUBTYPE         reduce using rule 508 (rep_spec -> attrib_def .)
    TASK            reduce using rule 508 (rep_spec -> attrib_def .)
    PACKAGE         reduce using rule 508 (rep_spec -> attrib_def .)
    PROTECTED       reduce using rule 508 (rep_spec -> attrib_def .)
    FOR             reduce using rule 508 (rep_spec -> attrib_def .)
    GENERIC         reduce using rule 508 (rep_spec -> attrib_def .)
    PROCEDURE       reduce using rule 508 (rep_spec -> attrib_def .)
    FUNCTION        reduce using rule 508 (rep_spec -> attrib_def .)
    ID              reduce using rule 508 (rep_spec -> attrib_def .)
    END             reduce using rule 508 (rep_spec -> attrib_def .)
    BEGIN           reduce using rule 508 (rep_spec -> attrib_def .)
    ENTRY           reduce using rule 508 (rep_spec -> attrib_def .)
    PRIVATE         reduce using rule 508 (rep_spec -> attrib_def .)


state 72

    (138) decl_part -> decl_item_or_body_s1 .
    (148) decl_item_or_body_s1 -> decl_item_or_body_s1 . decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (348) pkg_body -> . pkg_start decl_part body_opt END c_id_opt ;
    (373) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (390) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (337) subprog_spec_is_push -> . subprog_spec IS
    (347) pkg_start -> . PACKAGE BODY compound_name IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (26) def_id -> . ID

    BEGIN           reduce using rule 138 (decl_part -> decl_item_or_body_s1 .)
    END             reduce using rule 138 (decl_part -> decl_item_or_body_s1 .)
    TASK            shift and go to state 68
    PROTECTED       shift and go to state 52
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    PACKAGE         shift and go to state 73
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 64
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    GENERIC         shift and go to state 21
    ID              shift and go to state 91

    decl                           shift and go to state 51
    subprog_body                   shift and go to state 60
    task_decl                      shift and go to state 61
    type_decl                      shift and go to state 57
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 62
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    subprog_spec_is_push           shift and go to state 24
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    def_id                         shift and go to state 88
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 86
    def_id_s                       shift and go to state 87
    decl_item                      shift and go to state 54
    task_spec                      shift and go to state 66
    body                           shift and go to state 63
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    pkg_spec                       shift and go to state 38
    rename_decl                    shift and go to state 89
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 75
    rename_unit                    shift and go to state 90
    generic_formal_part            shift and go to state 34
    subprog_decl                   shift and go to state 59
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    pkg_start                      shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 173
    number_decl                    shift and go to state 93

state 73

    (347) pkg_start -> PACKAGE . BODY compound_name IS
    (460) body_stub -> PACKAGE . BODY compound_name IS SEPARATE ;
    (342) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (361) rename_unit -> PACKAGE . compound_name renames ;
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    BODY            shift and go to state 174
    ID              shift and go to state 41

    simple_name                    shift and go to state 42
    compound_name                  shift and go to state 175

state 74

    (20) decl -> body_stub .

    TASK            reduce using rule 20 (decl -> body_stub .)
    PROTECTED       reduce using rule 20 (decl -> body_stub .)
    error           reduce using rule 20 (decl -> body_stub .)
    USE             reduce using rule 20 (decl -> body_stub .)
    PRAGMA          reduce using rule 20 (decl -> body_stub .)
    PACKAGE         reduce using rule 20 (decl -> body_stub .)
    TYPE            reduce using rule 20 (decl -> body_stub .)
    SUBTYPE         reduce using rule 20 (decl -> body_stub .)
    FOR             reduce using rule 20 (decl -> body_stub .)
    PROCEDURE       reduce using rule 20 (decl -> body_stub .)
    FUNCTION        reduce using rule 20 (decl -> body_stub .)
    GENERIC         reduce using rule 20 (decl -> body_stub .)
    ID              reduce using rule 20 (decl -> body_stub .)
    BEGIN           reduce using rule 20 (decl -> body_stub .)
    END             reduce using rule 20 (decl -> body_stub .)
    PRIVATE         reduce using rule 20 (decl -> body_stub .)


state 75

    (146) decl_item -> pragma .

    TASK            reduce using rule 146 (decl_item -> pragma .)
    PROTECTED       reduce using rule 146 (decl_item -> pragma .)
    error           reduce using rule 146 (decl_item -> pragma .)
    USE             reduce using rule 146 (decl_item -> pragma .)
    PRAGMA          reduce using rule 146 (decl_item -> pragma .)
    PACKAGE         reduce using rule 146 (decl_item -> pragma .)
    TYPE            reduce using rule 146 (decl_item -> pragma .)
    SUBTYPE         reduce using rule 146 (decl_item -> pragma .)
    FOR             reduce using rule 146 (decl_item -> pragma .)
    PROCEDURE       reduce using rule 146 (decl_item -> pragma .)
    FUNCTION        reduce using rule 146 (decl_item -> pragma .)
    GENERIC         reduce using rule 146 (decl_item -> pragma .)
    ID              reduce using rule 146 (decl_item -> pragma .)
    BEGIN           reduce using rule 146 (decl_item -> pragma .)
    END             reduce using rule 146 (decl_item -> pragma .)
    PRIVATE         reduce using rule 146 (decl_item -> pragma .)


state 76

    (374) prot_decl -> prot_spec . ;

    ;               shift and go to state 176


state 77

    (152) body -> pkg_body .

    TASK            reduce using rule 152 (body -> pkg_body .)
    PROTECTED       reduce using rule 152 (body -> pkg_body .)
    error           reduce using rule 152 (body -> pkg_body .)
    USE             reduce using rule 152 (body -> pkg_body .)
    PRAGMA          reduce using rule 152 (body -> pkg_body .)
    PACKAGE         reduce using rule 152 (body -> pkg_body .)
    TYPE            reduce using rule 152 (body -> pkg_body .)
    SUBTYPE         reduce using rule 152 (body -> pkg_body .)
    FOR             reduce using rule 152 (body -> pkg_body .)
    PROCEDURE       reduce using rule 152 (body -> pkg_body .)
    FUNCTION        reduce using rule 152 (body -> pkg_body .)
    GENERIC         reduce using rule 152 (body -> pkg_body .)
    ID              reduce using rule 152 (body -> pkg_body .)
    BEGIN           reduce using rule 152 (body -> pkg_body .)
    END             reduce using rule 152 (body -> pkg_body .)


state 78

    (21) decl -> error . ;

    ;               shift and go to state 177


state 79

    (147) decl_item_or_body_s1 -> decl_item_or_body .

    TASK            reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    PROTECTED       reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    error           reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    USE             reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    PRAGMA          reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    PACKAGE         reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    TYPE            reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    SUBTYPE         reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    FOR             reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    PROCEDURE       reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    FUNCTION        reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    GENERIC         reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    ID              reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    BEGIN           reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    END             reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)


state 80

    (36) type_decl -> TYPE . ID discrim_part_opt type_completion ;

    ID              shift and go to state 178


state 81

    (319) subprog_decl -> subprog_spec_is_push ABSTRACT . ;

    ;               shift and go to state 179


state 82

    (145) decl_item -> rep_spec .

    TASK            reduce using rule 145 (decl_item -> rep_spec .)
    PROTECTED       reduce using rule 145 (decl_item -> rep_spec .)
    error           reduce using rule 145 (decl_item -> rep_spec .)
    USE             reduce using rule 145 (decl_item -> rep_spec .)
    PRAGMA          reduce using rule 145 (decl_item -> rep_spec .)
    PACKAGE         reduce using rule 145 (decl_item -> rep_spec .)
    TYPE            reduce using rule 145 (decl_item -> rep_spec .)
    SUBTYPE         reduce using rule 145 (decl_item -> rep_spec .)
    FOR             reduce using rule 145 (decl_item -> rep_spec .)
    PROCEDURE       reduce using rule 145 (decl_item -> rep_spec .)
    FUNCTION        reduce using rule 145 (decl_item -> rep_spec .)
    GENERIC         reduce using rule 145 (decl_item -> rep_spec .)
    ID              reduce using rule 145 (decl_item -> rep_spec .)
    BEGIN           reduce using rule 145 (decl_item -> rep_spec .)
    END             reduce using rule 145 (decl_item -> rep_spec .)
    PRIVATE         reduce using rule 145 (decl_item -> rep_spec .)


state 83

    (153) body -> task_body .

    TASK            reduce using rule 153 (body -> task_body .)
    PROTECTED       reduce using rule 153 (body -> task_body .)
    error           reduce using rule 153 (body -> task_body .)
    USE             reduce using rule 153 (body -> task_body .)
    PRAGMA          reduce using rule 153 (body -> task_body .)
    PACKAGE         reduce using rule 153 (body -> task_body .)
    TYPE            reduce using rule 153 (body -> task_body .)
    SUBTYPE         reduce using rule 153 (body -> task_body .)
    FOR             reduce using rule 153 (body -> task_body .)
    PROCEDURE       reduce using rule 153 (body -> task_body .)
    FUNCTION        reduce using rule 153 (body -> task_body .)
    GENERIC         reduce using rule 153 (body -> task_body .)
    ID              reduce using rule 153 (body -> task_body .)
    BEGIN           reduce using rule 153 (body -> task_body .)
    END             reduce using rule 153 (body -> task_body .)


state 84

    (50) subtype_decl -> SUBTYPE . ID IS subtype_ind ;

    ID              shift and go to state 180


state 85

    (17) decl -> exception_decl .

    TASK            reduce using rule 17 (decl -> exception_decl .)
    PROTECTED       reduce using rule 17 (decl -> exception_decl .)
    error           reduce using rule 17 (decl -> exception_decl .)
    USE             reduce using rule 17 (decl -> exception_decl .)
    PRAGMA          reduce using rule 17 (decl -> exception_decl .)
    PACKAGE         reduce using rule 17 (decl -> exception_decl .)
    TYPE            reduce using rule 17 (decl -> exception_decl .)
    SUBTYPE         reduce using rule 17 (decl -> exception_decl .)
    FOR             reduce using rule 17 (decl -> exception_decl .)
    PROCEDURE       reduce using rule 17 (decl -> exception_decl .)
    FUNCTION        reduce using rule 17 (decl -> exception_decl .)
    GENERIC         reduce using rule 17 (decl -> exception_decl .)
    ID              reduce using rule 17 (decl -> exception_decl .)
    BEGIN           reduce using rule 17 (decl -> exception_decl .)
    END             reduce using rule 17 (decl -> exception_decl .)
    PRIVATE         reduce using rule 17 (decl -> exception_decl .)


state 86

    (337) subprog_spec_is_push -> subprog_spec . IS
    (461) body_stub -> subprog_spec . IS SEPARATE ;
    (317) subprog_decl -> subprog_spec . ;
    (362) rename_unit -> subprog_spec . renames ;
    (505) generic_subp_inst -> subprog_spec . IS generic_inst
    (365) renames -> . RENAMES name

    IS              shift and go to state 181
    ;               shift and go to state 97
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 87

    (23) object_decl -> def_id_s . : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> def_id_s . : CONSTANT ASSIGNMENT expression ;
    (463) exception_decl -> def_id_s . : EXCEPTION ;
    (358) rename_decl -> def_id_s . : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> def_id_s . : EXCEPTION renames ;
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 183
    ,               shift and go to state 182


state 88

    (24) def_id_s -> def_id .

    :               reduce using rule 24 (def_id_s -> def_id .)
    ,               reduce using rule 24 (def_id_s -> def_id .)


state 89

    (18) decl -> rename_decl .

    TASK            reduce using rule 18 (decl -> rename_decl .)
    PROTECTED       reduce using rule 18 (decl -> rename_decl .)
    error           reduce using rule 18 (decl -> rename_decl .)
    USE             reduce using rule 18 (decl -> rename_decl .)
    PRAGMA          reduce using rule 18 (decl -> rename_decl .)
    PACKAGE         reduce using rule 18 (decl -> rename_decl .)
    TYPE            reduce using rule 18 (decl -> rename_decl .)
    SUBTYPE         reduce using rule 18 (decl -> rename_decl .)
    FOR             reduce using rule 18 (decl -> rename_decl .)
    PROCEDURE       reduce using rule 18 (decl -> rename_decl .)
    FUNCTION        reduce using rule 18 (decl -> rename_decl .)
    GENERIC         reduce using rule 18 (decl -> rename_decl .)
    ID              reduce using rule 18 (decl -> rename_decl .)
    BEGIN           reduce using rule 18 (decl -> rename_decl .)
    END             reduce using rule 18 (decl -> rename_decl .)
    PRIVATE         reduce using rule 18 (decl -> rename_decl .)


state 90

    (360) rename_decl -> rename_unit .

    error           reduce using rule 360 (rename_decl -> rename_unit .)
    USE             reduce using rule 360 (rename_decl -> rename_unit .)
    PRAGMA          reduce using rule 360 (rename_decl -> rename_unit .)
    TYPE            reduce using rule 360 (rename_decl -> rename_unit .)
    SUBTYPE         reduce using rule 360 (rename_decl -> rename_unit .)
    TASK            reduce using rule 360 (rename_decl -> rename_unit .)
    PACKAGE         reduce using rule 360 (rename_decl -> rename_unit .)
    PROTECTED       reduce using rule 360 (rename_decl -> rename_unit .)
    FOR             reduce using rule 360 (rename_decl -> rename_unit .)
    GENERIC         reduce using rule 360 (rename_decl -> rename_unit .)
    PROCEDURE       reduce using rule 360 (rename_decl -> rename_unit .)
    FUNCTION        reduce using rule 360 (rename_decl -> rename_unit .)
    ID              reduce using rule 360 (rename_decl -> rename_unit .)
    PRIVATE         reduce using rule 360 (rename_decl -> rename_unit .)
    END             reduce using rule 360 (rename_decl -> rename_unit .)
    BEGIN           reduce using rule 360 (rename_decl -> rename_unit .)


state 91

    (26) def_id -> ID .

    :               reduce using rule 26 (def_id -> ID .)
    ,               reduce using rule 26 (def_id -> ID .)


state 92

    (154) body -> prot_body .

    TASK            reduce using rule 154 (body -> prot_body .)
    PROTECTED       reduce using rule 154 (body -> prot_body .)
    error           reduce using rule 154 (body -> prot_body .)
    USE             reduce using rule 154 (body -> prot_body .)
    PRAGMA          reduce using rule 154 (body -> prot_body .)
    PACKAGE         reduce using rule 154 (body -> prot_body .)
    TYPE            reduce using rule 154 (body -> prot_body .)
    SUBTYPE         reduce using rule 154 (body -> prot_body .)
    FOR             reduce using rule 154 (body -> prot_body .)
    PROCEDURE       reduce using rule 154 (body -> prot_body .)
    FUNCTION        reduce using rule 154 (body -> prot_body .)
    GENERIC         reduce using rule 154 (body -> prot_body .)
    ID              reduce using rule 154 (body -> prot_body .)
    BEGIN           reduce using rule 154 (body -> prot_body .)
    END             reduce using rule 154 (body -> prot_body .)


state 93

    (11) decl -> number_decl .

    TASK            reduce using rule 11 (decl -> number_decl .)
    PROTECTED       reduce using rule 11 (decl -> number_decl .)
    error           reduce using rule 11 (decl -> number_decl .)
    USE             reduce using rule 11 (decl -> number_decl .)
    PRAGMA          reduce using rule 11 (decl -> number_decl .)
    PACKAGE         reduce using rule 11 (decl -> number_decl .)
    TYPE            reduce using rule 11 (decl -> number_decl .)
    SUBTYPE         reduce using rule 11 (decl -> number_decl .)
    FOR             reduce using rule 11 (decl -> number_decl .)
    PROCEDURE       reduce using rule 11 (decl -> number_decl .)
    FUNCTION        reduce using rule 11 (decl -> number_decl .)
    GENERIC         reduce using rule 11 (decl -> number_decl .)
    ID              reduce using rule 11 (decl -> number_decl .)
    BEGIN           reduce using rule 11 (decl -> number_decl .)
    END             reduce using rule 11 (decl -> number_decl .)
    PRIVATE         reduce using rule 11 (decl -> number_decl .)


state 94

    (362) rename_unit -> subprog_spec renames . ;

    ;               shift and go to state 184


state 95

    (365) renames -> RENAMES . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 185
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 96

    (337) subprog_spec_is_push -> subprog_spec IS .
    (505) generic_subp_inst -> subprog_spec IS . generic_inst
    (507) generic_inst -> . NEW name

    ABSTRACT        reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PACKAGE         reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    ID              reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    NEW             shift and go to state 186

    generic_inst                   shift and go to state 187

state 97

    (317) subprog_decl -> subprog_spec ; .

    TASK            reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    PROTECTED       reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    error           reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    USE             reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    PRAGMA          reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    PACKAGE         reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    TYPE            reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    SUBTYPE         reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    FOR             reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    PROCEDURE       reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    FUNCTION        reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    GENERIC         reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    ID              reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    BEGIN           reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    PRIVATE         reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    END             reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    WITH            reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    SEPARATE        reduce using rule 317 (subprog_decl -> subprog_spec ; .)
    $end            reduce using rule 317 (subprog_decl -> subprog_spec ; .)


state 98

    (347) pkg_start -> PACKAGE BODY . compound_name IS
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    compound_name                  shift and go to state 188
    simple_name                    shift and go to state 42

state 99

    (361) rename_unit -> PACKAGE compound_name . renames ;
    (342) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
    (165) compound_name -> compound_name . . simple_name
    (365) renames -> . RENAMES name

    IS              shift and go to state 190
    .               shift and go to state 120
    RENAMES         shift and go to state 95

    renames                        shift and go to state 189

state 100

    (318) subprog_decl -> generic_subp_inst ; .

    TASK            reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    PROTECTED       reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    error           reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    USE             reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    PRAGMA          reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    PACKAGE         reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    TYPE            reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    SUBTYPE         reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    FOR             reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    PROCEDURE       reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    FUNCTION        reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    GENERIC         reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    ID              reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    BEGIN           reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    PRIVATE         reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    END             reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    WITH            reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    SEPARATE        reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)
    $end            reduce using rule 318 (subprog_decl -> generic_subp_inst ; .)


state 101

    (320) subprog_spec -> PROCEDURE compound_name . formal_part_opt
    (165) compound_name -> compound_name . . simple_name
    (325) formal_part_opt -> .
    (326) formal_part_opt -> . formal_part
    (327) formal_part -> . ( param_s )

    .               shift and go to state 120
    ;               reduce using rule 325 (formal_part_opt -> .)
    IS              reduce using rule 325 (formal_part_opt -> .)
    RENAMES         reduce using rule 325 (formal_part_opt -> .)
    (               shift and go to state 192

    formal_part                    shift and go to state 191
    formal_part_opt                shift and go to state 193

state 102

    (348) pkg_body -> pkg_start decl_part . body_opt END c_id_opt ;
    (349) body_opt -> .
    (350) body_opt -> . block_body
    (305) block_body -> . BEGIN handled_stmt_s

    END             reduce using rule 349 (body_opt -> .)
    BEGIN           shift and go to state 165

    body_opt                       shift and go to state 194
    block_body                     shift and go to state 195

state 103

    (481) generic_formal -> WITH . PROCEDURE simple_name formal_part_opt subp_default ;
    (482) generic_formal -> WITH . FUNCTION designator formal_part_opt RETURN name subp_default ;
    (483) generic_formal -> WITH . PACKAGE simple_name IS NEW name ( BOX ) ;
    (484) generic_formal -> WITH . PACKAGE simple_name IS NEW name ;

    PROCEDURE       shift and go to state 198
    FUNCTION        shift and go to state 196
    PACKAGE         shift and go to state 197


state 104

    (479) generic_formal -> param . ;

    ;               shift and go to state 199


state 105

    (475) generic_decl -> generic_formal_part subprog_spec . ;
    (364) rename_unit -> generic_formal_part subprog_spec . renames ;
    (365) renames -> . RENAMES name

    ;               shift and go to state 201
    RENAMES         shift and go to state 95

    renames                        shift and go to state 200

state 106

    (330) param -> def_id_s . : mode mark init_opt
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 202
    ,               shift and go to state 182


state 107

    (363) rename_unit -> generic_formal_part PACKAGE . compound_name renames ;
    (342) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 42
    compound_name                  shift and go to state 203

state 108

    (478) generic_formal_part -> generic_formal_part generic_formal .

    PACKAGE         reduce using rule 478 (generic_formal_part -> generic_formal_part generic_formal .)
    PROCEDURE       reduce using rule 478 (generic_formal_part -> generic_formal_part generic_formal .)
    FUNCTION        reduce using rule 478 (generic_formal_part -> generic_formal_part generic_formal .)
    TYPE            reduce using rule 478 (generic_formal_part -> generic_formal_part generic_formal .)
    WITH            reduce using rule 478 (generic_formal_part -> generic_formal_part generic_formal .)
    error           reduce using rule 478 (generic_formal_part -> generic_formal_part generic_formal .)
    USE             reduce using rule 478 (generic_formal_part -> generic_formal_part generic_formal .)
    ID              reduce using rule 478 (generic_formal_part -> generic_formal_part generic_formal .)


state 109

    (485) generic_formal -> use_clause .

    PACKAGE         reduce using rule 485 (generic_formal -> use_clause .)
    PROCEDURE       reduce using rule 485 (generic_formal -> use_clause .)
    FUNCTION        reduce using rule 485 (generic_formal -> use_clause .)
    TYPE            reduce using rule 485 (generic_formal -> use_clause .)
    WITH            reduce using rule 485 (generic_formal -> use_clause .)
    error           reduce using rule 485 (generic_formal -> use_clause .)
    USE             reduce using rule 485 (generic_formal -> use_clause .)
    ID              reduce using rule 485 (generic_formal -> use_clause .)


state 110

    (331) param -> error .

    )               reduce using rule 331 (param -> error .)
    ;               reduce using rule 331 (param -> error .)


state 111

    (476) generic_decl -> generic_formal_part pkg_spec . ;

    ;               shift and go to state 204


state 112

    (480) generic_formal -> TYPE . simple_name generic_discrim_part_opt IS generic_type_def ;
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 205

state 113

    (341) pkg_decl -> generic_pkg_inst ; .

    PRAGMA          reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    PRIVATE         reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    WITH            reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    SEPARATE        reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    PACKAGE         reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    GENERIC         reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    PROCEDURE       reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    FUNCTION        reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    $end            reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    TASK            reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    PROTECTED       reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    error           reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    USE             reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    TYPE            reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    SUBTYPE         reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    FOR             reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    ID              reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    BEGIN           reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)
    END             reduce using rule 341 (pkg_decl -> generic_pkg_inst ; .)


state 114

    (324) designator -> STRLITERAL .

    (               reduce using rule 324 (designator -> STRLITERAL .)
    RETURN          reduce using rule 324 (designator -> STRLITERAL .)
    ;               reduce using rule 324 (designator -> STRLITERAL .)
    IS              reduce using rule 324 (designator -> STRLITERAL .)
    RENAMES         reduce using rule 324 (designator -> STRLITERAL .)


state 115

    (321) subprog_spec -> FUNCTION designator . formal_part_opt RETURN name
    (322) subprog_spec -> FUNCTION designator .
    (325) formal_part_opt -> .
    (326) formal_part_opt -> . formal_part
    (327) formal_part -> . ( param_s )

    IS              reduce using rule 322 (subprog_spec -> FUNCTION designator .)
    ;               reduce using rule 322 (subprog_spec -> FUNCTION designator .)
    RENAMES         reduce using rule 322 (subprog_spec -> FUNCTION designator .)
    RETURN          reduce using rule 325 (formal_part_opt -> .)
    (               shift and go to state 192

    formal_part                    shift and go to state 191
    formal_part_opt                shift and go to state 206

state 116

    (323) designator -> compound_name .
    (165) compound_name -> compound_name . . simple_name

    (               reduce using rule 323 (designator -> compound_name .)
    RETURN          reduce using rule 323 (designator -> compound_name .)
    ;               reduce using rule 323 (designator -> compound_name .)
    IS              reduce using rule 323 (designator -> compound_name .)
    RENAMES         reduce using rule 323 (designator -> compound_name .)
    .               shift and go to state 120


state 117

    (340) pkg_decl -> pkg_spec ; .

    PRAGMA          reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    PRIVATE         reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    WITH            reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    SEPARATE        reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    PACKAGE         reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    GENERIC         reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    PROCEDURE       reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    FUNCTION        reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    $end            reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    TASK            reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    PROTECTED       reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    error           reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    USE             reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    TYPE            reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    SUBTYPE         reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    FOR             reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    ID              reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    BEGIN           reduce using rule 340 (pkg_decl -> pkg_spec ; .)
    END             reduce using rule 340 (pkg_decl -> pkg_spec ; .)


state 118

    (444) with_clause -> WITH c_name_list ; .

    USE             reduce using rule 444 (with_clause -> WITH c_name_list ; .)
    PRIVATE         reduce using rule 444 (with_clause -> WITH c_name_list ; .)
    WITH            reduce using rule 444 (with_clause -> WITH c_name_list ; .)
    PRAGMA          reduce using rule 444 (with_clause -> WITH c_name_list ; .)
    SEPARATE        reduce using rule 444 (with_clause -> WITH c_name_list ; .)
    PACKAGE         reduce using rule 444 (with_clause -> WITH c_name_list ; .)
    GENERIC         reduce using rule 444 (with_clause -> WITH c_name_list ; .)
    PROCEDURE       reduce using rule 444 (with_clause -> WITH c_name_list ; .)
    FUNCTION        reduce using rule 444 (with_clause -> WITH c_name_list ; .)


state 119

    (167) c_name_list -> c_name_list , . compound_name
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    compound_name                  shift and go to state 207
    simple_name                    shift and go to state 42

state 120

    (165) compound_name -> compound_name . . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 208

state 121

    (157) name -> selected_comp .

    (               reduce using rule 157 (name -> selected_comp .)
    .               reduce using rule 157 (name -> selected_comp .)
    SINGLEQUOTE     reduce using rule 157 (name -> selected_comp .)
    ARROW           reduce using rule 157 (name -> selected_comp .)
    |               reduce using rule 157 (name -> selected_comp .)
    ASSIGNMENT      reduce using rule 157 (name -> selected_comp .)
    ;               reduce using rule 157 (name -> selected_comp .)
    RANGE           reduce using rule 157 (name -> selected_comp .)
    DOUBLESTAR      reduce using rule 157 (name -> selected_comp .)
    *               reduce using rule 157 (name -> selected_comp .)
    /               reduce using rule 157 (name -> selected_comp .)
    MOD             reduce using rule 157 (name -> selected_comp .)
    REM             reduce using rule 157 (name -> selected_comp .)
    =               reduce using rule 157 (name -> selected_comp .)
    NOTEQUAL        reduce using rule 157 (name -> selected_comp .)
    <               reduce using rule 157 (name -> selected_comp .)
    LEQUAL          reduce using rule 157 (name -> selected_comp .)
    >               reduce using rule 157 (name -> selected_comp .)
    GEQUAL          reduce using rule 157 (name -> selected_comp .)
    IN              reduce using rule 157 (name -> selected_comp .)
    NOT             reduce using rule 157 (name -> selected_comp .)
    +               reduce using rule 157 (name -> selected_comp .)
    -               reduce using rule 157 (name -> selected_comp .)
    &               reduce using rule 157 (name -> selected_comp .)
    )               reduce using rule 157 (name -> selected_comp .)
    AND             reduce using rule 157 (name -> selected_comp .)
    OR              reduce using rule 157 (name -> selected_comp .)
    XOR             reduce using rule 157 (name -> selected_comp .)
    ,               reduce using rule 157 (name -> selected_comp .)
    DIGITS          reduce using rule 157 (name -> selected_comp .)
    WITH            reduce using rule 157 (name -> selected_comp .)
    RENAMES         reduce using rule 157 (name -> selected_comp .)
    DOUBLEDOT       reduce using rule 157 (name -> selected_comp .)
    IS              reduce using rule 157 (name -> selected_comp .)
    THEN            reduce using rule 157 (name -> selected_comp .)
    LOOP            reduce using rule 157 (name -> selected_comp .)
    WHEN            reduce using rule 157 (name -> selected_comp .)


state 122

    (158) name -> attribute .

    (               reduce using rule 158 (name -> attribute .)
    .               reduce using rule 158 (name -> attribute .)
    SINGLEQUOTE     reduce using rule 158 (name -> attribute .)
    ARROW           reduce using rule 158 (name -> attribute .)
    |               reduce using rule 158 (name -> attribute .)
    ASSIGNMENT      reduce using rule 158 (name -> attribute .)
    ;               reduce using rule 158 (name -> attribute .)
    RANGE           reduce using rule 158 (name -> attribute .)
    DOUBLESTAR      reduce using rule 158 (name -> attribute .)
    *               reduce using rule 158 (name -> attribute .)
    /               reduce using rule 158 (name -> attribute .)
    MOD             reduce using rule 158 (name -> attribute .)
    REM             reduce using rule 158 (name -> attribute .)
    =               reduce using rule 158 (name -> attribute .)
    NOTEQUAL        reduce using rule 158 (name -> attribute .)
    <               reduce using rule 158 (name -> attribute .)
    LEQUAL          reduce using rule 158 (name -> attribute .)
    >               reduce using rule 158 (name -> attribute .)
    GEQUAL          reduce using rule 158 (name -> attribute .)
    IN              reduce using rule 158 (name -> attribute .)
    NOT             reduce using rule 158 (name -> attribute .)
    +               reduce using rule 158 (name -> attribute .)
    -               reduce using rule 158 (name -> attribute .)
    &               reduce using rule 158 (name -> attribute .)
    )               reduce using rule 158 (name -> attribute .)
    AND             reduce using rule 158 (name -> attribute .)
    OR              reduce using rule 158 (name -> attribute .)
    XOR             reduce using rule 158 (name -> attribute .)
    ,               reduce using rule 158 (name -> attribute .)
    DIGITS          reduce using rule 158 (name -> attribute .)
    WITH            reduce using rule 158 (name -> attribute .)
    RENAMES         reduce using rule 158 (name -> attribute .)
    DOUBLEDOT       reduce using rule 158 (name -> attribute .)
    IS              reduce using rule 158 (name -> attribute .)
    THEN            reduce using rule 158 (name -> attribute .)
    LOOP            reduce using rule 158 (name -> attribute .)
    WHEN            reduce using rule 158 (name -> attribute .)


state 123

    (235) factor -> primary .
    (237) factor -> primary . DOUBLESTAR primary

    *               reduce using rule 235 (factor -> primary .)
    /               reduce using rule 235 (factor -> primary .)
    MOD             reduce using rule 235 (factor -> primary .)
    REM             reduce using rule 235 (factor -> primary .)
    =               reduce using rule 235 (factor -> primary .)
    NOTEQUAL        reduce using rule 235 (factor -> primary .)
    <               reduce using rule 235 (factor -> primary .)
    LEQUAL          reduce using rule 235 (factor -> primary .)
    >               reduce using rule 235 (factor -> primary .)
    GEQUAL          reduce using rule 235 (factor -> primary .)
    IN              reduce using rule 235 (factor -> primary .)
    NOT             reduce using rule 235 (factor -> primary .)
    +               reduce using rule 235 (factor -> primary .)
    -               reduce using rule 235 (factor -> primary .)
    &               reduce using rule 235 (factor -> primary .)
    ;               reduce using rule 235 (factor -> primary .)
    AND             reduce using rule 235 (factor -> primary .)
    OR              reduce using rule 235 (factor -> primary .)
    XOR             reduce using rule 235 (factor -> primary .)
    )               reduce using rule 235 (factor -> primary .)
    ,               reduce using rule 235 (factor -> primary .)
    DOUBLEDOT       reduce using rule 235 (factor -> primary .)
    WITH            reduce using rule 235 (factor -> primary .)
    ARROW           reduce using rule 235 (factor -> primary .)
    |               reduce using rule 235 (factor -> primary .)
    IS              reduce using rule 235 (factor -> primary .)
    THEN            reduce using rule 235 (factor -> primary .)
    LOOP            reduce using rule 235 (factor -> primary .)
    RANGE           reduce using rule 235 (factor -> primary .)
    DIGITS          reduce using rule 235 (factor -> primary .)
    RENAMES         reduce using rule 235 (factor -> primary .)
    ASSIGNMENT      reduce using rule 235 (factor -> primary .)
    DOUBLESTAR      shift and go to state 209


state 124

    (4) pragma_arg_s -> pragma_arg .

    )               reduce using rule 4 (pragma_arg_s -> pragma_arg .)
    ,               reduce using rule 4 (pragma_arg_s -> pragma_arg .)


state 125

    (221) simple_expression -> unary . term
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 210
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    operator_symbol                shift and go to state 139

state 126

    (201) expression -> relation .

    IS              reduce using rule 201 (expression -> relation .)
    AND             reduce using rule 201 (expression -> relation .)
    OR              reduce using rule 201 (expression -> relation .)
    XOR             reduce using rule 201 (expression -> relation .)
    ;               reduce using rule 201 (expression -> relation .)
    )               reduce using rule 201 (expression -> relation .)
    WITH            reduce using rule 201 (expression -> relation .)
    ,               reduce using rule 201 (expression -> relation .)
    ARROW           reduce using rule 201 (expression -> relation .)
    |               reduce using rule 201 (expression -> relation .)
    THEN            reduce using rule 201 (expression -> relation .)
    RANGE           reduce using rule 201 (expression -> relation .)
    RENAMES         reduce using rule 201 (expression -> relation .)
    ASSIGNMENT      reduce using rule 201 (expression -> relation .)
    LOOP            reduce using rule 201 (expression -> relation .)
    DIGITS          reduce using rule 201 (expression -> relation .)


state 127

    (188) numeric_lit -> NUMLITERAL_INT .

    DOUBLESTAR      reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    *               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    /               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    MOD             reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    REM             reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    =               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    NOTEQUAL        reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    <               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    LEQUAL          reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    >               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    GEQUAL          reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    IN              reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    NOT             reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    +               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    -               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    &               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    RANGE           reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    AND             reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    OR              reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    XOR             reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    ;               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    )               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    ,               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    DOUBLEDOT       reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    WITH            reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    ARROW           reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    |               reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    IS              reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    THEN            reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    LOOP            reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    DIGITS          reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    RENAMES         reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)
    ASSIGNMENT      reduce using rule 188 (numeric_lit -> NUMLITERAL_INT .)


state 128

    (247) allocator -> NEW . name
    (248) allocator -> NEW . qualified
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 211
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 212
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 129

    (209) relation -> simple_expression .
    (210) relation -> simple_expression . relational simple_expression
    (211) relation -> simple_expression . membership range
    (212) relation -> simple_expression . membership name
    (223) simple_expression -> simple_expression . adding term
    (213) relational -> . =
    (214) relational -> . NOTEQUAL
    (215) relational -> . <
    (216) relational -> . LEQUAL
    (217) relational -> . >
    (218) relational -> . GEQUAL
    (219) membership -> . IN
    (220) membership -> . NOT IN
    (226) adding -> . +
    (227) adding -> . -
    (228) adding -> . &

    AND             reduce using rule 209 (relation -> simple_expression .)
    OR              reduce using rule 209 (relation -> simple_expression .)
    XOR             reduce using rule 209 (relation -> simple_expression .)
    )               reduce using rule 209 (relation -> simple_expression .)
    ,               reduce using rule 209 (relation -> simple_expression .)
    ;               reduce using rule 209 (relation -> simple_expression .)
    RANGE           reduce using rule 209 (relation -> simple_expression .)
    RENAMES         reduce using rule 209 (relation -> simple_expression .)
    ASSIGNMENT      reduce using rule 209 (relation -> simple_expression .)
    WITH            reduce using rule 209 (relation -> simple_expression .)
    THEN            reduce using rule 209 (relation -> simple_expression .)
    LOOP            reduce using rule 209 (relation -> simple_expression .)
    ARROW           reduce using rule 209 (relation -> simple_expression .)
    |               reduce using rule 209 (relation -> simple_expression .)
    IS              reduce using rule 209 (relation -> simple_expression .)
    DIGITS          reduce using rule 209 (relation -> simple_expression .)
    =               shift and go to state 224
    NOTEQUAL        shift and go to state 216
    <               shift and go to state 225
    LEQUAL          shift and go to state 215
    >               shift and go to state 226
    GEQUAL          shift and go to state 214
    IN              shift and go to state 221
    NOT             shift and go to state 222
    +               shift and go to state 217
    -               shift and go to state 219
    &               shift and go to state 218

    adding                         shift and go to state 213
    membership                     shift and go to state 220
    relational                     shift and go to state 223

state 130

    (156) name -> indexed_comp .

    (               reduce using rule 156 (name -> indexed_comp .)
    .               reduce using rule 156 (name -> indexed_comp .)
    SINGLEQUOTE     reduce using rule 156 (name -> indexed_comp .)
    ARROW           reduce using rule 156 (name -> indexed_comp .)
    |               reduce using rule 156 (name -> indexed_comp .)
    ASSIGNMENT      reduce using rule 156 (name -> indexed_comp .)
    ;               reduce using rule 156 (name -> indexed_comp .)
    RANGE           reduce using rule 156 (name -> indexed_comp .)
    DOUBLESTAR      reduce using rule 156 (name -> indexed_comp .)
    *               reduce using rule 156 (name -> indexed_comp .)
    /               reduce using rule 156 (name -> indexed_comp .)
    MOD             reduce using rule 156 (name -> indexed_comp .)
    REM             reduce using rule 156 (name -> indexed_comp .)
    =               reduce using rule 156 (name -> indexed_comp .)
    NOTEQUAL        reduce using rule 156 (name -> indexed_comp .)
    <               reduce using rule 156 (name -> indexed_comp .)
    LEQUAL          reduce using rule 156 (name -> indexed_comp .)
    >               reduce using rule 156 (name -> indexed_comp .)
    GEQUAL          reduce using rule 156 (name -> indexed_comp .)
    IN              reduce using rule 156 (name -> indexed_comp .)
    NOT             reduce using rule 156 (name -> indexed_comp .)
    +               reduce using rule 156 (name -> indexed_comp .)
    -               reduce using rule 156 (name -> indexed_comp .)
    &               reduce using rule 156 (name -> indexed_comp .)
    )               reduce using rule 156 (name -> indexed_comp .)
    AND             reduce using rule 156 (name -> indexed_comp .)
    OR              reduce using rule 156 (name -> indexed_comp .)
    XOR             reduce using rule 156 (name -> indexed_comp .)
    ,               reduce using rule 156 (name -> indexed_comp .)
    DIGITS          reduce using rule 156 (name -> indexed_comp .)
    WITH            reduce using rule 156 (name -> indexed_comp .)
    RENAMES         reduce using rule 156 (name -> indexed_comp .)
    DOUBLEDOT       reduce using rule 156 (name -> indexed_comp .)
    IS              reduce using rule 156 (name -> indexed_comp .)
    THEN            reduce using rule 156 (name -> indexed_comp .)
    LOOP            reduce using rule 156 (name -> indexed_comp .)
    WHEN            reduce using rule 156 (name -> indexed_comp .)


state 131

    (241) primary -> allocator .

    DOUBLESTAR      reduce using rule 241 (primary -> allocator .)
    *               reduce using rule 241 (primary -> allocator .)
    /               reduce using rule 241 (primary -> allocator .)
    MOD             reduce using rule 241 (primary -> allocator .)
    REM             reduce using rule 241 (primary -> allocator .)
    =               reduce using rule 241 (primary -> allocator .)
    NOTEQUAL        reduce using rule 241 (primary -> allocator .)
    <               reduce using rule 241 (primary -> allocator .)
    LEQUAL          reduce using rule 241 (primary -> allocator .)
    >               reduce using rule 241 (primary -> allocator .)
    GEQUAL          reduce using rule 241 (primary -> allocator .)
    IN              reduce using rule 241 (primary -> allocator .)
    NOT             reduce using rule 241 (primary -> allocator .)
    +               reduce using rule 241 (primary -> allocator .)
    -               reduce using rule 241 (primary -> allocator .)
    &               reduce using rule 241 (primary -> allocator .)
    IS              reduce using rule 241 (primary -> allocator .)
    AND             reduce using rule 241 (primary -> allocator .)
    OR              reduce using rule 241 (primary -> allocator .)
    XOR             reduce using rule 241 (primary -> allocator .)
    ;               reduce using rule 241 (primary -> allocator .)
    DOUBLEDOT       reduce using rule 241 (primary -> allocator .)
    )               reduce using rule 241 (primary -> allocator .)
    ,               reduce using rule 241 (primary -> allocator .)
    ARROW           reduce using rule 241 (primary -> allocator .)
    |               reduce using rule 241 (primary -> allocator .)
    WITH            reduce using rule 241 (primary -> allocator .)
    THEN            reduce using rule 241 (primary -> allocator .)
    LOOP            reduce using rule 241 (primary -> allocator .)
    RANGE           reduce using rule 241 (primary -> allocator .)
    DIGITS          reduce using rule 241 (primary -> allocator .)
    RENAMES         reduce using rule 241 (primary -> allocator .)
    ASSIGNMENT      reduce using rule 241 (primary -> allocator .)


state 132

    (7) pragma_arg -> simple_name . ARROW expression
    (155) name -> simple_name .

    ARROW           shift and go to state 227
    SINGLEQUOTE     reduce using rule 155 (name -> simple_name .)
    (               reduce using rule 155 (name -> simple_name .)
    .               reduce using rule 155 (name -> simple_name .)
    DOUBLESTAR      reduce using rule 155 (name -> simple_name .)
    *               reduce using rule 155 (name -> simple_name .)
    /               reduce using rule 155 (name -> simple_name .)
    MOD             reduce using rule 155 (name -> simple_name .)
    REM             reduce using rule 155 (name -> simple_name .)
    =               reduce using rule 155 (name -> simple_name .)
    NOTEQUAL        reduce using rule 155 (name -> simple_name .)
    <               reduce using rule 155 (name -> simple_name .)
    LEQUAL          reduce using rule 155 (name -> simple_name .)
    >               reduce using rule 155 (name -> simple_name .)
    GEQUAL          reduce using rule 155 (name -> simple_name .)
    IN              reduce using rule 155 (name -> simple_name .)
    NOT             reduce using rule 155 (name -> simple_name .)
    +               reduce using rule 155 (name -> simple_name .)
    -               reduce using rule 155 (name -> simple_name .)
    &               reduce using rule 155 (name -> simple_name .)
    AND             reduce using rule 155 (name -> simple_name .)
    OR              reduce using rule 155 (name -> simple_name .)
    XOR             reduce using rule 155 (name -> simple_name .)
    )               reduce using rule 155 (name -> simple_name .)
    ,               reduce using rule 155 (name -> simple_name .)


state 133

    (186) numeric_lit -> NUMLITERAL_BASE_INT .

    DOUBLESTAR      reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    *               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    /               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    MOD             reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    REM             reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    =               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    NOTEQUAL        reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    <               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    LEQUAL          reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    >               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    GEQUAL          reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    IN              reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    NOT             reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    +               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    -               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    &               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    RANGE           reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    AND             reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    OR              reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    XOR             reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    ;               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    )               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    ,               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    DOUBLEDOT       reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    WITH            reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    ARROW           reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    |               reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    IS              reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    THEN            reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    LOOP            reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    DIGITS          reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    RENAMES         reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)
    ASSIGNMENT      reduce using rule 186 (numeric_lit -> NUMLITERAL_BASE_INT .)


state 134

    (245) parenthesized_primary -> ( . expression )
    (193) aggregate -> ( . comp_assoc )
    (194) aggregate -> ( . value_s_2 )
    (195) aggregate -> ( . expression WITH value_s )
    (196) aggregate -> ( . expression WITH NuLL RECORD )
    (197) aggregate -> ( . NuLL RECORD )
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (200) comp_assoc -> . choice_s ARROW expression
    (198) value_s_2 -> . value , value
    (199) value_s_2 -> . value_s_2 , value
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    NuLL            shift and go to state 239
    error           shift and go to state 238
    OTHERS          shift and go to state 228
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 229
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    comp_assoc                     shift and go to state 231
    choice_s                       shift and go to state 230
    choice                         shift and go to state 232
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    value_s_2                      shift and go to state 233
    aggregate                      shift and go to state 145
    discrete_with_range            shift and go to state 234
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 235
    value                          shift and go to state 236
    range                          shift and go to state 237
    expression                     shift and go to state 240

state 135

    (224) unary -> + .

    NOT             reduce using rule 224 (unary -> + .)
    ABS             reduce using rule 224 (unary -> + .)
    NuLL            reduce using rule 224 (unary -> + .)
    NEW             reduce using rule 224 (unary -> + .)
    (               reduce using rule 224 (unary -> + .)
    NUMLITERAL_BASE_INT reduce using rule 224 (unary -> + .)
    NUMLITERAL_BASE_FLOAT reduce using rule 224 (unary -> + .)
    NUMLITERAL_INT  reduce using rule 224 (unary -> + .)
    NUMLITERAL_FLOAT reduce using rule 224 (unary -> + .)
    CHARLITERAL     reduce using rule 224 (unary -> + .)
    ID              reduce using rule 224 (unary -> + .)
    STRLITERAL      reduce using rule 224 (unary -> + .)


state 136

    (225) unary -> - .

    NOT             reduce using rule 225 (unary -> - .)
    ABS             reduce using rule 225 (unary -> - .)
    NuLL            reduce using rule 225 (unary -> - .)
    NEW             reduce using rule 225 (unary -> - .)
    (               reduce using rule 225 (unary -> - .)
    NUMLITERAL_BASE_INT reduce using rule 225 (unary -> - .)
    NUMLITERAL_BASE_FLOAT reduce using rule 225 (unary -> - .)
    NUMLITERAL_INT  reduce using rule 225 (unary -> - .)
    NUMLITERAL_FLOAT reduce using rule 225 (unary -> - .)
    CHARLITERAL     reduce using rule 225 (unary -> - .)
    ID              reduce using rule 225 (unary -> - .)
    STRLITERAL      reduce using rule 225 (unary -> - .)


state 137

    (239) primary -> literal .

    DOUBLESTAR      reduce using rule 239 (primary -> literal .)
    *               reduce using rule 239 (primary -> literal .)
    /               reduce using rule 239 (primary -> literal .)
    MOD             reduce using rule 239 (primary -> literal .)
    REM             reduce using rule 239 (primary -> literal .)
    =               reduce using rule 239 (primary -> literal .)
    NOTEQUAL        reduce using rule 239 (primary -> literal .)
    <               reduce using rule 239 (primary -> literal .)
    LEQUAL          reduce using rule 239 (primary -> literal .)
    >               reduce using rule 239 (primary -> literal .)
    GEQUAL          reduce using rule 239 (primary -> literal .)
    IN              reduce using rule 239 (primary -> literal .)
    NOT             reduce using rule 239 (primary -> literal .)
    +               reduce using rule 239 (primary -> literal .)
    -               reduce using rule 239 (primary -> literal .)
    &               reduce using rule 239 (primary -> literal .)
    IS              reduce using rule 239 (primary -> literal .)
    AND             reduce using rule 239 (primary -> literal .)
    OR              reduce using rule 239 (primary -> literal .)
    XOR             reduce using rule 239 (primary -> literal .)
    ;               reduce using rule 239 (primary -> literal .)
    DOUBLEDOT       reduce using rule 239 (primary -> literal .)
    )               reduce using rule 239 (primary -> literal .)
    ,               reduce using rule 239 (primary -> literal .)
    ARROW           reduce using rule 239 (primary -> literal .)
    |               reduce using rule 239 (primary -> literal .)
    WITH            reduce using rule 239 (primary -> literal .)
    THEN            reduce using rule 239 (primary -> literal .)
    LOOP            reduce using rule 239 (primary -> literal .)
    RANGE           reduce using rule 239 (primary -> literal .)
    DIGITS          reduce using rule 239 (primary -> literal .)
    RENAMES         reduce using rule 239 (primary -> literal .)
    ASSIGNMENT      reduce using rule 239 (primary -> literal .)


state 138

    (229) term -> factor .

    *               reduce using rule 229 (term -> factor .)
    /               reduce using rule 229 (term -> factor .)
    MOD             reduce using rule 229 (term -> factor .)
    REM             reduce using rule 229 (term -> factor .)
    =               reduce using rule 229 (term -> factor .)
    NOTEQUAL        reduce using rule 229 (term -> factor .)
    <               reduce using rule 229 (term -> factor .)
    LEQUAL          reduce using rule 229 (term -> factor .)
    >               reduce using rule 229 (term -> factor .)
    GEQUAL          reduce using rule 229 (term -> factor .)
    IN              reduce using rule 229 (term -> factor .)
    NOT             reduce using rule 229 (term -> factor .)
    +               reduce using rule 229 (term -> factor .)
    -               reduce using rule 229 (term -> factor .)
    &               reduce using rule 229 (term -> factor .)
    AND             reduce using rule 229 (term -> factor .)
    OR              reduce using rule 229 (term -> factor .)
    XOR             reduce using rule 229 (term -> factor .)
    )               reduce using rule 229 (term -> factor .)
    ,               reduce using rule 229 (term -> factor .)
    DOUBLEDOT       reduce using rule 229 (term -> factor .)
    ARROW           reduce using rule 229 (term -> factor .)
    |               reduce using rule 229 (term -> factor .)
    WITH            reduce using rule 229 (term -> factor .)
    ;               reduce using rule 229 (term -> factor .)
    IS              reduce using rule 229 (term -> factor .)
    THEN            reduce using rule 229 (term -> factor .)
    LOOP            reduce using rule 229 (term -> factor .)
    RANGE           reduce using rule 229 (term -> factor .)
    DIGITS          reduce using rule 229 (term -> factor .)
    RENAMES         reduce using rule 229 (term -> factor .)
    ASSIGNMENT      reduce using rule 229 (term -> factor .)


state 139

    (159) name -> operator_symbol .

    (               reduce using rule 159 (name -> operator_symbol .)
    .               reduce using rule 159 (name -> operator_symbol .)
    SINGLEQUOTE     reduce using rule 159 (name -> operator_symbol .)
    ARROW           reduce using rule 159 (name -> operator_symbol .)
    |               reduce using rule 159 (name -> operator_symbol .)
    ASSIGNMENT      reduce using rule 159 (name -> operator_symbol .)
    ;               reduce using rule 159 (name -> operator_symbol .)
    RANGE           reduce using rule 159 (name -> operator_symbol .)
    DOUBLESTAR      reduce using rule 159 (name -> operator_symbol .)
    *               reduce using rule 159 (name -> operator_symbol .)
    /               reduce using rule 159 (name -> operator_symbol .)
    MOD             reduce using rule 159 (name -> operator_symbol .)
    REM             reduce using rule 159 (name -> operator_symbol .)
    =               reduce using rule 159 (name -> operator_symbol .)
    NOTEQUAL        reduce using rule 159 (name -> operator_symbol .)
    <               reduce using rule 159 (name -> operator_symbol .)
    LEQUAL          reduce using rule 159 (name -> operator_symbol .)
    >               reduce using rule 159 (name -> operator_symbol .)
    GEQUAL          reduce using rule 159 (name -> operator_symbol .)
    IN              reduce using rule 159 (name -> operator_symbol .)
    NOT             reduce using rule 159 (name -> operator_symbol .)
    +               reduce using rule 159 (name -> operator_symbol .)
    -               reduce using rule 159 (name -> operator_symbol .)
    &               reduce using rule 159 (name -> operator_symbol .)
    )               reduce using rule 159 (name -> operator_symbol .)
    AND             reduce using rule 159 (name -> operator_symbol .)
    OR              reduce using rule 159 (name -> operator_symbol .)
    XOR             reduce using rule 159 (name -> operator_symbol .)
    ,               reduce using rule 159 (name -> operator_symbol .)
    DIGITS          reduce using rule 159 (name -> operator_symbol .)
    WITH            reduce using rule 159 (name -> operator_symbol .)
    RENAMES         reduce using rule 159 (name -> operator_symbol .)
    DOUBLEDOT       reduce using rule 159 (name -> operator_symbol .)
    IS              reduce using rule 159 (name -> operator_symbol .)
    THEN            reduce using rule 159 (name -> operator_symbol .)
    LOOP            reduce using rule 159 (name -> operator_symbol .)
    WHEN            reduce using rule 159 (name -> operator_symbol .)


state 140

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s . ) ;
    (5) pragma_arg_s -> pragma_arg_s . , pragma_arg

    )               shift and go to state 241
    ,               shift and go to state 242


state 141

    (238) factor -> ABS . primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    primary                        shift and go to state 243
    used_char                      shift and go to state 146
    literal                        shift and go to state 137
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160

state 142

    (243) primary -> parenthesized_primary .

    DOUBLESTAR      reduce using rule 243 (primary -> parenthesized_primary .)
    *               reduce using rule 243 (primary -> parenthesized_primary .)
    /               reduce using rule 243 (primary -> parenthesized_primary .)
    MOD             reduce using rule 243 (primary -> parenthesized_primary .)
    REM             reduce using rule 243 (primary -> parenthesized_primary .)
    =               reduce using rule 243 (primary -> parenthesized_primary .)
    NOTEQUAL        reduce using rule 243 (primary -> parenthesized_primary .)
    <               reduce using rule 243 (primary -> parenthesized_primary .)
    LEQUAL          reduce using rule 243 (primary -> parenthesized_primary .)
    >               reduce using rule 243 (primary -> parenthesized_primary .)
    GEQUAL          reduce using rule 243 (primary -> parenthesized_primary .)
    IN              reduce using rule 243 (primary -> parenthesized_primary .)
    NOT             reduce using rule 243 (primary -> parenthesized_primary .)
    +               reduce using rule 243 (primary -> parenthesized_primary .)
    -               reduce using rule 243 (primary -> parenthesized_primary .)
    &               reduce using rule 243 (primary -> parenthesized_primary .)
    IS              reduce using rule 243 (primary -> parenthesized_primary .)
    AND             reduce using rule 243 (primary -> parenthesized_primary .)
    OR              reduce using rule 243 (primary -> parenthesized_primary .)
    XOR             reduce using rule 243 (primary -> parenthesized_primary .)
    ;               reduce using rule 243 (primary -> parenthesized_primary .)
    DOUBLEDOT       reduce using rule 243 (primary -> parenthesized_primary .)
    )               reduce using rule 243 (primary -> parenthesized_primary .)
    ,               reduce using rule 243 (primary -> parenthesized_primary .)
    ARROW           reduce using rule 243 (primary -> parenthesized_primary .)
    |               reduce using rule 243 (primary -> parenthesized_primary .)
    WITH            reduce using rule 243 (primary -> parenthesized_primary .)
    THEN            reduce using rule 243 (primary -> parenthesized_primary .)
    LOOP            reduce using rule 243 (primary -> parenthesized_primary .)
    RANGE           reduce using rule 243 (primary -> parenthesized_primary .)
    DIGITS          reduce using rule 243 (primary -> parenthesized_primary .)
    RENAMES         reduce using rule 243 (primary -> parenthesized_primary .)
    ASSIGNMENT      reduce using rule 243 (primary -> parenthesized_primary .)


state 143

    (189) numeric_lit -> NUMLITERAL_FLOAT .

    DOUBLESTAR      reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    *               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    /               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    MOD             reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    REM             reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    =               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    NOTEQUAL        reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    <               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    LEQUAL          reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    >               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    GEQUAL          reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    IN              reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    NOT             reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    +               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    -               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    &               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    RANGE           reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    AND             reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    OR              reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    XOR             reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    ;               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    )               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    ,               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    DOUBLEDOT       reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    WITH            reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    ARROW           reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    |               reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    IS              reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    THEN            reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    LOOP            reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    DIGITS          reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    RENAMES         reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)
    ASSIGNMENT      reduce using rule 189 (numeric_lit -> NUMLITERAL_FLOAT .)


state 144

    (187) numeric_lit -> NUMLITERAL_BASE_FLOAT .

    DOUBLESTAR      reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    *               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    /               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    MOD             reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    REM             reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    =               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    NOTEQUAL        reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    <               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    LEQUAL          reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    >               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    GEQUAL          reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    IN              reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    NOT             reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    +               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    -               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    &               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    RANGE           reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    AND             reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    OR              reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    XOR             reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    ;               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    )               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    ,               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    DOUBLEDOT       reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    WITH            reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    ARROW           reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    |               reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    IS              reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    THEN            reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    LOOP            reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    DIGITS          reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    RENAMES         reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)
    ASSIGNMENT      reduce using rule 187 (numeric_lit -> NUMLITERAL_BASE_FLOAT .)


state 145

    (244) parenthesized_primary -> aggregate .

    DOUBLESTAR      reduce using rule 244 (parenthesized_primary -> aggregate .)
    *               reduce using rule 244 (parenthesized_primary -> aggregate .)
    /               reduce using rule 244 (parenthesized_primary -> aggregate .)
    MOD             reduce using rule 244 (parenthesized_primary -> aggregate .)
    REM             reduce using rule 244 (parenthesized_primary -> aggregate .)
    =               reduce using rule 244 (parenthesized_primary -> aggregate .)
    NOTEQUAL        reduce using rule 244 (parenthesized_primary -> aggregate .)
    <               reduce using rule 244 (parenthesized_primary -> aggregate .)
    LEQUAL          reduce using rule 244 (parenthesized_primary -> aggregate .)
    >               reduce using rule 244 (parenthesized_primary -> aggregate .)
    GEQUAL          reduce using rule 244 (parenthesized_primary -> aggregate .)
    IN              reduce using rule 244 (parenthesized_primary -> aggregate .)
    NOT             reduce using rule 244 (parenthesized_primary -> aggregate .)
    +               reduce using rule 244 (parenthesized_primary -> aggregate .)
    -               reduce using rule 244 (parenthesized_primary -> aggregate .)
    &               reduce using rule 244 (parenthesized_primary -> aggregate .)
    AND             reduce using rule 244 (parenthesized_primary -> aggregate .)
    OR              reduce using rule 244 (parenthesized_primary -> aggregate .)
    XOR             reduce using rule 244 (parenthesized_primary -> aggregate .)
    ARROW           reduce using rule 244 (parenthesized_primary -> aggregate .)
    )               reduce using rule 244 (parenthesized_primary -> aggregate .)
    ,               reduce using rule 244 (parenthesized_primary -> aggregate .)
    WITH            reduce using rule 244 (parenthesized_primary -> aggregate .)
    |               reduce using rule 244 (parenthesized_primary -> aggregate .)
    ;               reduce using rule 244 (parenthesized_primary -> aggregate .)
    IS              reduce using rule 244 (parenthesized_primary -> aggregate .)
    THEN            reduce using rule 244 (parenthesized_primary -> aggregate .)
    LOOP            reduce using rule 244 (parenthesized_primary -> aggregate .)
    RANGE           reduce using rule 244 (parenthesized_primary -> aggregate .)
    DIGITS          reduce using rule 244 (parenthesized_primary -> aggregate .)
    RENAMES         reduce using rule 244 (parenthesized_primary -> aggregate .)
    ASSIGNMENT      reduce using rule 244 (parenthesized_primary -> aggregate .)
    DOUBLEDOT       reduce using rule 244 (parenthesized_primary -> aggregate .)


state 146

    (191) literal -> used_char .

    DOUBLESTAR      reduce using rule 191 (literal -> used_char .)
    *               reduce using rule 191 (literal -> used_char .)
    /               reduce using rule 191 (literal -> used_char .)
    MOD             reduce using rule 191 (literal -> used_char .)
    REM             reduce using rule 191 (literal -> used_char .)
    =               reduce using rule 191 (literal -> used_char .)
    NOTEQUAL        reduce using rule 191 (literal -> used_char .)
    <               reduce using rule 191 (literal -> used_char .)
    LEQUAL          reduce using rule 191 (literal -> used_char .)
    >               reduce using rule 191 (literal -> used_char .)
    GEQUAL          reduce using rule 191 (literal -> used_char .)
    IN              reduce using rule 191 (literal -> used_char .)
    NOT             reduce using rule 191 (literal -> used_char .)
    +               reduce using rule 191 (literal -> used_char .)
    -               reduce using rule 191 (literal -> used_char .)
    &               reduce using rule 191 (literal -> used_char .)
    RANGE           reduce using rule 191 (literal -> used_char .)
    AND             reduce using rule 191 (literal -> used_char .)
    OR              reduce using rule 191 (literal -> used_char .)
    XOR             reduce using rule 191 (literal -> used_char .)
    ;               reduce using rule 191 (literal -> used_char .)
    THEN            reduce using rule 191 (literal -> used_char .)
    DOUBLEDOT       reduce using rule 191 (literal -> used_char .)
    RENAMES         reduce using rule 191 (literal -> used_char .)
    ASSIGNMENT      reduce using rule 191 (literal -> used_char .)
    WITH            reduce using rule 191 (literal -> used_char .)
    )               reduce using rule 191 (literal -> used_char .)
    ARROW           reduce using rule 191 (literal -> used_char .)
    |               reduce using rule 191 (literal -> used_char .)
    ,               reduce using rule 191 (literal -> used_char .)
    IS              reduce using rule 191 (literal -> used_char .)
    LOOP            reduce using rule 191 (literal -> used_char .)
    DIGITS          reduce using rule 191 (literal -> used_char .)


state 147

    (222) simple_expression -> term .
    (230) term -> term . multiplying factor
    (231) multiplying -> . *
    (232) multiplying -> . /
    (233) multiplying -> . MOD
    (234) multiplying -> . REM

    DOUBLEDOT       reduce using rule 222 (simple_expression -> term .)
    =               reduce using rule 222 (simple_expression -> term .)
    NOTEQUAL        reduce using rule 222 (simple_expression -> term .)
    <               reduce using rule 222 (simple_expression -> term .)
    LEQUAL          reduce using rule 222 (simple_expression -> term .)
    >               reduce using rule 222 (simple_expression -> term .)
    GEQUAL          reduce using rule 222 (simple_expression -> term .)
    IN              reduce using rule 222 (simple_expression -> term .)
    NOT             reduce using rule 222 (simple_expression -> term .)
    +               reduce using rule 222 (simple_expression -> term .)
    -               reduce using rule 222 (simple_expression -> term .)
    &               reduce using rule 222 (simple_expression -> term .)
    AND             reduce using rule 222 (simple_expression -> term .)
    OR              reduce using rule 222 (simple_expression -> term .)
    XOR             reduce using rule 222 (simple_expression -> term .)
    ARROW           reduce using rule 222 (simple_expression -> term .)
    |               reduce using rule 222 (simple_expression -> term .)
    THEN            reduce using rule 222 (simple_expression -> term .)
    )               reduce using rule 222 (simple_expression -> term .)
    ,               reduce using rule 222 (simple_expression -> term .)
    WITH            reduce using rule 222 (simple_expression -> term .)
    ;               reduce using rule 222 (simple_expression -> term .)
    IS              reduce using rule 222 (simple_expression -> term .)
    LOOP            reduce using rule 222 (simple_expression -> term .)
    RANGE           reduce using rule 222 (simple_expression -> term .)
    DIGITS          reduce using rule 222 (simple_expression -> term .)
    RENAMES         reduce using rule 222 (simple_expression -> term .)
    ASSIGNMENT      reduce using rule 222 (simple_expression -> term .)
    *               shift and go to state 246
    /               shift and go to state 247
    MOD             shift and go to state 248
    REM             shift and go to state 244

    multiplying                    shift and go to state 245

state 148

    (190) literal -> numeric_lit .

    DOUBLESTAR      reduce using rule 190 (literal -> numeric_lit .)
    *               reduce using rule 190 (literal -> numeric_lit .)
    /               reduce using rule 190 (literal -> numeric_lit .)
    MOD             reduce using rule 190 (literal -> numeric_lit .)
    REM             reduce using rule 190 (literal -> numeric_lit .)
    =               reduce using rule 190 (literal -> numeric_lit .)
    NOTEQUAL        reduce using rule 190 (literal -> numeric_lit .)
    <               reduce using rule 190 (literal -> numeric_lit .)
    LEQUAL          reduce using rule 190 (literal -> numeric_lit .)
    >               reduce using rule 190 (literal -> numeric_lit .)
    GEQUAL          reduce using rule 190 (literal -> numeric_lit .)
    IN              reduce using rule 190 (literal -> numeric_lit .)
    NOT             reduce using rule 190 (literal -> numeric_lit .)
    +               reduce using rule 190 (literal -> numeric_lit .)
    -               reduce using rule 190 (literal -> numeric_lit .)
    &               reduce using rule 190 (literal -> numeric_lit .)
    RANGE           reduce using rule 190 (literal -> numeric_lit .)
    AND             reduce using rule 190 (literal -> numeric_lit .)
    OR              reduce using rule 190 (literal -> numeric_lit .)
    XOR             reduce using rule 190 (literal -> numeric_lit .)
    ;               reduce using rule 190 (literal -> numeric_lit .)
    THEN            reduce using rule 190 (literal -> numeric_lit .)
    DOUBLEDOT       reduce using rule 190 (literal -> numeric_lit .)
    RENAMES         reduce using rule 190 (literal -> numeric_lit .)
    ASSIGNMENT      reduce using rule 190 (literal -> numeric_lit .)
    WITH            reduce using rule 190 (literal -> numeric_lit .)
    )               reduce using rule 190 (literal -> numeric_lit .)
    ARROW           reduce using rule 190 (literal -> numeric_lit .)
    |               reduce using rule 190 (literal -> numeric_lit .)
    ,               reduce using rule 190 (literal -> numeric_lit .)
    IS              reduce using rule 190 (literal -> numeric_lit .)
    LOOP            reduce using rule 190 (literal -> numeric_lit .)
    DIGITS          reduce using rule 190 (literal -> numeric_lit .)


state 149

    (240) primary -> name .
    (246) qualified -> name . SINGLEQUOTE parenthesized_primary
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    DOUBLESTAR      reduce using rule 240 (primary -> name .)
    *               reduce using rule 240 (primary -> name .)
    /               reduce using rule 240 (primary -> name .)
    MOD             reduce using rule 240 (primary -> name .)
    REM             reduce using rule 240 (primary -> name .)
    =               reduce using rule 240 (primary -> name .)
    NOTEQUAL        reduce using rule 240 (primary -> name .)
    <               reduce using rule 240 (primary -> name .)
    LEQUAL          reduce using rule 240 (primary -> name .)
    >               reduce using rule 240 (primary -> name .)
    GEQUAL          reduce using rule 240 (primary -> name .)
    IN              reduce using rule 240 (primary -> name .)
    NOT             reduce using rule 240 (primary -> name .)
    +               reduce using rule 240 (primary -> name .)
    -               reduce using rule 240 (primary -> name .)
    &               reduce using rule 240 (primary -> name .)
    IS              reduce using rule 240 (primary -> name .)
    AND             reduce using rule 240 (primary -> name .)
    OR              reduce using rule 240 (primary -> name .)
    XOR             reduce using rule 240 (primary -> name .)
    ;               reduce using rule 240 (primary -> name .)
    )               reduce using rule 240 (primary -> name .)
    ,               reduce using rule 240 (primary -> name .)
    DOUBLEDOT       reduce using rule 240 (primary -> name .)
    WITH            reduce using rule 240 (primary -> name .)
    ARROW           reduce using rule 240 (primary -> name .)
    |               reduce using rule 240 (primary -> name .)
    THEN            reduce using rule 240 (primary -> name .)
    LOOP            reduce using rule 240 (primary -> name .)
    RANGE           reduce using rule 240 (primary -> name .)
    DIGITS          reduce using rule 240 (primary -> name .)
    RENAMES         reduce using rule 240 (primary -> name .)
    ASSIGNMENT      reduce using rule 240 (primary -> name .)
    SINGLEQUOTE     shift and go to state 251
    (               shift and go to state 249
    .               shift and go to state 250


state 150

    (169) operator_symbol -> STRLITERAL .

    SINGLEQUOTE     reduce using rule 169 (operator_symbol -> STRLITERAL .)
    (               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    .               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    DOUBLESTAR      reduce using rule 169 (operator_symbol -> STRLITERAL .)
    *               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    /               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    MOD             reduce using rule 169 (operator_symbol -> STRLITERAL .)
    REM             reduce using rule 169 (operator_symbol -> STRLITERAL .)
    =               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    NOTEQUAL        reduce using rule 169 (operator_symbol -> STRLITERAL .)
    <               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    LEQUAL          reduce using rule 169 (operator_symbol -> STRLITERAL .)
    >               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    GEQUAL          reduce using rule 169 (operator_symbol -> STRLITERAL .)
    IN              reduce using rule 169 (operator_symbol -> STRLITERAL .)
    NOT             reduce using rule 169 (operator_symbol -> STRLITERAL .)
    +               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    -               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    &               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    ;               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    AND             reduce using rule 169 (operator_symbol -> STRLITERAL .)
    OR              reduce using rule 169 (operator_symbol -> STRLITERAL .)
    XOR             reduce using rule 169 (operator_symbol -> STRLITERAL .)
    RANGE           reduce using rule 169 (operator_symbol -> STRLITERAL .)
    DIGITS          reduce using rule 169 (operator_symbol -> STRLITERAL .)
    WITH            reduce using rule 169 (operator_symbol -> STRLITERAL .)
    )               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    ,               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    ASSIGNMENT      reduce using rule 169 (operator_symbol -> STRLITERAL .)
    DOUBLEDOT       reduce using rule 169 (operator_symbol -> STRLITERAL .)
    ARROW           reduce using rule 169 (operator_symbol -> STRLITERAL .)
    |               reduce using rule 169 (operator_symbol -> STRLITERAL .)
    IS              reduce using rule 169 (operator_symbol -> STRLITERAL .)
    LOOP            reduce using rule 169 (operator_symbol -> STRLITERAL .)
    RENAMES         reduce using rule 169 (operator_symbol -> STRLITERAL .)
    THEN            reduce using rule 169 (operator_symbol -> STRLITERAL .)
    WHEN            reduce using rule 169 (operator_symbol -> STRLITERAL .)


state 151

    (242) primary -> qualified .

    DOUBLESTAR      reduce using rule 242 (primary -> qualified .)
    *               reduce using rule 242 (primary -> qualified .)
    /               reduce using rule 242 (primary -> qualified .)
    MOD             reduce using rule 242 (primary -> qualified .)
    REM             reduce using rule 242 (primary -> qualified .)
    =               reduce using rule 242 (primary -> qualified .)
    NOTEQUAL        reduce using rule 242 (primary -> qualified .)
    <               reduce using rule 242 (primary -> qualified .)
    LEQUAL          reduce using rule 242 (primary -> qualified .)
    >               reduce using rule 242 (primary -> qualified .)
    GEQUAL          reduce using rule 242 (primary -> qualified .)
    IN              reduce using rule 242 (primary -> qualified .)
    NOT             reduce using rule 242 (primary -> qualified .)
    +               reduce using rule 242 (primary -> qualified .)
    -               reduce using rule 242 (primary -> qualified .)
    &               reduce using rule 242 (primary -> qualified .)
    IS              reduce using rule 242 (primary -> qualified .)
    AND             reduce using rule 242 (primary -> qualified .)
    OR              reduce using rule 242 (primary -> qualified .)
    XOR             reduce using rule 242 (primary -> qualified .)
    ;               reduce using rule 242 (primary -> qualified .)
    DOUBLEDOT       reduce using rule 242 (primary -> qualified .)
    )               reduce using rule 242 (primary -> qualified .)
    ,               reduce using rule 242 (primary -> qualified .)
    ARROW           reduce using rule 242 (primary -> qualified .)
    |               reduce using rule 242 (primary -> qualified .)
    WITH            reduce using rule 242 (primary -> qualified .)
    THEN            reduce using rule 242 (primary -> qualified .)
    LOOP            reduce using rule 242 (primary -> qualified .)
    RANGE           reduce using rule 242 (primary -> qualified .)
    DIGITS          reduce using rule 242 (primary -> qualified .)
    RENAMES         reduce using rule 242 (primary -> qualified .)
    ASSIGNMENT      reduce using rule 242 (primary -> qualified .)


state 152

    (236) factor -> NOT . primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    primary                        shift and go to state 252
    used_char                      shift and go to state 146
    literal                        shift and go to state 137
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160

state 153

    (192) literal -> NuLL .

    DOUBLESTAR      reduce using rule 192 (literal -> NuLL .)
    *               reduce using rule 192 (literal -> NuLL .)
    /               reduce using rule 192 (literal -> NuLL .)
    MOD             reduce using rule 192 (literal -> NuLL .)
    REM             reduce using rule 192 (literal -> NuLL .)
    =               reduce using rule 192 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 192 (literal -> NuLL .)
    <               reduce using rule 192 (literal -> NuLL .)
    LEQUAL          reduce using rule 192 (literal -> NuLL .)
    >               reduce using rule 192 (literal -> NuLL .)
    GEQUAL          reduce using rule 192 (literal -> NuLL .)
    IN              reduce using rule 192 (literal -> NuLL .)
    NOT             reduce using rule 192 (literal -> NuLL .)
    +               reduce using rule 192 (literal -> NuLL .)
    -               reduce using rule 192 (literal -> NuLL .)
    &               reduce using rule 192 (literal -> NuLL .)
    RANGE           reduce using rule 192 (literal -> NuLL .)
    AND             reduce using rule 192 (literal -> NuLL .)
    OR              reduce using rule 192 (literal -> NuLL .)
    XOR             reduce using rule 192 (literal -> NuLL .)
    ;               reduce using rule 192 (literal -> NuLL .)
    THEN            reduce using rule 192 (literal -> NuLL .)
    DOUBLEDOT       reduce using rule 192 (literal -> NuLL .)
    RENAMES         reduce using rule 192 (literal -> NuLL .)
    ASSIGNMENT      reduce using rule 192 (literal -> NuLL .)
    WITH            reduce using rule 192 (literal -> NuLL .)
    )               reduce using rule 192 (literal -> NuLL .)
    ARROW           reduce using rule 192 (literal -> NuLL .)
    |               reduce using rule 192 (literal -> NuLL .)
    ,               reduce using rule 192 (literal -> NuLL .)
    IS              reduce using rule 192 (literal -> NuLL .)
    LOOP            reduce using rule 192 (literal -> NuLL .)
    DIGITS          reduce using rule 192 (literal -> NuLL .)


state 154

    (6) pragma_arg -> expression .
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    )               reduce using rule 6 (pragma_arg -> expression .)
    ,               reduce using rule 6 (pragma_arg -> expression .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 155

    (168) used_char -> CHARLITERAL .

    DOUBLESTAR      reduce using rule 168 (used_char -> CHARLITERAL .)
    *               reduce using rule 168 (used_char -> CHARLITERAL .)
    /               reduce using rule 168 (used_char -> CHARLITERAL .)
    MOD             reduce using rule 168 (used_char -> CHARLITERAL .)
    REM             reduce using rule 168 (used_char -> CHARLITERAL .)
    =               reduce using rule 168 (used_char -> CHARLITERAL .)
    NOTEQUAL        reduce using rule 168 (used_char -> CHARLITERAL .)
    <               reduce using rule 168 (used_char -> CHARLITERAL .)
    LEQUAL          reduce using rule 168 (used_char -> CHARLITERAL .)
    >               reduce using rule 168 (used_char -> CHARLITERAL .)
    GEQUAL          reduce using rule 168 (used_char -> CHARLITERAL .)
    IN              reduce using rule 168 (used_char -> CHARLITERAL .)
    NOT             reduce using rule 168 (used_char -> CHARLITERAL .)
    +               reduce using rule 168 (used_char -> CHARLITERAL .)
    -               reduce using rule 168 (used_char -> CHARLITERAL .)
    &               reduce using rule 168 (used_char -> CHARLITERAL .)
    AND             reduce using rule 168 (used_char -> CHARLITERAL .)
    OR              reduce using rule 168 (used_char -> CHARLITERAL .)
    XOR             reduce using rule 168 (used_char -> CHARLITERAL .)
    )               reduce using rule 168 (used_char -> CHARLITERAL .)
    ,               reduce using rule 168 (used_char -> CHARLITERAL .)
    WITH            reduce using rule 168 (used_char -> CHARLITERAL .)
    ARROW           reduce using rule 168 (used_char -> CHARLITERAL .)
    |               reduce using rule 168 (used_char -> CHARLITERAL .)
    ;               reduce using rule 168 (used_char -> CHARLITERAL .)
    IS              reduce using rule 168 (used_char -> CHARLITERAL .)
    THEN            reduce using rule 168 (used_char -> CHARLITERAL .)
    LOOP            reduce using rule 168 (used_char -> CHARLITERAL .)
    RANGE           reduce using rule 168 (used_char -> CHARLITERAL .)
    DIGITS          reduce using rule 168 (used_char -> CHARLITERAL .)
    RENAMES         reduce using rule 168 (used_char -> CHARLITERAL .)
    ASSIGNMENT      reduce using rule 168 (used_char -> CHARLITERAL .)
    DOUBLEDOT       reduce using rule 168 (used_char -> CHARLITERAL .)
    SINGLEQUOTE     reduce using rule 168 (used_char -> CHARLITERAL .)
    (               reduce using rule 168 (used_char -> CHARLITERAL .)
    .               reduce using rule 168 (used_char -> CHARLITERAL .)
    WHEN            reduce using rule 168 (used_char -> CHARLITERAL .)


state 156

    (437) comp_unit -> context_spec private_opt unit pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 437 (comp_unit -> context_spec private_opt unit pragma_s .)
    WITH            reduce using rule 437 (comp_unit -> context_spec private_opt unit pragma_s .)
    SEPARATE        reduce using rule 437 (comp_unit -> context_spec private_opt unit pragma_s .)
    PACKAGE         reduce using rule 437 (comp_unit -> context_spec private_opt unit pragma_s .)
    GENERIC         reduce using rule 437 (comp_unit -> context_spec private_opt unit pragma_s .)
    PROCEDURE       reduce using rule 437 (comp_unit -> context_spec private_opt unit pragma_s .)
    FUNCTION        reduce using rule 437 (comp_unit -> context_spec private_opt unit pragma_s .)
    $end            reduce using rule 437 (comp_unit -> context_spec private_opt unit pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 157

    (354) use_clause -> USE name_s . ;
    (357) name_s -> name_s . , name

    ;               shift and go to state 258
    ,               shift and go to state 259


state 158

    (356) name_s -> name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    ;               reduce using rule 356 (name_s -> name .)
    ,               reduce using rule 356 (name_s -> name .)
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 159

    (355) use_clause -> USE TYPE . name_s ;
    (356) name_s -> . name
    (357) name_s -> . name_s , name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name_s                         shift and go to state 261
    name                           shift and go to state 158
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 160

    (155) name -> simple_name .

    (               reduce using rule 155 (name -> simple_name .)
    .               reduce using rule 155 (name -> simple_name .)
    SINGLEQUOTE     reduce using rule 155 (name -> simple_name .)
    ARROW           reduce using rule 155 (name -> simple_name .)
    |               reduce using rule 155 (name -> simple_name .)
    ASSIGNMENT      reduce using rule 155 (name -> simple_name .)
    ;               reduce using rule 155 (name -> simple_name .)
    RANGE           reduce using rule 155 (name -> simple_name .)
    DOUBLESTAR      reduce using rule 155 (name -> simple_name .)
    *               reduce using rule 155 (name -> simple_name .)
    /               reduce using rule 155 (name -> simple_name .)
    MOD             reduce using rule 155 (name -> simple_name .)
    REM             reduce using rule 155 (name -> simple_name .)
    =               reduce using rule 155 (name -> simple_name .)
    NOTEQUAL        reduce using rule 155 (name -> simple_name .)
    <               reduce using rule 155 (name -> simple_name .)
    LEQUAL          reduce using rule 155 (name -> simple_name .)
    >               reduce using rule 155 (name -> simple_name .)
    GEQUAL          reduce using rule 155 (name -> simple_name .)
    IN              reduce using rule 155 (name -> simple_name .)
    NOT             reduce using rule 155 (name -> simple_name .)
    +               reduce using rule 155 (name -> simple_name .)
    -               reduce using rule 155 (name -> simple_name .)
    &               reduce using rule 155 (name -> simple_name .)
    )               reduce using rule 155 (name -> simple_name .)
    AND             reduce using rule 155 (name -> simple_name .)
    OR              reduce using rule 155 (name -> simple_name .)
    XOR             reduce using rule 155 (name -> simple_name .)
    DIGITS          reduce using rule 155 (name -> simple_name .)
    WITH            reduce using rule 155 (name -> simple_name .)
    ,               reduce using rule 155 (name -> simple_name .)
    RENAMES         reduce using rule 155 (name -> simple_name .)
    DOUBLEDOT       reduce using rule 155 (name -> simple_name .)
    IS              reduce using rule 155 (name -> simple_name .)
    THEN            reduce using rule 155 (name -> simple_name .)
    LOOP            reduce using rule 155 (name -> simple_name .)
    WHEN            reduce using rule 155 (name -> simple_name .)


state 161

    (454) subunit -> SEPARATE ( compound_name . ) subunit_body
    (165) compound_name -> compound_name . . simple_name

    )               shift and go to state 262
    .               shift and go to state 120


state 162

    (390) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt ;
    (462) body_stub -> PROTECTED BODY . simple_name IS SEPARATE ;
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 263

state 163

    (376) prot_spec -> PROTECTED TYPE . simple_name discrim_part_opt prot_def
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 264

state 164

    (375) prot_spec -> PROTECTED ID . prot_def
    (377) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt

    IS              shift and go to state 265

    prot_def                       shift and go to state 266

state 165

    (305) block_body -> BEGIN . handled_stmt_s
    (306) handled_stmt_s -> . statement_s except_handler_part_opt
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    label                          shift and go to state 285
    statement_s                    shift and go to state 305
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    handled_stmt_s                 shift and go to state 292
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    assign_stmt                    shift and go to state 315
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 166

    (338) subprog_body -> subprog_spec_is_push decl_part block_body . END id_opt ;

    END             shift and go to state 316


state 167

    (511) attrib_def -> FOR mark . USE expression ;
    (512) record_type_spec -> FOR mark . USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> FOR mark . USE AT expression ;
    (161) mark -> mark . SINGLEQUOTE attribute_id
    (162) mark -> mark . . simple_name

    USE             shift and go to state 317
    SINGLEQUOTE     shift and go to state 318
    .               shift and go to state 319


state 168

    (160) mark -> simple_name .

    USE             reduce using rule 160 (mark -> simple_name .)
    SINGLEQUOTE     reduce using rule 160 (mark -> simple_name .)
    .               reduce using rule 160 (mark -> simple_name .)
    ;               reduce using rule 160 (mark -> simple_name .)
    ASSIGNMENT      reduce using rule 160 (mark -> simple_name .)
    )               reduce using rule 160 (mark -> simple_name .)
    AT              reduce using rule 160 (mark -> simple_name .)


state 169

    (366) task_decl -> task_spec ; .

    error           reduce using rule 366 (task_decl -> task_spec ; .)
    USE             reduce using rule 366 (task_decl -> task_spec ; .)
    PRAGMA          reduce using rule 366 (task_decl -> task_spec ; .)
    TYPE            reduce using rule 366 (task_decl -> task_spec ; .)
    SUBTYPE         reduce using rule 366 (task_decl -> task_spec ; .)
    TASK            reduce using rule 366 (task_decl -> task_spec ; .)
    PACKAGE         reduce using rule 366 (task_decl -> task_spec ; .)
    PROTECTED       reduce using rule 366 (task_decl -> task_spec ; .)
    FOR             reduce using rule 366 (task_decl -> task_spec ; .)
    GENERIC         reduce using rule 366 (task_decl -> task_spec ; .)
    PROCEDURE       reduce using rule 366 (task_decl -> task_spec ; .)
    FUNCTION        reduce using rule 366 (task_decl -> task_spec ; .)
    ID              reduce using rule 366 (task_decl -> task_spec ; .)
    PRIVATE         reduce using rule 366 (task_decl -> task_spec ; .)
    END             reduce using rule 366 (task_decl -> task_spec ; .)
    BEGIN           reduce using rule 366 (task_decl -> task_spec ; .)


state 170

    (373) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt ;
    (459) body_stub -> TASK BODY . simple_name IS SEPARATE ;
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 320

state 171

    (368) task_spec -> TASK TYPE . simple_name discrim_part_opt task_def
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 321

state 172

    (367) task_spec -> TASK simple_name . task_def
    (369) task_def -> .
    (370) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt

    ;               reduce using rule 369 (task_def -> .)
    IS              shift and go to state 322

    task_def                       shift and go to state 323

state 173

    (148) decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .

    TASK            reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PROTECTED       reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    error           reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    USE             reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PRAGMA          reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PACKAGE         reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    TYPE            reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    SUBTYPE         reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    FOR             reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PROCEDURE       reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    FUNCTION        reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    GENERIC         reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    ID              reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    BEGIN           reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    END             reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)


state 174

    (347) pkg_start -> PACKAGE BODY . compound_name IS
    (460) body_stub -> PACKAGE BODY . compound_name IS SEPARATE ;
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    compound_name                  shift and go to state 324
    simple_name                    shift and go to state 42

state 175

    (342) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
    (361) rename_unit -> PACKAGE compound_name . renames ;
    (165) compound_name -> compound_name . . simple_name
    (365) renames -> . RENAMES name

    IS              shift and go to state 190
    .               shift and go to state 120
    RENAMES         shift and go to state 95

    renames                        shift and go to state 189

state 176

    (374) prot_decl -> prot_spec ; .

    error           reduce using rule 374 (prot_decl -> prot_spec ; .)
    USE             reduce using rule 374 (prot_decl -> prot_spec ; .)
    PRAGMA          reduce using rule 374 (prot_decl -> prot_spec ; .)
    TYPE            reduce using rule 374 (prot_decl -> prot_spec ; .)
    SUBTYPE         reduce using rule 374 (prot_decl -> prot_spec ; .)
    TASK            reduce using rule 374 (prot_decl -> prot_spec ; .)
    PACKAGE         reduce using rule 374 (prot_decl -> prot_spec ; .)
    PROTECTED       reduce using rule 374 (prot_decl -> prot_spec ; .)
    FOR             reduce using rule 374 (prot_decl -> prot_spec ; .)
    GENERIC         reduce using rule 374 (prot_decl -> prot_spec ; .)
    PROCEDURE       reduce using rule 374 (prot_decl -> prot_spec ; .)
    FUNCTION        reduce using rule 374 (prot_decl -> prot_spec ; .)
    ID              reduce using rule 374 (prot_decl -> prot_spec ; .)
    END             reduce using rule 374 (prot_decl -> prot_spec ; .)
    BEGIN           reduce using rule 374 (prot_decl -> prot_spec ; .)
    PRIVATE         reduce using rule 374 (prot_decl -> prot_spec ; .)


state 177

    (21) decl -> error ; .

    TASK            reduce using rule 21 (decl -> error ; .)
    PROTECTED       reduce using rule 21 (decl -> error ; .)
    error           reduce using rule 21 (decl -> error ; .)
    USE             reduce using rule 21 (decl -> error ; .)
    PRAGMA          reduce using rule 21 (decl -> error ; .)
    PACKAGE         reduce using rule 21 (decl -> error ; .)
    TYPE            reduce using rule 21 (decl -> error ; .)
    SUBTYPE         reduce using rule 21 (decl -> error ; .)
    FOR             reduce using rule 21 (decl -> error ; .)
    PROCEDURE       reduce using rule 21 (decl -> error ; .)
    FUNCTION        reduce using rule 21 (decl -> error ; .)
    GENERIC         reduce using rule 21 (decl -> error ; .)
    ID              reduce using rule 21 (decl -> error ; .)
    BEGIN           reduce using rule 21 (decl -> error ; .)
    END             reduce using rule 21 (decl -> error ; .)
    PRIVATE         reduce using rule 21 (decl -> error ; .)


state 178

    (36) type_decl -> TYPE ID . discrim_part_opt type_completion ;
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( BOX )
    (112) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    ;               reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 325

    discrim_part_opt               shift and go to state 326
    discrim_part                   shift and go to state 327

state 179

    (319) subprog_decl -> subprog_spec_is_push ABSTRACT ; .

    TASK            reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PROTECTED       reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    error           reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    USE             reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PRAGMA          reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PACKAGE         reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    TYPE            reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    SUBTYPE         reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    FOR             reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PROCEDURE       reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    FUNCTION        reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    GENERIC         reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    ID              reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    BEGIN           reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PRIVATE         reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    END             reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    WITH            reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    SEPARATE        reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    $end            reduce using rule 319 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)


state 180

    (50) subtype_decl -> SUBTYPE ID . IS subtype_ind ;

    IS              shift and go to state 328


state 181

    (337) subprog_spec_is_push -> subprog_spec IS .
    (461) body_stub -> subprog_spec IS . SEPARATE ;
    (505) generic_subp_inst -> subprog_spec IS . generic_inst
    (507) generic_inst -> . NEW name

    ABSTRACT        reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PACKAGE         reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    ID              reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    SEPARATE        shift and go to state 329
    NEW             shift and go to state 186

    generic_inst                   shift and go to state 187

state 182

    (25) def_id_s -> def_id_s , . def_id
    (26) def_id -> . ID

    ID              shift and go to state 91

    def_id                         shift and go to state 330

state 183

    (23) object_decl -> def_id_s : . object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> def_id_s : . CONSTANT ASSIGNMENT expression ;
    (463) exception_decl -> def_id_s : . EXCEPTION ;
    (358) rename_decl -> def_id_s : . object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> def_id_s : . EXCEPTION renames ;
    (27) object_qualifier_opt -> .
    (28) object_qualifier_opt -> . ALIASED
    (29) object_qualifier_opt -> . CONSTANT
    (30) object_qualifier_opt -> . ALIASED CONSTANT

    CONSTANT        shift and go to state 332
    EXCEPTION       shift and go to state 331
    ARRAY           reduce using rule 27 (object_qualifier_opt -> .)
    ID              reduce using rule 27 (object_qualifier_opt -> .)
    STRLITERAL      reduce using rule 27 (object_qualifier_opt -> .)
    ALIASED         shift and go to state 333

    object_qualifier_opt           shift and go to state 334

state 184

    (362) rename_unit -> subprog_spec renames ; .

    TASK            reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    PROTECTED       reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    error           reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    USE             reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    PRAGMA          reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    PACKAGE         reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    TYPE            reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    SUBTYPE         reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    FOR             reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    PROCEDURE       reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    FUNCTION        reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    GENERIC         reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    ID              reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    BEGIN           reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    END             reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    PRIVATE         reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    WITH            reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    SEPARATE        reduce using rule 362 (rename_unit -> subprog_spec renames ; .)
    $end            reduce using rule 362 (rename_unit -> subprog_spec renames ; .)


state 185

    (365) renames -> RENAMES name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    ;               reduce using rule 365 (renames -> RENAMES name .)
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 186

    (507) generic_inst -> NEW . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 335
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 187

    (505) generic_subp_inst -> subprog_spec IS generic_inst .

    ;               reduce using rule 505 (generic_subp_inst -> subprog_spec IS generic_inst .)


state 188

    (347) pkg_start -> PACKAGE BODY compound_name . IS
    (165) compound_name -> compound_name . . simple_name

    IS              shift and go to state 336
    .               shift and go to state 120


state 189

    (361) rename_unit -> PACKAGE compound_name renames . ;

    ;               shift and go to state 337


state 190

    (342) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> PACKAGE compound_name IS . generic_inst
    (139) decl_item_s -> .
    (140) decl_item_s -> . decl_item_s1
    (507) generic_inst -> . NEW name
    (141) decl_item_s1 -> . decl_item
    (142) decl_item_s1 -> . decl_item_s1 decl_item
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) subprog_spec_is_push -> . subprog_spec IS
    (26) def_id -> . ID

    PRIVATE         reduce using rule 139 (decl_item_s -> .)
    END             reduce using rule 139 (decl_item_s -> .)
    NEW             shift and go to state 186
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 343
    PACKAGE         shift and go to state 344
    PROTECTED       shift and go to state 340
    FOR             shift and go to state 64
    GENERIC         shift and go to state 21
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    ID              shift and go to state 91

    decl                           shift and go to state 51
    task_decl                      shift and go to state 61
    subtype_decl                   shift and go to state 62
    generic_inst                   shift and go to state 338
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 339
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    decl_item                      shift and go to state 341
    subprog_spec_is_push           shift and go to state 345
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 346
    def_id_s                       shift and go to state 87
    task_spec                      shift and go to state 66
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 88
    rename_decl                    shift and go to state 89
    type_decl                      shift and go to state 57
    rename_unit                    shift and go to state 90
    generic_formal_part            shift and go to state 34
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    subprog_decl                   shift and go to state 59
    decl_item_s                    shift and go to state 342
    pragma                         shift and go to state 75
    pkg_spec                       shift and go to state 38
    number_decl                    shift and go to state 93

state 191

    (326) formal_part_opt -> formal_part .

    WHEN            reduce using rule 326 (formal_part_opt -> formal_part .)
    ;               reduce using rule 326 (formal_part_opt -> formal_part .)
    DO              reduce using rule 326 (formal_part_opt -> formal_part .)
    RETURN          reduce using rule 326 (formal_part_opt -> formal_part .)
    IS              reduce using rule 326 (formal_part_opt -> formal_part .)
    RENAMES         reduce using rule 326 (formal_part_opt -> formal_part .)


state 192

    (327) formal_part -> ( . param_s )
    (328) param_s -> . param
    (329) param_s -> . param_s ; param
    (330) param -> . def_id_s : mode mark init_opt
    (331) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . ID

    error           shift and go to state 110
    ID              shift and go to state 91

    param_s                        shift and go to state 348
    param                          shift and go to state 347
    def_id                         shift and go to state 88
    def_id_s                       shift and go to state 106

state 193

    (320) subprog_spec -> PROCEDURE compound_name formal_part_opt .

    IS              reduce using rule 320 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
    ;               reduce using rule 320 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
    RENAMES         reduce using rule 320 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)


state 194

    (348) pkg_body -> pkg_start decl_part body_opt . END c_id_opt ;

    END             shift and go to state 349


state 195

    (350) body_opt -> block_body .

    END             reduce using rule 350 (body_opt -> block_body .)


state 196

    (482) generic_formal -> WITH FUNCTION . designator formal_part_opt RETURN name subp_default ;
    (323) designator -> . compound_name
    (324) designator -> . STRLITERAL
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    STRLITERAL      shift and go to state 114
    ID              shift and go to state 41

    designator                     shift and go to state 350
    compound_name                  shift and go to state 116
    simple_name                    shift and go to state 42

state 197

    (483) generic_formal -> WITH PACKAGE . simple_name IS NEW name ( BOX ) ;
    (484) generic_formal -> WITH PACKAGE . simple_name IS NEW name ;
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 351

state 198

    (481) generic_formal -> WITH PROCEDURE . simple_name formal_part_opt subp_default ;
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 352

state 199

    (479) generic_formal -> param ; .

    PACKAGE         reduce using rule 479 (generic_formal -> param ; .)
    PROCEDURE       reduce using rule 479 (generic_formal -> param ; .)
    FUNCTION        reduce using rule 479 (generic_formal -> param ; .)
    TYPE            reduce using rule 479 (generic_formal -> param ; .)
    WITH            reduce using rule 479 (generic_formal -> param ; .)
    error           reduce using rule 479 (generic_formal -> param ; .)
    USE             reduce using rule 479 (generic_formal -> param ; .)
    ID              reduce using rule 479 (generic_formal -> param ; .)


state 200

    (364) rename_unit -> generic_formal_part subprog_spec renames . ;

    ;               shift and go to state 353


state 201

    (475) generic_decl -> generic_formal_part subprog_spec ; .

    TASK            reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    PROTECTED       reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    error           reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    USE             reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    PRAGMA          reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    PACKAGE         reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    TYPE            reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    SUBTYPE         reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    FOR             reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    PROCEDURE       reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    FUNCTION        reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    GENERIC         reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    ID              reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    BEGIN           reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    PRIVATE         reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    WITH            reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    SEPARATE        reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    $end            reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)
    END             reduce using rule 475 (generic_decl -> generic_formal_part subprog_spec ; .)


state 202

    (330) param -> def_id_s : . mode mark init_opt
    (332) mode -> .
    (333) mode -> . IN
    (334) mode -> . OUT
    (335) mode -> . IN OUT
    (336) mode -> . ACCESS

    ID              reduce using rule 332 (mode -> .)
    IN              shift and go to state 356
    OUT             shift and go to state 355
    ACCESS          shift and go to state 354

    mode                           shift and go to state 357

state 203

    (363) rename_unit -> generic_formal_part PACKAGE compound_name . renames ;
    (342) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (165) compound_name -> compound_name . . simple_name
    (365) renames -> . RENAMES name

    IS              shift and go to state 359
    .               shift and go to state 120
    RENAMES         shift and go to state 95

    renames                        shift and go to state 358

state 204

    (476) generic_decl -> generic_formal_part pkg_spec ; .

    TASK            reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    PROTECTED       reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    error           reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    USE             reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    PRAGMA          reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    PACKAGE         reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    TYPE            reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    SUBTYPE         reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    FOR             reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    PROCEDURE       reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    FUNCTION        reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    GENERIC         reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    ID              reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    BEGIN           reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    PRIVATE         reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    WITH            reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    SEPARATE        reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    $end            reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)
    END             reduce using rule 476 (generic_decl -> generic_formal_part pkg_spec ; .)


state 205

    (480) generic_formal -> TYPE simple_name . generic_discrim_part_opt IS generic_type_def ;
    (486) generic_discrim_part_opt -> .
    (487) generic_discrim_part_opt -> . discrim_part
    (488) generic_discrim_part_opt -> . ( BOX )
    (112) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 486 (generic_discrim_part_opt -> .)
    (               shift and go to state 361

    generic_discrim_part_opt       shift and go to state 360
    discrim_part                   shift and go to state 362

state 206

    (321) subprog_spec -> FUNCTION designator formal_part_opt . RETURN name

    RETURN          shift and go to state 363


state 207

    (167) c_name_list -> c_name_list , compound_name .
    (165) compound_name -> compound_name . . simple_name

    ;               reduce using rule 167 (c_name_list -> c_name_list , compound_name .)
    ,               reduce using rule 167 (c_name_list -> c_name_list , compound_name .)
    .               shift and go to state 120


state 208

    (165) compound_name -> compound_name . simple_name .

    IS              reduce using rule 165 (compound_name -> compound_name . simple_name .)
    .               reduce using rule 165 (compound_name -> compound_name . simple_name .)
    RENAMES         reduce using rule 165 (compound_name -> compound_name . simple_name .)
    ;               reduce using rule 165 (compound_name -> compound_name . simple_name .)
    (               reduce using rule 165 (compound_name -> compound_name . simple_name .)
    RETURN          reduce using rule 165 (compound_name -> compound_name . simple_name .)
    ,               reduce using rule 165 (compound_name -> compound_name . simple_name .)
    )               reduce using rule 165 (compound_name -> compound_name . simple_name .)


state 209

    (237) factor -> primary DOUBLESTAR . primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    primary                        shift and go to state 364
    used_char                      shift and go to state 146
    literal                        shift and go to state 137
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160

state 210

    (221) simple_expression -> unary term .
    (230) term -> term . multiplying factor
    (231) multiplying -> . *
    (232) multiplying -> . /
    (233) multiplying -> . MOD
    (234) multiplying -> . REM

    DOUBLEDOT       reduce using rule 221 (simple_expression -> unary term .)
    =               reduce using rule 221 (simple_expression -> unary term .)
    NOTEQUAL        reduce using rule 221 (simple_expression -> unary term .)
    <               reduce using rule 221 (simple_expression -> unary term .)
    LEQUAL          reduce using rule 221 (simple_expression -> unary term .)
    >               reduce using rule 221 (simple_expression -> unary term .)
    GEQUAL          reduce using rule 221 (simple_expression -> unary term .)
    IN              reduce using rule 221 (simple_expression -> unary term .)
    NOT             reduce using rule 221 (simple_expression -> unary term .)
    +               reduce using rule 221 (simple_expression -> unary term .)
    -               reduce using rule 221 (simple_expression -> unary term .)
    &               reduce using rule 221 (simple_expression -> unary term .)
    AND             reduce using rule 221 (simple_expression -> unary term .)
    OR              reduce using rule 221 (simple_expression -> unary term .)
    XOR             reduce using rule 221 (simple_expression -> unary term .)
    ARROW           reduce using rule 221 (simple_expression -> unary term .)
    |               reduce using rule 221 (simple_expression -> unary term .)
    THEN            reduce using rule 221 (simple_expression -> unary term .)
    )               reduce using rule 221 (simple_expression -> unary term .)
    ,               reduce using rule 221 (simple_expression -> unary term .)
    WITH            reduce using rule 221 (simple_expression -> unary term .)
    ;               reduce using rule 221 (simple_expression -> unary term .)
    IS              reduce using rule 221 (simple_expression -> unary term .)
    LOOP            reduce using rule 221 (simple_expression -> unary term .)
    RANGE           reduce using rule 221 (simple_expression -> unary term .)
    DIGITS          reduce using rule 221 (simple_expression -> unary term .)
    RENAMES         reduce using rule 221 (simple_expression -> unary term .)
    ASSIGNMENT      reduce using rule 221 (simple_expression -> unary term .)
    *               shift and go to state 246
    /               shift and go to state 247
    MOD             shift and go to state 248
    REM             shift and go to state 244

    multiplying                    shift and go to state 245

state 211

    (247) allocator -> NEW name .
    (246) qualified -> name . SINGLEQUOTE parenthesized_primary
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    DOUBLESTAR      reduce using rule 247 (allocator -> NEW name .)
    *               reduce using rule 247 (allocator -> NEW name .)
    /               reduce using rule 247 (allocator -> NEW name .)
    MOD             reduce using rule 247 (allocator -> NEW name .)
    REM             reduce using rule 247 (allocator -> NEW name .)
    DOUBLEDOT       reduce using rule 247 (allocator -> NEW name .)
    +               reduce using rule 247 (allocator -> NEW name .)
    -               reduce using rule 247 (allocator -> NEW name .)
    &               reduce using rule 247 (allocator -> NEW name .)
    =               reduce using rule 247 (allocator -> NEW name .)
    NOTEQUAL        reduce using rule 247 (allocator -> NEW name .)
    <               reduce using rule 247 (allocator -> NEW name .)
    LEQUAL          reduce using rule 247 (allocator -> NEW name .)
    >               reduce using rule 247 (allocator -> NEW name .)
    GEQUAL          reduce using rule 247 (allocator -> NEW name .)
    IN              reduce using rule 247 (allocator -> NEW name .)
    NOT             reduce using rule 247 (allocator -> NEW name .)
    AND             reduce using rule 247 (allocator -> NEW name .)
    OR              reduce using rule 247 (allocator -> NEW name .)
    XOR             reduce using rule 247 (allocator -> NEW name .)
    )               reduce using rule 247 (allocator -> NEW name .)
    ,               reduce using rule 247 (allocator -> NEW name .)
    ARROW           reduce using rule 247 (allocator -> NEW name .)
    |               reduce using rule 247 (allocator -> NEW name .)
    THEN            reduce using rule 247 (allocator -> NEW name .)
    ;               reduce using rule 247 (allocator -> NEW name .)
    WITH            reduce using rule 247 (allocator -> NEW name .)
    IS              reduce using rule 247 (allocator -> NEW name .)
    LOOP            reduce using rule 247 (allocator -> NEW name .)
    RANGE           reduce using rule 247 (allocator -> NEW name .)
    DIGITS          reduce using rule 247 (allocator -> NEW name .)
    RENAMES         reduce using rule 247 (allocator -> NEW name .)
    ASSIGNMENT      reduce using rule 247 (allocator -> NEW name .)
    SINGLEQUOTE     shift and go to state 251
    (               shift and go to state 249
    .               shift and go to state 250


state 212

    (248) allocator -> NEW qualified .

    DOUBLESTAR      reduce using rule 248 (allocator -> NEW qualified .)
    *               reduce using rule 248 (allocator -> NEW qualified .)
    /               reduce using rule 248 (allocator -> NEW qualified .)
    MOD             reduce using rule 248 (allocator -> NEW qualified .)
    REM             reduce using rule 248 (allocator -> NEW qualified .)
    DOUBLEDOT       reduce using rule 248 (allocator -> NEW qualified .)
    +               reduce using rule 248 (allocator -> NEW qualified .)
    -               reduce using rule 248 (allocator -> NEW qualified .)
    &               reduce using rule 248 (allocator -> NEW qualified .)
    =               reduce using rule 248 (allocator -> NEW qualified .)
    NOTEQUAL        reduce using rule 248 (allocator -> NEW qualified .)
    <               reduce using rule 248 (allocator -> NEW qualified .)
    LEQUAL          reduce using rule 248 (allocator -> NEW qualified .)
    >               reduce using rule 248 (allocator -> NEW qualified .)
    GEQUAL          reduce using rule 248 (allocator -> NEW qualified .)
    IN              reduce using rule 248 (allocator -> NEW qualified .)
    NOT             reduce using rule 248 (allocator -> NEW qualified .)
    AND             reduce using rule 248 (allocator -> NEW qualified .)
    OR              reduce using rule 248 (allocator -> NEW qualified .)
    XOR             reduce using rule 248 (allocator -> NEW qualified .)
    )               reduce using rule 248 (allocator -> NEW qualified .)
    ,               reduce using rule 248 (allocator -> NEW qualified .)
    ARROW           reduce using rule 248 (allocator -> NEW qualified .)
    |               reduce using rule 248 (allocator -> NEW qualified .)
    THEN            reduce using rule 248 (allocator -> NEW qualified .)
    ;               reduce using rule 248 (allocator -> NEW qualified .)
    WITH            reduce using rule 248 (allocator -> NEW qualified .)
    IS              reduce using rule 248 (allocator -> NEW qualified .)
    LOOP            reduce using rule 248 (allocator -> NEW qualified .)
    RANGE           reduce using rule 248 (allocator -> NEW qualified .)
    DIGITS          reduce using rule 248 (allocator -> NEW qualified .)
    RENAMES         reduce using rule 248 (allocator -> NEW qualified .)
    ASSIGNMENT      reduce using rule 248 (allocator -> NEW qualified .)


state 213

    (223) simple_expression -> simple_expression adding . term
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 365
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    operator_symbol                shift and go to state 139

state 214

    (218) relational -> GEQUAL .

    +               reduce using rule 218 (relational -> GEQUAL .)
    -               reduce using rule 218 (relational -> GEQUAL .)
    NOT             reduce using rule 218 (relational -> GEQUAL .)
    ABS             reduce using rule 218 (relational -> GEQUAL .)
    NuLL            reduce using rule 218 (relational -> GEQUAL .)
    NEW             reduce using rule 218 (relational -> GEQUAL .)
    (               reduce using rule 218 (relational -> GEQUAL .)
    NUMLITERAL_BASE_INT reduce using rule 218 (relational -> GEQUAL .)
    NUMLITERAL_BASE_FLOAT reduce using rule 218 (relational -> GEQUAL .)
    NUMLITERAL_INT  reduce using rule 218 (relational -> GEQUAL .)
    NUMLITERAL_FLOAT reduce using rule 218 (relational -> GEQUAL .)
    CHARLITERAL     reduce using rule 218 (relational -> GEQUAL .)
    ID              reduce using rule 218 (relational -> GEQUAL .)
    STRLITERAL      reduce using rule 218 (relational -> GEQUAL .)


state 215

    (216) relational -> LEQUAL .

    +               reduce using rule 216 (relational -> LEQUAL .)
    -               reduce using rule 216 (relational -> LEQUAL .)
    NOT             reduce using rule 216 (relational -> LEQUAL .)
    ABS             reduce using rule 216 (relational -> LEQUAL .)
    NuLL            reduce using rule 216 (relational -> LEQUAL .)
    NEW             reduce using rule 216 (relational -> LEQUAL .)
    (               reduce using rule 216 (relational -> LEQUAL .)
    NUMLITERAL_BASE_INT reduce using rule 216 (relational -> LEQUAL .)
    NUMLITERAL_BASE_FLOAT reduce using rule 216 (relational -> LEQUAL .)
    NUMLITERAL_INT  reduce using rule 216 (relational -> LEQUAL .)
    NUMLITERAL_FLOAT reduce using rule 216 (relational -> LEQUAL .)
    CHARLITERAL     reduce using rule 216 (relational -> LEQUAL .)
    ID              reduce using rule 216 (relational -> LEQUAL .)
    STRLITERAL      reduce using rule 216 (relational -> LEQUAL .)


state 216

    (214) relational -> NOTEQUAL .

    +               reduce using rule 214 (relational -> NOTEQUAL .)
    -               reduce using rule 214 (relational -> NOTEQUAL .)
    NOT             reduce using rule 214 (relational -> NOTEQUAL .)
    ABS             reduce using rule 214 (relational -> NOTEQUAL .)
    NuLL            reduce using rule 214 (relational -> NOTEQUAL .)
    NEW             reduce using rule 214 (relational -> NOTEQUAL .)
    (               reduce using rule 214 (relational -> NOTEQUAL .)
    NUMLITERAL_BASE_INT reduce using rule 214 (relational -> NOTEQUAL .)
    NUMLITERAL_BASE_FLOAT reduce using rule 214 (relational -> NOTEQUAL .)
    NUMLITERAL_INT  reduce using rule 214 (relational -> NOTEQUAL .)
    NUMLITERAL_FLOAT reduce using rule 214 (relational -> NOTEQUAL .)
    CHARLITERAL     reduce using rule 214 (relational -> NOTEQUAL .)
    ID              reduce using rule 214 (relational -> NOTEQUAL .)
    STRLITERAL      reduce using rule 214 (relational -> NOTEQUAL .)


state 217

    (226) adding -> + .

    NOT             reduce using rule 226 (adding -> + .)
    ABS             reduce using rule 226 (adding -> + .)
    NuLL            reduce using rule 226 (adding -> + .)
    NEW             reduce using rule 226 (adding -> + .)
    (               reduce using rule 226 (adding -> + .)
    NUMLITERAL_BASE_INT reduce using rule 226 (adding -> + .)
    NUMLITERAL_BASE_FLOAT reduce using rule 226 (adding -> + .)
    NUMLITERAL_INT  reduce using rule 226 (adding -> + .)
    NUMLITERAL_FLOAT reduce using rule 226 (adding -> + .)
    CHARLITERAL     reduce using rule 226 (adding -> + .)
    ID              reduce using rule 226 (adding -> + .)
    STRLITERAL      reduce using rule 226 (adding -> + .)


state 218

    (228) adding -> & .

    NOT             reduce using rule 228 (adding -> & .)
    ABS             reduce using rule 228 (adding -> & .)
    NuLL            reduce using rule 228 (adding -> & .)
    NEW             reduce using rule 228 (adding -> & .)
    (               reduce using rule 228 (adding -> & .)
    NUMLITERAL_BASE_INT reduce using rule 228 (adding -> & .)
    NUMLITERAL_BASE_FLOAT reduce using rule 228 (adding -> & .)
    NUMLITERAL_INT  reduce using rule 228 (adding -> & .)
    NUMLITERAL_FLOAT reduce using rule 228 (adding -> & .)
    CHARLITERAL     reduce using rule 228 (adding -> & .)
    ID              reduce using rule 228 (adding -> & .)
    STRLITERAL      reduce using rule 228 (adding -> & .)


state 219

    (227) adding -> - .

    NOT             reduce using rule 227 (adding -> - .)
    ABS             reduce using rule 227 (adding -> - .)
    NuLL            reduce using rule 227 (adding -> - .)
    NEW             reduce using rule 227 (adding -> - .)
    (               reduce using rule 227 (adding -> - .)
    NUMLITERAL_BASE_INT reduce using rule 227 (adding -> - .)
    NUMLITERAL_BASE_FLOAT reduce using rule 227 (adding -> - .)
    NUMLITERAL_INT  reduce using rule 227 (adding -> - .)
    NUMLITERAL_FLOAT reduce using rule 227 (adding -> - .)
    CHARLITERAL     reduce using rule 227 (adding -> - .)
    ID              reduce using rule 227 (adding -> - .)
    STRLITERAL      reduce using rule 227 (adding -> - .)


state 220

    (211) relation -> simple_expression membership . range
    (212) relation -> simple_expression membership . name
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    simple_expression              shift and go to state 366
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 367
    operator_symbol                shift and go to state 139
    range                          shift and go to state 368

state 221

    (219) membership -> IN .

    ID              reduce using rule 219 (membership -> IN .)
    STRLITERAL      reduce using rule 219 (membership -> IN .)
    +               reduce using rule 219 (membership -> IN .)
    -               reduce using rule 219 (membership -> IN .)
    NOT             reduce using rule 219 (membership -> IN .)
    ABS             reduce using rule 219 (membership -> IN .)
    NuLL            reduce using rule 219 (membership -> IN .)
    NEW             reduce using rule 219 (membership -> IN .)
    (               reduce using rule 219 (membership -> IN .)
    NUMLITERAL_BASE_INT reduce using rule 219 (membership -> IN .)
    NUMLITERAL_BASE_FLOAT reduce using rule 219 (membership -> IN .)
    NUMLITERAL_INT  reduce using rule 219 (membership -> IN .)
    NUMLITERAL_FLOAT reduce using rule 219 (membership -> IN .)
    CHARLITERAL     reduce using rule 219 (membership -> IN .)


state 222

    (220) membership -> NOT . IN

    IN              shift and go to state 369


state 223

    (210) relation -> simple_expression relational . simple_expression
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    simple_expression              shift and go to state 370
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    operator_symbol                shift and go to state 139

state 224

    (213) relational -> = .

    +               reduce using rule 213 (relational -> = .)
    -               reduce using rule 213 (relational -> = .)
    NOT             reduce using rule 213 (relational -> = .)
    ABS             reduce using rule 213 (relational -> = .)
    NuLL            reduce using rule 213 (relational -> = .)
    NEW             reduce using rule 213 (relational -> = .)
    (               reduce using rule 213 (relational -> = .)
    NUMLITERAL_BASE_INT reduce using rule 213 (relational -> = .)
    NUMLITERAL_BASE_FLOAT reduce using rule 213 (relational -> = .)
    NUMLITERAL_INT  reduce using rule 213 (relational -> = .)
    NUMLITERAL_FLOAT reduce using rule 213 (relational -> = .)
    CHARLITERAL     reduce using rule 213 (relational -> = .)
    ID              reduce using rule 213 (relational -> = .)
    STRLITERAL      reduce using rule 213 (relational -> = .)


state 225

    (215) relational -> < .

    +               reduce using rule 215 (relational -> < .)
    -               reduce using rule 215 (relational -> < .)
    NOT             reduce using rule 215 (relational -> < .)
    ABS             reduce using rule 215 (relational -> < .)
    NuLL            reduce using rule 215 (relational -> < .)
    NEW             reduce using rule 215 (relational -> < .)
    (               reduce using rule 215 (relational -> < .)
    NUMLITERAL_BASE_INT reduce using rule 215 (relational -> < .)
    NUMLITERAL_BASE_FLOAT reduce using rule 215 (relational -> < .)
    NUMLITERAL_INT  reduce using rule 215 (relational -> < .)
    NUMLITERAL_FLOAT reduce using rule 215 (relational -> < .)
    CHARLITERAL     reduce using rule 215 (relational -> < .)
    ID              reduce using rule 215 (relational -> < .)
    STRLITERAL      reduce using rule 215 (relational -> < .)


state 226

    (217) relational -> > .

    +               reduce using rule 217 (relational -> > .)
    -               reduce using rule 217 (relational -> > .)
    NOT             reduce using rule 217 (relational -> > .)
    ABS             reduce using rule 217 (relational -> > .)
    NuLL            reduce using rule 217 (relational -> > .)
    NEW             reduce using rule 217 (relational -> > .)
    (               reduce using rule 217 (relational -> > .)
    NUMLITERAL_BASE_INT reduce using rule 217 (relational -> > .)
    NUMLITERAL_BASE_FLOAT reduce using rule 217 (relational -> > .)
    NUMLITERAL_INT  reduce using rule 217 (relational -> > .)
    NUMLITERAL_FLOAT reduce using rule 217 (relational -> > .)
    CHARLITERAL     reduce using rule 217 (relational -> > .)
    ID              reduce using rule 217 (relational -> > .)
    STRLITERAL      reduce using rule 217 (relational -> > .)


state 227

    (7) pragma_arg -> simple_name ARROW . expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 371

state 228

    (127) choice -> OTHERS .

    ARROW           reduce using rule 127 (choice -> OTHERS .)
    |               reduce using rule 127 (choice -> OTHERS .)


state 229

    (209) relation -> simple_expression .
    (210) relation -> simple_expression . relational simple_expression
    (211) relation -> simple_expression . membership range
    (212) relation -> simple_expression . membership name
    (223) simple_expression -> simple_expression . adding term
    (62) range -> simple_expression . DOUBLEDOT simple_expression
    (213) relational -> . =
    (214) relational -> . NOTEQUAL
    (215) relational -> . <
    (216) relational -> . LEQUAL
    (217) relational -> . >
    (218) relational -> . GEQUAL
    (219) membership -> . IN
    (220) membership -> . NOT IN
    (226) adding -> . +
    (227) adding -> . -
    (228) adding -> . &

    )               reduce using rule 209 (relation -> simple_expression .)
    WITH            reduce using rule 209 (relation -> simple_expression .)
    AND             reduce using rule 209 (relation -> simple_expression .)
    OR              reduce using rule 209 (relation -> simple_expression .)
    XOR             reduce using rule 209 (relation -> simple_expression .)
    ,               reduce using rule 209 (relation -> simple_expression .)
    ARROW           reduce using rule 209 (relation -> simple_expression .)
    |               reduce using rule 209 (relation -> simple_expression .)
    DOUBLEDOT       shift and go to state 372
    =               shift and go to state 224
    NOTEQUAL        shift and go to state 216
    <               shift and go to state 225
    LEQUAL          shift and go to state 215
    >               shift and go to state 226
    GEQUAL          shift and go to state 214
    IN              shift and go to state 221
    NOT             shift and go to state 222
    +               shift and go to state 217
    -               shift and go to state 219
    &               shift and go to state 218

    adding                         shift and go to state 213
    membership                     shift and go to state 220
    relational                     shift and go to state 223

state 230

    (200) comp_assoc -> choice_s . ARROW expression
    (124) choice_s -> choice_s . | choice

    ARROW           shift and go to state 374
    |               shift and go to state 373


state 231

    (193) aggregate -> ( comp_assoc . )
    (174) value -> comp_assoc .

    )               shift and go to state 375
    ,               reduce using rule 174 (value -> comp_assoc .)


state 232

    (123) choice_s -> choice .

    ARROW           reduce using rule 123 (choice_s -> choice .)
    |               reduce using rule 123 (choice_s -> choice .)


state 233

    (194) aggregate -> ( value_s_2 . )
    (199) value_s_2 -> value_s_2 . , value

    )               shift and go to state 376
    ,               shift and go to state 377


state 234

    (175) value -> discrete_with_range .
    (126) choice -> discrete_with_range .

    ,               reduce using rule 175 (value -> discrete_with_range .)
    )               reduce using rule 175 (value -> discrete_with_range .)
    ARROW           reduce using rule 126 (choice -> discrete_with_range .)
    |               reduce using rule 126 (choice -> discrete_with_range .)


state 235

    (128) discrete_with_range -> name . range_constraint
    (63) range -> name . SINGLEQUOTE RANGE
    (64) range -> name . SINGLEQUOTE RANGE ( expression )
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id
    (240) primary -> name .
    (246) qualified -> name . SINGLEQUOTE parenthesized_primary
    (61) range_constraint -> . RANGE range

    SINGLEQUOTE     shift and go to state 379
    (               shift and go to state 249
    .               shift and go to state 250
    DOUBLESTAR      reduce using rule 240 (primary -> name .)
    *               reduce using rule 240 (primary -> name .)
    /               reduce using rule 240 (primary -> name .)
    MOD             reduce using rule 240 (primary -> name .)
    REM             reduce using rule 240 (primary -> name .)
    DOUBLEDOT       reduce using rule 240 (primary -> name .)
    =               reduce using rule 240 (primary -> name .)
    NOTEQUAL        reduce using rule 240 (primary -> name .)
    <               reduce using rule 240 (primary -> name .)
    LEQUAL          reduce using rule 240 (primary -> name .)
    >               reduce using rule 240 (primary -> name .)
    GEQUAL          reduce using rule 240 (primary -> name .)
    IN              reduce using rule 240 (primary -> name .)
    NOT             reduce using rule 240 (primary -> name .)
    +               reduce using rule 240 (primary -> name .)
    -               reduce using rule 240 (primary -> name .)
    &               reduce using rule 240 (primary -> name .)
    AND             reduce using rule 240 (primary -> name .)
    OR              reduce using rule 240 (primary -> name .)
    XOR             reduce using rule 240 (primary -> name .)
    )               reduce using rule 240 (primary -> name .)
    ,               reduce using rule 240 (primary -> name .)
    ARROW           reduce using rule 240 (primary -> name .)
    |               reduce using rule 240 (primary -> name .)
    WITH            reduce using rule 240 (primary -> name .)
    RANGE           shift and go to state 378

    range_constraint               shift and go to state 380

state 236

    (198) value_s_2 -> value . , value

    ,               shift and go to state 381


state 237

    (129) discrete_with_range -> range .

    ARROW           reduce using rule 129 (discrete_with_range -> range .)
    |               reduce using rule 129 (discrete_with_range -> range .)
    )               reduce using rule 129 (discrete_with_range -> range .)
    ,               reduce using rule 129 (discrete_with_range -> range .)


state 238

    (176) value -> error .

    ,               reduce using rule 176 (value -> error .)
    )               reduce using rule 176 (value -> error .)


state 239

    (197) aggregate -> ( NuLL . RECORD )
    (192) literal -> NuLL .

    RECORD          shift and go to state 382
    DOUBLESTAR      reduce using rule 192 (literal -> NuLL .)
    *               reduce using rule 192 (literal -> NuLL .)
    /               reduce using rule 192 (literal -> NuLL .)
    MOD             reduce using rule 192 (literal -> NuLL .)
    REM             reduce using rule 192 (literal -> NuLL .)
    DOUBLEDOT       reduce using rule 192 (literal -> NuLL .)
    =               reduce using rule 192 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 192 (literal -> NuLL .)
    <               reduce using rule 192 (literal -> NuLL .)
    LEQUAL          reduce using rule 192 (literal -> NuLL .)
    >               reduce using rule 192 (literal -> NuLL .)
    GEQUAL          reduce using rule 192 (literal -> NuLL .)
    IN              reduce using rule 192 (literal -> NuLL .)
    NOT             reduce using rule 192 (literal -> NuLL .)
    +               reduce using rule 192 (literal -> NuLL .)
    -               reduce using rule 192 (literal -> NuLL .)
    &               reduce using rule 192 (literal -> NuLL .)
    )               reduce using rule 192 (literal -> NuLL .)
    WITH            reduce using rule 192 (literal -> NuLL .)
    AND             reduce using rule 192 (literal -> NuLL .)
    OR              reduce using rule 192 (literal -> NuLL .)
    XOR             reduce using rule 192 (literal -> NuLL .)
    ,               reduce using rule 192 (literal -> NuLL .)
    ARROW           reduce using rule 192 (literal -> NuLL .)
    |               reduce using rule 192 (literal -> NuLL .)


state 240

    (245) parenthesized_primary -> ( expression . )
    (195) aggregate -> ( expression . WITH value_s )
    (196) aggregate -> ( expression . WITH NuLL RECORD )
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (173) value -> expression .
    (125) choice -> expression .
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    )               shift and go to state 383
    WITH            shift and go to state 384
    ,               reduce using rule 173 (value -> expression .)
    ARROW           reduce using rule 125 (choice -> expression .)
    |               reduce using rule 125 (choice -> expression .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 241

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s ) . ;

    ;               shift and go to state 385


state 242

    (5) pragma_arg_s -> pragma_arg_s , . pragma_arg
    (6) pragma_arg -> . expression
    (7) pragma_arg -> . simple_name ARROW expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (163) simple_name -> . ID
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    ID              shift and go to state 41
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    pragma_arg                     shift and go to state 386
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 132
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    used_char                      shift and go to state 146
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 154

state 243

    (238) factor -> ABS primary .

    *               reduce using rule 238 (factor -> ABS primary .)
    /               reduce using rule 238 (factor -> ABS primary .)
    MOD             reduce using rule 238 (factor -> ABS primary .)
    REM             reduce using rule 238 (factor -> ABS primary .)
    =               reduce using rule 238 (factor -> ABS primary .)
    NOTEQUAL        reduce using rule 238 (factor -> ABS primary .)
    <               reduce using rule 238 (factor -> ABS primary .)
    LEQUAL          reduce using rule 238 (factor -> ABS primary .)
    >               reduce using rule 238 (factor -> ABS primary .)
    GEQUAL          reduce using rule 238 (factor -> ABS primary .)
    IN              reduce using rule 238 (factor -> ABS primary .)
    NOT             reduce using rule 238 (factor -> ABS primary .)
    +               reduce using rule 238 (factor -> ABS primary .)
    -               reduce using rule 238 (factor -> ABS primary .)
    &               reduce using rule 238 (factor -> ABS primary .)
    ;               reduce using rule 238 (factor -> ABS primary .)
    AND             reduce using rule 238 (factor -> ABS primary .)
    OR              reduce using rule 238 (factor -> ABS primary .)
    XOR             reduce using rule 238 (factor -> ABS primary .)
    )               reduce using rule 238 (factor -> ABS primary .)
    ,               reduce using rule 238 (factor -> ABS primary .)
    DOUBLEDOT       reduce using rule 238 (factor -> ABS primary .)
    WITH            reduce using rule 238 (factor -> ABS primary .)
    ARROW           reduce using rule 238 (factor -> ABS primary .)
    |               reduce using rule 238 (factor -> ABS primary .)
    IS              reduce using rule 238 (factor -> ABS primary .)
    THEN            reduce using rule 238 (factor -> ABS primary .)
    LOOP            reduce using rule 238 (factor -> ABS primary .)
    RANGE           reduce using rule 238 (factor -> ABS primary .)
    DIGITS          reduce using rule 238 (factor -> ABS primary .)
    RENAMES         reduce using rule 238 (factor -> ABS primary .)
    ASSIGNMENT      reduce using rule 238 (factor -> ABS primary .)


state 244

    (234) multiplying -> REM .

    NOT             reduce using rule 234 (multiplying -> REM .)
    ABS             reduce using rule 234 (multiplying -> REM .)
    NuLL            reduce using rule 234 (multiplying -> REM .)
    NEW             reduce using rule 234 (multiplying -> REM .)
    (               reduce using rule 234 (multiplying -> REM .)
    NUMLITERAL_BASE_INT reduce using rule 234 (multiplying -> REM .)
    NUMLITERAL_BASE_FLOAT reduce using rule 234 (multiplying -> REM .)
    NUMLITERAL_INT  reduce using rule 234 (multiplying -> REM .)
    NUMLITERAL_FLOAT reduce using rule 234 (multiplying -> REM .)
    CHARLITERAL     reduce using rule 234 (multiplying -> REM .)
    ID              reduce using rule 234 (multiplying -> REM .)
    STRLITERAL      reduce using rule 234 (multiplying -> REM .)


state 245

    (230) term -> term multiplying . factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 387
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    operator_symbol                shift and go to state 139

state 246

    (231) multiplying -> * .

    NOT             reduce using rule 231 (multiplying -> * .)
    ABS             reduce using rule 231 (multiplying -> * .)
    NuLL            reduce using rule 231 (multiplying -> * .)
    NEW             reduce using rule 231 (multiplying -> * .)
    (               reduce using rule 231 (multiplying -> * .)
    NUMLITERAL_BASE_INT reduce using rule 231 (multiplying -> * .)
    NUMLITERAL_BASE_FLOAT reduce using rule 231 (multiplying -> * .)
    NUMLITERAL_INT  reduce using rule 231 (multiplying -> * .)
    NUMLITERAL_FLOAT reduce using rule 231 (multiplying -> * .)
    CHARLITERAL     reduce using rule 231 (multiplying -> * .)
    ID              reduce using rule 231 (multiplying -> * .)
    STRLITERAL      reduce using rule 231 (multiplying -> * .)


state 247

    (232) multiplying -> / .

    NOT             reduce using rule 232 (multiplying -> / .)
    ABS             reduce using rule 232 (multiplying -> / .)
    NuLL            reduce using rule 232 (multiplying -> / .)
    NEW             reduce using rule 232 (multiplying -> / .)
    (               reduce using rule 232 (multiplying -> / .)
    NUMLITERAL_BASE_INT reduce using rule 232 (multiplying -> / .)
    NUMLITERAL_BASE_FLOAT reduce using rule 232 (multiplying -> / .)
    NUMLITERAL_INT  reduce using rule 232 (multiplying -> / .)
    NUMLITERAL_FLOAT reduce using rule 232 (multiplying -> / .)
    CHARLITERAL     reduce using rule 232 (multiplying -> / .)
    ID              reduce using rule 232 (multiplying -> / .)
    STRLITERAL      reduce using rule 232 (multiplying -> / .)


state 248

    (233) multiplying -> MOD .

    NOT             reduce using rule 233 (multiplying -> MOD .)
    ABS             reduce using rule 233 (multiplying -> MOD .)
    NuLL            reduce using rule 233 (multiplying -> MOD .)
    NEW             reduce using rule 233 (multiplying -> MOD .)
    (               reduce using rule 233 (multiplying -> MOD .)
    NUMLITERAL_BASE_INT reduce using rule 233 (multiplying -> MOD .)
    NUMLITERAL_BASE_FLOAT reduce using rule 233 (multiplying -> MOD .)
    NUMLITERAL_INT  reduce using rule 233 (multiplying -> MOD .)
    NUMLITERAL_FLOAT reduce using rule 233 (multiplying -> MOD .)
    CHARLITERAL     reduce using rule 233 (multiplying -> MOD .)
    ID              reduce using rule 233 (multiplying -> MOD .)
    STRLITERAL      reduce using rule 233 (multiplying -> MOD .)


state 249

    (170) indexed_comp -> name ( . value_s )
    (171) value_s -> . value
    (172) value_s -> . value_s , value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (200) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 238
    OTHERS          shift and go to state 228
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    value_s                        shift and go to state 388
    simple_expression              shift and go to state 389
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    choice_s                       shift and go to state 230
    operator_symbol                shift and go to state 139
    comp_assoc                     shift and go to state 390
    factor                         shift and go to state 138
    choice                         shift and go to state 232
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    discrete_with_range            shift and go to state 234
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 235
    value                          shift and go to state 391
    range                          shift and go to state 237
    expression                     shift and go to state 392

state 250

    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (163) simple_name -> . ID
    (168) used_char -> . CHARLITERAL
    (169) operator_symbol -> . STRLITERAL

    ALL             shift and go to state 393
    ID              shift and go to state 41
    CHARLITERAL     shift and go to state 155
    STRLITERAL      shift and go to state 150

    used_char                      shift and go to state 395
    operator_symbol                shift and go to state 394
    simple_name                    shift and go to state 396

state 251

    (246) qualified -> name SINGLEQUOTE . parenthesized_primary
    (181) attribute -> name SINGLEQUOTE . attribute_id
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (182) attribute_id -> . ID
    (183) attribute_id -> . DIGITS
    (184) attribute_id -> . DELTA
    (185) attribute_id -> . ACCESS
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    (               shift and go to state 134
    ID              shift and go to state 402
    DIGITS          shift and go to state 397
    DELTA           shift and go to state 400
    ACCESS          shift and go to state 398

    attribute_id                   shift and go to state 399
    aggregate                      shift and go to state 145
    parenthesized_primary          shift and go to state 401

state 252

    (236) factor -> NOT primary .

    *               reduce using rule 236 (factor -> NOT primary .)
    /               reduce using rule 236 (factor -> NOT primary .)
    MOD             reduce using rule 236 (factor -> NOT primary .)
    REM             reduce using rule 236 (factor -> NOT primary .)
    =               reduce using rule 236 (factor -> NOT primary .)
    NOTEQUAL        reduce using rule 236 (factor -> NOT primary .)
    <               reduce using rule 236 (factor -> NOT primary .)
    LEQUAL          reduce using rule 236 (factor -> NOT primary .)
    >               reduce using rule 236 (factor -> NOT primary .)
    GEQUAL          reduce using rule 236 (factor -> NOT primary .)
    IN              reduce using rule 236 (factor -> NOT primary .)
    NOT             reduce using rule 236 (factor -> NOT primary .)
    +               reduce using rule 236 (factor -> NOT primary .)
    -               reduce using rule 236 (factor -> NOT primary .)
    &               reduce using rule 236 (factor -> NOT primary .)
    ;               reduce using rule 236 (factor -> NOT primary .)
    AND             reduce using rule 236 (factor -> NOT primary .)
    OR              reduce using rule 236 (factor -> NOT primary .)
    XOR             reduce using rule 236 (factor -> NOT primary .)
    )               reduce using rule 236 (factor -> NOT primary .)
    ,               reduce using rule 236 (factor -> NOT primary .)
    DOUBLEDOT       reduce using rule 236 (factor -> NOT primary .)
    WITH            reduce using rule 236 (factor -> NOT primary .)
    ARROW           reduce using rule 236 (factor -> NOT primary .)
    |               reduce using rule 236 (factor -> NOT primary .)
    IS              reduce using rule 236 (factor -> NOT primary .)
    THEN            reduce using rule 236 (factor -> NOT primary .)
    LOOP            reduce using rule 236 (factor -> NOT primary .)
    RANGE           reduce using rule 236 (factor -> NOT primary .)
    DIGITS          reduce using rule 236 (factor -> NOT primary .)
    RENAMES         reduce using rule 236 (factor -> NOT primary .)
    ASSIGNMENT      reduce using rule 236 (factor -> NOT primary .)


state 253

    (204) logical -> AND .
    (207) short_circuit -> AND . THEN

    +               reduce using rule 204 (logical -> AND .)
    -               reduce using rule 204 (logical -> AND .)
    NOT             reduce using rule 204 (logical -> AND .)
    ABS             reduce using rule 204 (logical -> AND .)
    NuLL            reduce using rule 204 (logical -> AND .)
    NEW             reduce using rule 204 (logical -> AND .)
    (               reduce using rule 204 (logical -> AND .)
    NUMLITERAL_BASE_INT reduce using rule 204 (logical -> AND .)
    NUMLITERAL_BASE_FLOAT reduce using rule 204 (logical -> AND .)
    NUMLITERAL_INT  reduce using rule 204 (logical -> AND .)
    NUMLITERAL_FLOAT reduce using rule 204 (logical -> AND .)
    CHARLITERAL     reduce using rule 204 (logical -> AND .)
    ID              reduce using rule 204 (logical -> AND .)
    STRLITERAL      reduce using rule 204 (logical -> AND .)
    THEN            shift and go to state 403


state 254

    (206) logical -> XOR .

    +               reduce using rule 206 (logical -> XOR .)
    -               reduce using rule 206 (logical -> XOR .)
    NOT             reduce using rule 206 (logical -> XOR .)
    ABS             reduce using rule 206 (logical -> XOR .)
    NuLL            reduce using rule 206 (logical -> XOR .)
    NEW             reduce using rule 206 (logical -> XOR .)
    (               reduce using rule 206 (logical -> XOR .)
    NUMLITERAL_BASE_INT reduce using rule 206 (logical -> XOR .)
    NUMLITERAL_BASE_FLOAT reduce using rule 206 (logical -> XOR .)
    NUMLITERAL_INT  reduce using rule 206 (logical -> XOR .)
    NUMLITERAL_FLOAT reduce using rule 206 (logical -> XOR .)
    CHARLITERAL     reduce using rule 206 (logical -> XOR .)
    ID              reduce using rule 206 (logical -> XOR .)
    STRLITERAL      reduce using rule 206 (logical -> XOR .)


state 255

    (202) expression -> expression logical . m relation
    (519) m -> .

    +               reduce using rule 519 (m -> .)
    -               reduce using rule 519 (m -> .)
    NOT             reduce using rule 519 (m -> .)
    ABS             reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    NEW             reduce using rule 519 (m -> .)
    (               reduce using rule 519 (m -> .)
    NUMLITERAL_BASE_INT reduce using rule 519 (m -> .)
    NUMLITERAL_BASE_FLOAT reduce using rule 519 (m -> .)
    NUMLITERAL_INT  reduce using rule 519 (m -> .)
    NUMLITERAL_FLOAT reduce using rule 519 (m -> .)
    CHARLITERAL     reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)

    m                              shift and go to state 404

state 256

    (203) expression -> expression short_circuit . m relation
    (519) m -> .

    +               reduce using rule 519 (m -> .)
    -               reduce using rule 519 (m -> .)
    NOT             reduce using rule 519 (m -> .)
    ABS             reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    NEW             reduce using rule 519 (m -> .)
    (               reduce using rule 519 (m -> .)
    NUMLITERAL_BASE_INT reduce using rule 519 (m -> .)
    NUMLITERAL_BASE_FLOAT reduce using rule 519 (m -> .)
    NUMLITERAL_INT  reduce using rule 519 (m -> .)
    NUMLITERAL_FLOAT reduce using rule 519 (m -> .)
    CHARLITERAL     reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)

    m                              shift and go to state 405

state 257

    (205) logical -> OR .
    (208) short_circuit -> OR . ELSE

    +               reduce using rule 205 (logical -> OR .)
    -               reduce using rule 205 (logical -> OR .)
    NOT             reduce using rule 205 (logical -> OR .)
    ABS             reduce using rule 205 (logical -> OR .)
    NuLL            reduce using rule 205 (logical -> OR .)
    NEW             reduce using rule 205 (logical -> OR .)
    (               reduce using rule 205 (logical -> OR .)
    NUMLITERAL_BASE_INT reduce using rule 205 (logical -> OR .)
    NUMLITERAL_BASE_FLOAT reduce using rule 205 (logical -> OR .)
    NUMLITERAL_INT  reduce using rule 205 (logical -> OR .)
    NUMLITERAL_FLOAT reduce using rule 205 (logical -> OR .)
    CHARLITERAL     reduce using rule 205 (logical -> OR .)
    ID              reduce using rule 205 (logical -> OR .)
    STRLITERAL      reduce using rule 205 (logical -> OR .)
    ELSE            shift and go to state 406


state 258

    (354) use_clause -> USE name_s ; .

    TASK            reduce using rule 354 (use_clause -> USE name_s ; .)
    PROTECTED       reduce using rule 354 (use_clause -> USE name_s ; .)
    error           reduce using rule 354 (use_clause -> USE name_s ; .)
    USE             reduce using rule 354 (use_clause -> USE name_s ; .)
    PRAGMA          reduce using rule 354 (use_clause -> USE name_s ; .)
    PACKAGE         reduce using rule 354 (use_clause -> USE name_s ; .)
    TYPE            reduce using rule 354 (use_clause -> USE name_s ; .)
    SUBTYPE         reduce using rule 354 (use_clause -> USE name_s ; .)
    FOR             reduce using rule 354 (use_clause -> USE name_s ; .)
    PROCEDURE       reduce using rule 354 (use_clause -> USE name_s ; .)
    FUNCTION        reduce using rule 354 (use_clause -> USE name_s ; .)
    GENERIC         reduce using rule 354 (use_clause -> USE name_s ; .)
    ID              reduce using rule 354 (use_clause -> USE name_s ; .)
    BEGIN           reduce using rule 354 (use_clause -> USE name_s ; .)
    END             reduce using rule 354 (use_clause -> USE name_s ; .)
    WITH            reduce using rule 354 (use_clause -> USE name_s ; .)
    PRIVATE         reduce using rule 354 (use_clause -> USE name_s ; .)
    SEPARATE        reduce using rule 354 (use_clause -> USE name_s ; .)


state 259

    (357) name_s -> name_s , . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 407
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 260

    (181) attribute -> name SINGLEQUOTE . attribute_id
    (182) attribute_id -> . ID
    (183) attribute_id -> . DIGITS
    (184) attribute_id -> . DELTA
    (185) attribute_id -> . ACCESS

    ID              shift and go to state 402
    DIGITS          shift and go to state 397
    DELTA           shift and go to state 400
    ACCESS          shift and go to state 398

    attribute_id                   shift and go to state 399

state 261

    (355) use_clause -> USE TYPE name_s . ;
    (357) name_s -> name_s . , name

    ;               shift and go to state 408
    ,               shift and go to state 259


state 262

    (454) subunit -> SEPARATE ( compound_name ) . subunit_body
    (455) subunit_body -> . subprog_body
    (456) subunit_body -> . pkg_body
    (457) subunit_body -> . task_body
    (458) subunit_body -> . prot_body
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (348) pkg_body -> . pkg_start decl_part body_opt END c_id_opt ;
    (373) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (390) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (337) subprog_spec_is_push -> . subprog_spec IS
    (347) pkg_start -> . PACKAGE BODY compound_name IS
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator

    TASK            shift and go to state 413
    PROTECTED       shift and go to state 411
    PACKAGE         shift and go to state 415
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37

    subprog_body                   shift and go to state 409
    pkg_start                      shift and go to state 33
    subprog_spec_is_push           shift and go to state 416
    prot_body                      shift and go to state 417
    pkg_body                       shift and go to state 418
    task_body                      shift and go to state 410
    subprog_spec                   shift and go to state 414
    subunit_body                   shift and go to state 412

state 263

    (390) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt ;
    (462) body_stub -> PROTECTED BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 419


state 264

    (376) prot_spec -> PROTECTED TYPE simple_name . discrim_part_opt prot_def
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( BOX )
    (112) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 325

    discrim_part_opt               shift and go to state 420
    discrim_part                   shift and go to state 327

state 265

    (377) prot_def -> IS . prot_op_decl_s prot_private_opt END id_opt
    (380) prot_op_decl_s -> .
    (381) prot_op_decl_s -> . prot_op_decl_s prot_op_decl

    PRIVATE         reduce using rule 380 (prot_op_decl_s -> .)
    ENTRY           reduce using rule 380 (prot_op_decl_s -> .)
    PROCEDURE       reduce using rule 380 (prot_op_decl_s -> .)
    FUNCTION        reduce using rule 380 (prot_op_decl_s -> .)
    PRAGMA          reduce using rule 380 (prot_op_decl_s -> .)
    FOR             reduce using rule 380 (prot_op_decl_s -> .)
    END             reduce using rule 380 (prot_op_decl_s -> .)

    prot_op_decl_s                 shift and go to state 421

state 266

    (375) prot_spec -> PROTECTED ID prot_def .

    ;               reduce using rule 375 (prot_spec -> PROTECTED ID prot_def .)


state 267

    (412) delay_stmt -> DELAY . expression ;
    (413) delay_stmt -> DELAY . UNTIL expression ;
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    UNTIL           shift and go to state 422
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 423

state 268

    (415) select_stmt -> async_select .

    LEFTLABEL       reduce using rule 415 (select_stmt -> async_select .)
    error           reduce using rule 415 (select_stmt -> async_select .)
    PRAGMA          reduce using rule 415 (select_stmt -> async_select .)
    NuLL            reduce using rule 415 (select_stmt -> async_select .)
    EXIT            reduce using rule 415 (select_stmt -> async_select .)
    RETURN          reduce using rule 415 (select_stmt -> async_select .)
    GOTO            reduce using rule 415 (select_stmt -> async_select .)
    DELAY           reduce using rule 415 (select_stmt -> async_select .)
    ABORT           reduce using rule 415 (select_stmt -> async_select .)
    RAISE           reduce using rule 415 (select_stmt -> async_select .)
    REQUEUE         reduce using rule 415 (select_stmt -> async_select .)
    IF              reduce using rule 415 (select_stmt -> async_select .)
    CASE            reduce using rule 415 (select_stmt -> async_select .)
    ID              reduce using rule 415 (select_stmt -> async_select .)
    ACCEPT          reduce using rule 415 (select_stmt -> async_select .)
    SELECT          reduce using rule 415 (select_stmt -> async_select .)
    STRLITERAL      reduce using rule 415 (select_stmt -> async_select .)
    WHILE           reduce using rule 415 (select_stmt -> async_select .)
    DECLARE         reduce using rule 415 (select_stmt -> async_select .)
    FOR             reduce using rule 415 (select_stmt -> async_select .)
    LOOP            reduce using rule 415 (select_stmt -> async_select .)
    BEGIN           reduce using rule 415 (select_stmt -> async_select .)
    END             reduce using rule 415 (select_stmt -> async_select .)
    WHEN            reduce using rule 415 (select_stmt -> async_select .)
    EXCEPTION       reduce using rule 415 (select_stmt -> async_select .)
    OR              reduce using rule 415 (select_stmt -> async_select .)
    ELSE            reduce using rule 415 (select_stmt -> async_select .)
    THEN            reduce using rule 415 (select_stmt -> async_select .)
    ELSIF           reduce using rule 415 (select_stmt -> async_select .)


state 269

    (273) compound_stmt -> select_stmt .

    END             reduce using rule 273 (compound_stmt -> select_stmt .)
    LEFTLABEL       reduce using rule 273 (compound_stmt -> select_stmt .)
    error           reduce using rule 273 (compound_stmt -> select_stmt .)
    PRAGMA          reduce using rule 273 (compound_stmt -> select_stmt .)
    NuLL            reduce using rule 273 (compound_stmt -> select_stmt .)
    EXIT            reduce using rule 273 (compound_stmt -> select_stmt .)
    RETURN          reduce using rule 273 (compound_stmt -> select_stmt .)
    GOTO            reduce using rule 273 (compound_stmt -> select_stmt .)
    DELAY           reduce using rule 273 (compound_stmt -> select_stmt .)
    ABORT           reduce using rule 273 (compound_stmt -> select_stmt .)
    RAISE           reduce using rule 273 (compound_stmt -> select_stmt .)
    REQUEUE         reduce using rule 273 (compound_stmt -> select_stmt .)
    IF              reduce using rule 273 (compound_stmt -> select_stmt .)
    CASE            reduce using rule 273 (compound_stmt -> select_stmt .)
    ID              reduce using rule 273 (compound_stmt -> select_stmt .)
    ACCEPT          reduce using rule 273 (compound_stmt -> select_stmt .)
    SELECT          reduce using rule 273 (compound_stmt -> select_stmt .)
    STRLITERAL      reduce using rule 273 (compound_stmt -> select_stmt .)
    WHILE           reduce using rule 273 (compound_stmt -> select_stmt .)
    DECLARE         reduce using rule 273 (compound_stmt -> select_stmt .)
    FOR             reduce using rule 273 (compound_stmt -> select_stmt .)
    LOOP            reduce using rule 273 (compound_stmt -> select_stmt .)
    BEGIN           reduce using rule 273 (compound_stmt -> select_stmt .)
    EXCEPTION       reduce using rule 273 (compound_stmt -> select_stmt .)
    OR              reduce using rule 273 (compound_stmt -> select_stmt .)
    ELSE            reduce using rule 273 (compound_stmt -> select_stmt .)
    THEN            reduce using rule 273 (compound_stmt -> select_stmt .)
    ELSIF           reduce using rule 273 (compound_stmt -> select_stmt .)
    WHEN            reduce using rule 273 (compound_stmt -> select_stmt .)


state 270

    (290) loop_stmt -> label_opt . iteration m basic_loop id_opt ;
    (302) block -> label_opt . block_decl block_body END id_opt ;
    (293) iteration -> .
    (294) iteration -> . WHILE m condition
    (295) iteration -> . iter_part reverse_opt discrete_range
    (303) block_decl -> .
    (304) block_decl -> . DECLARE decl_part
    (296) iter_part -> . FOR ID IN

    LOOP            reduce using rule 293 (iteration -> .)
    WHILE           shift and go to state 428
    BEGIN           reduce using rule 303 (block_decl -> .)
    DECLARE         shift and go to state 429
    FOR             shift and go to state 425

    iter_part                      shift and go to state 424
    iteration                      shift and go to state 426
    block_decl                     shift and go to state 427

state 271

    (316) goto_stmt -> GOTO . name ;
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 430
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 272

    (253) unlabeled -> simple_stmt .

    LEFTLABEL       reduce using rule 253 (unlabeled -> simple_stmt .)
    error           reduce using rule 253 (unlabeled -> simple_stmt .)
    PRAGMA          reduce using rule 253 (unlabeled -> simple_stmt .)
    NuLL            reduce using rule 253 (unlabeled -> simple_stmt .)
    EXIT            reduce using rule 253 (unlabeled -> simple_stmt .)
    RETURN          reduce using rule 253 (unlabeled -> simple_stmt .)
    GOTO            reduce using rule 253 (unlabeled -> simple_stmt .)
    DELAY           reduce using rule 253 (unlabeled -> simple_stmt .)
    ABORT           reduce using rule 253 (unlabeled -> simple_stmt .)
    RAISE           reduce using rule 253 (unlabeled -> simple_stmt .)
    REQUEUE         reduce using rule 253 (unlabeled -> simple_stmt .)
    IF              reduce using rule 253 (unlabeled -> simple_stmt .)
    CASE            reduce using rule 253 (unlabeled -> simple_stmt .)
    ID              reduce using rule 253 (unlabeled -> simple_stmt .)
    ACCEPT          reduce using rule 253 (unlabeled -> simple_stmt .)
    SELECT          reduce using rule 253 (unlabeled -> simple_stmt .)
    STRLITERAL      reduce using rule 253 (unlabeled -> simple_stmt .)
    WHILE           reduce using rule 253 (unlabeled -> simple_stmt .)
    DECLARE         reduce using rule 253 (unlabeled -> simple_stmt .)
    FOR             reduce using rule 253 (unlabeled -> simple_stmt .)
    LOOP            reduce using rule 253 (unlabeled -> simple_stmt .)
    BEGIN           reduce using rule 253 (unlabeled -> simple_stmt .)
    WHEN            reduce using rule 253 (unlabeled -> simple_stmt .)
    END             reduce using rule 253 (unlabeled -> simple_stmt .)
    OR              reduce using rule 253 (unlabeled -> simple_stmt .)
    ELSE            reduce using rule 253 (unlabeled -> simple_stmt .)
    EXCEPTION       reduce using rule 253 (unlabeled -> simple_stmt .)
    THEN            reduce using rule 253 (unlabeled -> simple_stmt .)
    ELSIF           reduce using rule 253 (unlabeled -> simple_stmt .)


state 273

    (270) compound_stmt -> loop_stmt .

    END             reduce using rule 270 (compound_stmt -> loop_stmt .)
    LEFTLABEL       reduce using rule 270 (compound_stmt -> loop_stmt .)
    error           reduce using rule 270 (compound_stmt -> loop_stmt .)
    PRAGMA          reduce using rule 270 (compound_stmt -> loop_stmt .)
    NuLL            reduce using rule 270 (compound_stmt -> loop_stmt .)
    EXIT            reduce using rule 270 (compound_stmt -> loop_stmt .)
    RETURN          reduce using rule 270 (compound_stmt -> loop_stmt .)
    GOTO            reduce using rule 270 (compound_stmt -> loop_stmt .)
    DELAY           reduce using rule 270 (compound_stmt -> loop_stmt .)
    ABORT           reduce using rule 270 (compound_stmt -> loop_stmt .)
    RAISE           reduce using rule 270 (compound_stmt -> loop_stmt .)
    REQUEUE         reduce using rule 270 (compound_stmt -> loop_stmt .)
    IF              reduce using rule 270 (compound_stmt -> loop_stmt .)
    CASE            reduce using rule 270 (compound_stmt -> loop_stmt .)
    ID              reduce using rule 270 (compound_stmt -> loop_stmt .)
    ACCEPT          reduce using rule 270 (compound_stmt -> loop_stmt .)
    SELECT          reduce using rule 270 (compound_stmt -> loop_stmt .)
    STRLITERAL      reduce using rule 270 (compound_stmt -> loop_stmt .)
    WHILE           reduce using rule 270 (compound_stmt -> loop_stmt .)
    DECLARE         reduce using rule 270 (compound_stmt -> loop_stmt .)
    FOR             reduce using rule 270 (compound_stmt -> loop_stmt .)
    LOOP            reduce using rule 270 (compound_stmt -> loop_stmt .)
    BEGIN           reduce using rule 270 (compound_stmt -> loop_stmt .)
    EXCEPTION       reduce using rule 270 (compound_stmt -> loop_stmt .)
    OR              reduce using rule 270 (compound_stmt -> loop_stmt .)
    ELSE            reduce using rule 270 (compound_stmt -> loop_stmt .)
    THEN            reduce using rule 270 (compound_stmt -> loop_stmt .)
    ELSIF           reduce using rule 270 (compound_stmt -> loop_stmt .)
    WHEN            reduce using rule 270 (compound_stmt -> loop_stmt .)


state 274

    (518) code_stmt -> qualified . ;

    ;               shift and go to state 431


state 275

    (268) compound_stmt -> if_stmt .

    END             reduce using rule 268 (compound_stmt -> if_stmt .)
    LEFTLABEL       reduce using rule 268 (compound_stmt -> if_stmt .)
    error           reduce using rule 268 (compound_stmt -> if_stmt .)
    PRAGMA          reduce using rule 268 (compound_stmt -> if_stmt .)
    NuLL            reduce using rule 268 (compound_stmt -> if_stmt .)
    EXIT            reduce using rule 268 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 268 (compound_stmt -> if_stmt .)
    GOTO            reduce using rule 268 (compound_stmt -> if_stmt .)
    DELAY           reduce using rule 268 (compound_stmt -> if_stmt .)
    ABORT           reduce using rule 268 (compound_stmt -> if_stmt .)
    RAISE           reduce using rule 268 (compound_stmt -> if_stmt .)
    REQUEUE         reduce using rule 268 (compound_stmt -> if_stmt .)
    IF              reduce using rule 268 (compound_stmt -> if_stmt .)
    CASE            reduce using rule 268 (compound_stmt -> if_stmt .)
    ID              reduce using rule 268 (compound_stmt -> if_stmt .)
    ACCEPT          reduce using rule 268 (compound_stmt -> if_stmt .)
    SELECT          reduce using rule 268 (compound_stmt -> if_stmt .)
    STRLITERAL      reduce using rule 268 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 268 (compound_stmt -> if_stmt .)
    DECLARE         reduce using rule 268 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 268 (compound_stmt -> if_stmt .)
    LOOP            reduce using rule 268 (compound_stmt -> if_stmt .)
    BEGIN           reduce using rule 268 (compound_stmt -> if_stmt .)
    EXCEPTION       reduce using rule 268 (compound_stmt -> if_stmt .)
    OR              reduce using rule 268 (compound_stmt -> if_stmt .)
    ELSE            reduce using rule 268 (compound_stmt -> if_stmt .)
    THEN            reduce using rule 268 (compound_stmt -> if_stmt .)
    ELSIF           reduce using rule 268 (compound_stmt -> if_stmt .)
    WHEN            reduce using rule 268 (compound_stmt -> if_stmt .)


state 276

    (276) assign_stmt -> name . ASSIGNMENT expression ;
    (339) procedure_call -> name . ;
    (246) qualified -> name . SINGLEQUOTE parenthesized_primary
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    ASSIGNMENT      shift and go to state 432
    ;               shift and go to state 433
    SINGLEQUOTE     shift and go to state 251
    (               shift and go to state 249
    .               shift and go to state 250


state 277

    (433) abort_stmt -> ABORT . name_s ;
    (356) name_s -> . name
    (357) name_s -> . name_s , name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name_s                         shift and go to state 434
    name                           shift and go to state 158
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 278

    (275) null_stmt -> NuLL . ;

    ;               shift and go to state 435


state 279

    (272) compound_stmt -> accept_stmt .

    END             reduce using rule 272 (compound_stmt -> accept_stmt .)
    LEFTLABEL       reduce using rule 272 (compound_stmt -> accept_stmt .)
    error           reduce using rule 272 (compound_stmt -> accept_stmt .)
    PRAGMA          reduce using rule 272 (compound_stmt -> accept_stmt .)
    NuLL            reduce using rule 272 (compound_stmt -> accept_stmt .)
    EXIT            reduce using rule 272 (compound_stmt -> accept_stmt .)
    RETURN          reduce using rule 272 (compound_stmt -> accept_stmt .)
    GOTO            reduce using rule 272 (compound_stmt -> accept_stmt .)
    DELAY           reduce using rule 272 (compound_stmt -> accept_stmt .)
    ABORT           reduce using rule 272 (compound_stmt -> accept_stmt .)
    RAISE           reduce using rule 272 (compound_stmt -> accept_stmt .)
    REQUEUE         reduce using rule 272 (compound_stmt -> accept_stmt .)
    IF              reduce using rule 272 (compound_stmt -> accept_stmt .)
    CASE            reduce using rule 272 (compound_stmt -> accept_stmt .)
    ID              reduce using rule 272 (compound_stmt -> accept_stmt .)
    ACCEPT          reduce using rule 272 (compound_stmt -> accept_stmt .)
    SELECT          reduce using rule 272 (compound_stmt -> accept_stmt .)
    STRLITERAL      reduce using rule 272 (compound_stmt -> accept_stmt .)
    WHILE           reduce using rule 272 (compound_stmt -> accept_stmt .)
    DECLARE         reduce using rule 272 (compound_stmt -> accept_stmt .)
    FOR             reduce using rule 272 (compound_stmt -> accept_stmt .)
    LOOP            reduce using rule 272 (compound_stmt -> accept_stmt .)
    BEGIN           reduce using rule 272 (compound_stmt -> accept_stmt .)
    EXCEPTION       reduce using rule 272 (compound_stmt -> accept_stmt .)
    OR              reduce using rule 272 (compound_stmt -> accept_stmt .)
    ELSE            reduce using rule 272 (compound_stmt -> accept_stmt .)
    THEN            reduce using rule 272 (compound_stmt -> accept_stmt .)
    ELSIF           reduce using rule 272 (compound_stmt -> accept_stmt .)
    WHEN            reduce using rule 272 (compound_stmt -> accept_stmt .)


state 280

    (314) return_stmt -> RETURN . ;
    (315) return_stmt -> RETURN . expression ;
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    ;               shift and go to state 436
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 437

state 281

    (409) accept_hdr -> ACCEPT . entry_name formal_part_opt
    (410) entry_name -> . simple_name
    (411) entry_name -> . entry_name ( expression )
    (163) simple_name -> . ID

    ID              shift and go to state 41

    entry_name                     shift and go to state 438
    simple_name                    shift and go to state 439

state 282

    (261) simple_stmt -> procedure_call .

    END             reduce using rule 261 (simple_stmt -> procedure_call .)
    LEFTLABEL       reduce using rule 261 (simple_stmt -> procedure_call .)
    error           reduce using rule 261 (simple_stmt -> procedure_call .)
    PRAGMA          reduce using rule 261 (simple_stmt -> procedure_call .)
    NuLL            reduce using rule 261 (simple_stmt -> procedure_call .)
    EXIT            reduce using rule 261 (simple_stmt -> procedure_call .)
    RETURN          reduce using rule 261 (simple_stmt -> procedure_call .)
    GOTO            reduce using rule 261 (simple_stmt -> procedure_call .)
    DELAY           reduce using rule 261 (simple_stmt -> procedure_call .)
    ABORT           reduce using rule 261 (simple_stmt -> procedure_call .)
    RAISE           reduce using rule 261 (simple_stmt -> procedure_call .)
    REQUEUE         reduce using rule 261 (simple_stmt -> procedure_call .)
    IF              reduce using rule 261 (simple_stmt -> procedure_call .)
    CASE            reduce using rule 261 (simple_stmt -> procedure_call .)
    ID              reduce using rule 261 (simple_stmt -> procedure_call .)
    ACCEPT          reduce using rule 261 (simple_stmt -> procedure_call .)
    SELECT          reduce using rule 261 (simple_stmt -> procedure_call .)
    STRLITERAL      reduce using rule 261 (simple_stmt -> procedure_call .)
    WHILE           reduce using rule 261 (simple_stmt -> procedure_call .)
    DECLARE         reduce using rule 261 (simple_stmt -> procedure_call .)
    FOR             reduce using rule 261 (simple_stmt -> procedure_call .)
    LOOP            reduce using rule 261 (simple_stmt -> procedure_call .)
    BEGIN           reduce using rule 261 (simple_stmt -> procedure_call .)
    EXCEPTION       reduce using rule 261 (simple_stmt -> procedure_call .)
    OR              reduce using rule 261 (simple_stmt -> procedure_call .)
    ELSE            reduce using rule 261 (simple_stmt -> procedure_call .)
    THEN            reduce using rule 261 (simple_stmt -> procedure_call .)
    ELSIF           reduce using rule 261 (simple_stmt -> procedure_call .)
    WHEN            reduce using rule 261 (simple_stmt -> procedure_call .)


state 283

    (418) select_wait -> SELECT . guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> SELECT . delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> SELECT . entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> SELECT . entry_call stmts_opt ELSE statement_s END SELECT ;
    (419) guarded_select_alt -> . select_alt
    (420) guarded_select_alt -> . WHEN condition ARROW select_alt
    (426) delay_or_entry_alt -> . delay_stmt stmts_opt
    (427) delay_or_entry_alt -> . entry_call stmts_opt
    (406) entry_call -> . procedure_call
    (423) select_alt -> . accept_stmt stmts_opt
    (424) select_alt -> . delay_stmt stmts_opt
    (425) select_alt -> . TERMINATE ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (339) procedure_call -> . name ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    WHEN            shift and go to state 444
    TERMINATE       shift and go to state 449
    DELAY           shift and go to state 267
    ACCEPT          shift and go to state 281
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    accept_stmt                    shift and go to state 440
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    entry_call                     shift and go to state 441
    delay_or_entry_alt             shift and go to state 443
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160
    guarded_select_alt             shift and go to state 445
    select_alt                     shift and go to state 446
    delay_stmt                     shift and go to state 447
    accept_hdr                     shift and go to state 297
    name                           shift and go to state 448
    operator_symbol                shift and go to state 139
    procedure_call                 shift and go to state 442

state 284

    (269) compound_stmt -> case_stmt .

    END             reduce using rule 269 (compound_stmt -> case_stmt .)
    LEFTLABEL       reduce using rule 269 (compound_stmt -> case_stmt .)
    error           reduce using rule 269 (compound_stmt -> case_stmt .)
    PRAGMA          reduce using rule 269 (compound_stmt -> case_stmt .)
    NuLL            reduce using rule 269 (compound_stmt -> case_stmt .)
    EXIT            reduce using rule 269 (compound_stmt -> case_stmt .)
    RETURN          reduce using rule 269 (compound_stmt -> case_stmt .)
    GOTO            reduce using rule 269 (compound_stmt -> case_stmt .)
    DELAY           reduce using rule 269 (compound_stmt -> case_stmt .)
    ABORT           reduce using rule 269 (compound_stmt -> case_stmt .)
    RAISE           reduce using rule 269 (compound_stmt -> case_stmt .)
    REQUEUE         reduce using rule 269 (compound_stmt -> case_stmt .)
    IF              reduce using rule 269 (compound_stmt -> case_stmt .)
    CASE            reduce using rule 269 (compound_stmt -> case_stmt .)
    ID              reduce using rule 269 (compound_stmt -> case_stmt .)
    ACCEPT          reduce using rule 269 (compound_stmt -> case_stmt .)
    SELECT          reduce using rule 269 (compound_stmt -> case_stmt .)
    STRLITERAL      reduce using rule 269 (compound_stmt -> case_stmt .)
    WHILE           reduce using rule 269 (compound_stmt -> case_stmt .)
    DECLARE         reduce using rule 269 (compound_stmt -> case_stmt .)
    FOR             reduce using rule 269 (compound_stmt -> case_stmt .)
    LOOP            reduce using rule 269 (compound_stmt -> case_stmt .)
    BEGIN           reduce using rule 269 (compound_stmt -> case_stmt .)
    EXCEPTION       reduce using rule 269 (compound_stmt -> case_stmt .)
    OR              reduce using rule 269 (compound_stmt -> case_stmt .)
    ELSE            reduce using rule 269 (compound_stmt -> case_stmt .)
    THEN            reduce using rule 269 (compound_stmt -> case_stmt .)
    ELSIF           reduce using rule 269 (compound_stmt -> case_stmt .)
    WHEN            reduce using rule 269 (compound_stmt -> case_stmt .)


state 285

    (252) statement -> label . statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    accept_hdr                     shift and go to state 297
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 450
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 286

    (254) unlabeled -> compound_stmt .

    LEFTLABEL       reduce using rule 254 (unlabeled -> compound_stmt .)
    error           reduce using rule 254 (unlabeled -> compound_stmt .)
    PRAGMA          reduce using rule 254 (unlabeled -> compound_stmt .)
    NuLL            reduce using rule 254 (unlabeled -> compound_stmt .)
    EXIT            reduce using rule 254 (unlabeled -> compound_stmt .)
    RETURN          reduce using rule 254 (unlabeled -> compound_stmt .)
    GOTO            reduce using rule 254 (unlabeled -> compound_stmt .)
    DELAY           reduce using rule 254 (unlabeled -> compound_stmt .)
    ABORT           reduce using rule 254 (unlabeled -> compound_stmt .)
    RAISE           reduce using rule 254 (unlabeled -> compound_stmt .)
    REQUEUE         reduce using rule 254 (unlabeled -> compound_stmt .)
    IF              reduce using rule 254 (unlabeled -> compound_stmt .)
    CASE            reduce using rule 254 (unlabeled -> compound_stmt .)
    ID              reduce using rule 254 (unlabeled -> compound_stmt .)
    ACCEPT          reduce using rule 254 (unlabeled -> compound_stmt .)
    SELECT          reduce using rule 254 (unlabeled -> compound_stmt .)
    STRLITERAL      reduce using rule 254 (unlabeled -> compound_stmt .)
    WHILE           reduce using rule 254 (unlabeled -> compound_stmt .)
    DECLARE         reduce using rule 254 (unlabeled -> compound_stmt .)
    FOR             reduce using rule 254 (unlabeled -> compound_stmt .)
    LOOP            reduce using rule 254 (unlabeled -> compound_stmt .)
    BEGIN           reduce using rule 254 (unlabeled -> compound_stmt .)
    WHEN            reduce using rule 254 (unlabeled -> compound_stmt .)
    END             reduce using rule 254 (unlabeled -> compound_stmt .)
    OR              reduce using rule 254 (unlabeled -> compound_stmt .)
    ELSE            reduce using rule 254 (unlabeled -> compound_stmt .)
    EXCEPTION       reduce using rule 254 (unlabeled -> compound_stmt .)
    THEN            reduce using rule 254 (unlabeled -> compound_stmt .)
    ELSIF           reduce using rule 254 (unlabeled -> compound_stmt .)


state 287

    (260) simple_stmt -> goto_stmt .

    END             reduce using rule 260 (simple_stmt -> goto_stmt .)
    LEFTLABEL       reduce using rule 260 (simple_stmt -> goto_stmt .)
    error           reduce using rule 260 (simple_stmt -> goto_stmt .)
    PRAGMA          reduce using rule 260 (simple_stmt -> goto_stmt .)
    NuLL            reduce using rule 260 (simple_stmt -> goto_stmt .)
    EXIT            reduce using rule 260 (simple_stmt -> goto_stmt .)
    RETURN          reduce using rule 260 (simple_stmt -> goto_stmt .)
    GOTO            reduce using rule 260 (simple_stmt -> goto_stmt .)
    DELAY           reduce using rule 260 (simple_stmt -> goto_stmt .)
    ABORT           reduce using rule 260 (simple_stmt -> goto_stmt .)
    RAISE           reduce using rule 260 (simple_stmt -> goto_stmt .)
    REQUEUE         reduce using rule 260 (simple_stmt -> goto_stmt .)
    IF              reduce using rule 260 (simple_stmt -> goto_stmt .)
    CASE            reduce using rule 260 (simple_stmt -> goto_stmt .)
    ID              reduce using rule 260 (simple_stmt -> goto_stmt .)
    ACCEPT          reduce using rule 260 (simple_stmt -> goto_stmt .)
    SELECT          reduce using rule 260 (simple_stmt -> goto_stmt .)
    STRLITERAL      reduce using rule 260 (simple_stmt -> goto_stmt .)
    WHILE           reduce using rule 260 (simple_stmt -> goto_stmt .)
    DECLARE         reduce using rule 260 (simple_stmt -> goto_stmt .)
    FOR             reduce using rule 260 (simple_stmt -> goto_stmt .)
    LOOP            reduce using rule 260 (simple_stmt -> goto_stmt .)
    BEGIN           reduce using rule 260 (simple_stmt -> goto_stmt .)
    EXCEPTION       reduce using rule 260 (simple_stmt -> goto_stmt .)
    OR              reduce using rule 260 (simple_stmt -> goto_stmt .)
    ELSE            reduce using rule 260 (simple_stmt -> goto_stmt .)
    THEN            reduce using rule 260 (simple_stmt -> goto_stmt .)
    ELSIF           reduce using rule 260 (simple_stmt -> goto_stmt .)
    WHEN            reduce using rule 260 (simple_stmt -> goto_stmt .)


state 288

    (285) case_stmt -> case_hdr . pragma_s alternative_s END CASE ;
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 451

state 289

    (271) compound_stmt -> block .

    END             reduce using rule 271 (compound_stmt -> block .)
    LEFTLABEL       reduce using rule 271 (compound_stmt -> block .)
    error           reduce using rule 271 (compound_stmt -> block .)
    PRAGMA          reduce using rule 271 (compound_stmt -> block .)
    NuLL            reduce using rule 271 (compound_stmt -> block .)
    EXIT            reduce using rule 271 (compound_stmt -> block .)
    RETURN          reduce using rule 271 (compound_stmt -> block .)
    GOTO            reduce using rule 271 (compound_stmt -> block .)
    DELAY           reduce using rule 271 (compound_stmt -> block .)
    ABORT           reduce using rule 271 (compound_stmt -> block .)
    RAISE           reduce using rule 271 (compound_stmt -> block .)
    REQUEUE         reduce using rule 271 (compound_stmt -> block .)
    IF              reduce using rule 271 (compound_stmt -> block .)
    CASE            reduce using rule 271 (compound_stmt -> block .)
    ID              reduce using rule 271 (compound_stmt -> block .)
    ACCEPT          reduce using rule 271 (compound_stmt -> block .)
    SELECT          reduce using rule 271 (compound_stmt -> block .)
    STRLITERAL      reduce using rule 271 (compound_stmt -> block .)
    WHILE           reduce using rule 271 (compound_stmt -> block .)
    DECLARE         reduce using rule 271 (compound_stmt -> block .)
    FOR             reduce using rule 271 (compound_stmt -> block .)
    LOOP            reduce using rule 271 (compound_stmt -> block .)
    BEGIN           reduce using rule 271 (compound_stmt -> block .)
    EXCEPTION       reduce using rule 271 (compound_stmt -> block .)
    OR              reduce using rule 271 (compound_stmt -> block .)
    ELSE            reduce using rule 271 (compound_stmt -> block .)
    THEN            reduce using rule 271 (compound_stmt -> block .)
    ELSIF           reduce using rule 271 (compound_stmt -> block .)
    WHEN            reduce using rule 271 (compound_stmt -> block .)


state 290

    (472) raise_stmt -> RAISE . name_opt ;
    (310) name_opt -> .
    (311) name_opt -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ;               reduce using rule 310 (name_opt -> .)
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 452
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    name_opt                       shift and go to state 453
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 291

    (259) simple_stmt -> return_stmt .

    END             reduce using rule 259 (simple_stmt -> return_stmt .)
    LEFTLABEL       reduce using rule 259 (simple_stmt -> return_stmt .)
    error           reduce using rule 259 (simple_stmt -> return_stmt .)
    PRAGMA          reduce using rule 259 (simple_stmt -> return_stmt .)
    NuLL            reduce using rule 259 (simple_stmt -> return_stmt .)
    EXIT            reduce using rule 259 (simple_stmt -> return_stmt .)
    RETURN          reduce using rule 259 (simple_stmt -> return_stmt .)
    GOTO            reduce using rule 259 (simple_stmt -> return_stmt .)
    DELAY           reduce using rule 259 (simple_stmt -> return_stmt .)
    ABORT           reduce using rule 259 (simple_stmt -> return_stmt .)
    RAISE           reduce using rule 259 (simple_stmt -> return_stmt .)
    REQUEUE         reduce using rule 259 (simple_stmt -> return_stmt .)
    IF              reduce using rule 259 (simple_stmt -> return_stmt .)
    CASE            reduce using rule 259 (simple_stmt -> return_stmt .)
    ID              reduce using rule 259 (simple_stmt -> return_stmt .)
    ACCEPT          reduce using rule 259 (simple_stmt -> return_stmt .)
    SELECT          reduce using rule 259 (simple_stmt -> return_stmt .)
    STRLITERAL      reduce using rule 259 (simple_stmt -> return_stmt .)
    WHILE           reduce using rule 259 (simple_stmt -> return_stmt .)
    DECLARE         reduce using rule 259 (simple_stmt -> return_stmt .)
    FOR             reduce using rule 259 (simple_stmt -> return_stmt .)
    LOOP            reduce using rule 259 (simple_stmt -> return_stmt .)
    BEGIN           reduce using rule 259 (simple_stmt -> return_stmt .)
    EXCEPTION       reduce using rule 259 (simple_stmt -> return_stmt .)
    OR              reduce using rule 259 (simple_stmt -> return_stmt .)
    ELSE            reduce using rule 259 (simple_stmt -> return_stmt .)
    THEN            reduce using rule 259 (simple_stmt -> return_stmt .)
    ELSIF           reduce using rule 259 (simple_stmt -> return_stmt .)
    WHEN            reduce using rule 259 (simple_stmt -> return_stmt .)


state 292

    (305) block_body -> BEGIN handled_stmt_s .

    END             reduce using rule 305 (block_body -> BEGIN handled_stmt_s .)


state 293

    (286) case_hdr -> CASE . expression IS
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 454

state 294

    (473) requeue_stmt -> REQUEUE . name ;
    (474) requeue_stmt -> REQUEUE . name WITH ABORT ;
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 455
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 295

    (249) statement_s -> statement .

    END             reduce using rule 249 (statement_s -> statement .)
    LEFTLABEL       reduce using rule 249 (statement_s -> statement .)
    error           reduce using rule 249 (statement_s -> statement .)
    PRAGMA          reduce using rule 249 (statement_s -> statement .)
    NuLL            reduce using rule 249 (statement_s -> statement .)
    EXIT            reduce using rule 249 (statement_s -> statement .)
    RETURN          reduce using rule 249 (statement_s -> statement .)
    GOTO            reduce using rule 249 (statement_s -> statement .)
    DELAY           reduce using rule 249 (statement_s -> statement .)
    ABORT           reduce using rule 249 (statement_s -> statement .)
    RAISE           reduce using rule 249 (statement_s -> statement .)
    REQUEUE         reduce using rule 249 (statement_s -> statement .)
    IF              reduce using rule 249 (statement_s -> statement .)
    CASE            reduce using rule 249 (statement_s -> statement .)
    ID              reduce using rule 249 (statement_s -> statement .)
    ACCEPT          reduce using rule 249 (statement_s -> statement .)
    SELECT          reduce using rule 249 (statement_s -> statement .)
    STRLITERAL      reduce using rule 249 (statement_s -> statement .)
    WHILE           reduce using rule 249 (statement_s -> statement .)
    DECLARE         reduce using rule 249 (statement_s -> statement .)
    FOR             reduce using rule 249 (statement_s -> statement .)
    LOOP            reduce using rule 249 (statement_s -> statement .)
    BEGIN           reduce using rule 249 (statement_s -> statement .)
    ELSIF           reduce using rule 249 (statement_s -> statement .)
    ELSE            reduce using rule 249 (statement_s -> statement .)
    WHEN            reduce using rule 249 (statement_s -> statement .)
    THEN            reduce using rule 249 (statement_s -> statement .)
    OR              reduce using rule 249 (statement_s -> statement .)
    EXCEPTION       reduce using rule 249 (statement_s -> statement .)


state 296

    (262) simple_stmt -> delay_stmt .

    END             reduce using rule 262 (simple_stmt -> delay_stmt .)
    LEFTLABEL       reduce using rule 262 (simple_stmt -> delay_stmt .)
    error           reduce using rule 262 (simple_stmt -> delay_stmt .)
    PRAGMA          reduce using rule 262 (simple_stmt -> delay_stmt .)
    NuLL            reduce using rule 262 (simple_stmt -> delay_stmt .)
    EXIT            reduce using rule 262 (simple_stmt -> delay_stmt .)
    RETURN          reduce using rule 262 (simple_stmt -> delay_stmt .)
    GOTO            reduce using rule 262 (simple_stmt -> delay_stmt .)
    DELAY           reduce using rule 262 (simple_stmt -> delay_stmt .)
    ABORT           reduce using rule 262 (simple_stmt -> delay_stmt .)
    RAISE           reduce using rule 262 (simple_stmt -> delay_stmt .)
    REQUEUE         reduce using rule 262 (simple_stmt -> delay_stmt .)
    IF              reduce using rule 262 (simple_stmt -> delay_stmt .)
    CASE            reduce using rule 262 (simple_stmt -> delay_stmt .)
    ID              reduce using rule 262 (simple_stmt -> delay_stmt .)
    ACCEPT          reduce using rule 262 (simple_stmt -> delay_stmt .)
    SELECT          reduce using rule 262 (simple_stmt -> delay_stmt .)
    STRLITERAL      reduce using rule 262 (simple_stmt -> delay_stmt .)
    WHILE           reduce using rule 262 (simple_stmt -> delay_stmt .)
    DECLARE         reduce using rule 262 (simple_stmt -> delay_stmt .)
    FOR             reduce using rule 262 (simple_stmt -> delay_stmt .)
    LOOP            reduce using rule 262 (simple_stmt -> delay_stmt .)
    BEGIN           reduce using rule 262 (simple_stmt -> delay_stmt .)
    EXCEPTION       reduce using rule 262 (simple_stmt -> delay_stmt .)
    OR              reduce using rule 262 (simple_stmt -> delay_stmt .)
    ELSE            reduce using rule 262 (simple_stmt -> delay_stmt .)
    THEN            reduce using rule 262 (simple_stmt -> delay_stmt .)
    ELSIF           reduce using rule 262 (simple_stmt -> delay_stmt .)
    WHEN            reduce using rule 262 (simple_stmt -> delay_stmt .)


state 297

    (407) accept_stmt -> accept_hdr . ;
    (408) accept_stmt -> accept_hdr . DO handled_stmt_s END id_opt ;

    ;               shift and go to state 457
    DO              shift and go to state 456


state 298

    (255) unlabeled -> pragma .

    LEFTLABEL       reduce using rule 255 (unlabeled -> pragma .)
    error           reduce using rule 255 (unlabeled -> pragma .)
    PRAGMA          reduce using rule 255 (unlabeled -> pragma .)
    NuLL            reduce using rule 255 (unlabeled -> pragma .)
    EXIT            reduce using rule 255 (unlabeled -> pragma .)
    RETURN          reduce using rule 255 (unlabeled -> pragma .)
    GOTO            reduce using rule 255 (unlabeled -> pragma .)
    DELAY           reduce using rule 255 (unlabeled -> pragma .)
    ABORT           reduce using rule 255 (unlabeled -> pragma .)
    RAISE           reduce using rule 255 (unlabeled -> pragma .)
    REQUEUE         reduce using rule 255 (unlabeled -> pragma .)
    IF              reduce using rule 255 (unlabeled -> pragma .)
    CASE            reduce using rule 255 (unlabeled -> pragma .)
    ID              reduce using rule 255 (unlabeled -> pragma .)
    ACCEPT          reduce using rule 255 (unlabeled -> pragma .)
    SELECT          reduce using rule 255 (unlabeled -> pragma .)
    STRLITERAL      reduce using rule 255 (unlabeled -> pragma .)
    WHILE           reduce using rule 255 (unlabeled -> pragma .)
    DECLARE         reduce using rule 255 (unlabeled -> pragma .)
    FOR             reduce using rule 255 (unlabeled -> pragma .)
    LOOP            reduce using rule 255 (unlabeled -> pragma .)
    BEGIN           reduce using rule 255 (unlabeled -> pragma .)
    WHEN            reduce using rule 255 (unlabeled -> pragma .)
    END             reduce using rule 255 (unlabeled -> pragma .)
    OR              reduce using rule 255 (unlabeled -> pragma .)
    ELSE            reduce using rule 255 (unlabeled -> pragma .)
    EXCEPTION       reduce using rule 255 (unlabeled -> pragma .)
    THEN            reduce using rule 255 (unlabeled -> pragma .)
    ELSIF           reduce using rule 255 (unlabeled -> pragma .)


state 299

    (266) simple_stmt -> requeue_stmt .

    END             reduce using rule 266 (simple_stmt -> requeue_stmt .)
    LEFTLABEL       reduce using rule 266 (simple_stmt -> requeue_stmt .)
    error           reduce using rule 266 (simple_stmt -> requeue_stmt .)
    PRAGMA          reduce using rule 266 (simple_stmt -> requeue_stmt .)
    NuLL            reduce using rule 266 (simple_stmt -> requeue_stmt .)
    EXIT            reduce using rule 266 (simple_stmt -> requeue_stmt .)
    RETURN          reduce using rule 266 (simple_stmt -> requeue_stmt .)
    GOTO            reduce using rule 266 (simple_stmt -> requeue_stmt .)
    DELAY           reduce using rule 266 (simple_stmt -> requeue_stmt .)
    ABORT           reduce using rule 266 (simple_stmt -> requeue_stmt .)
    RAISE           reduce using rule 266 (simple_stmt -> requeue_stmt .)
    REQUEUE         reduce using rule 266 (simple_stmt -> requeue_stmt .)
    IF              reduce using rule 266 (simple_stmt -> requeue_stmt .)
    CASE            reduce using rule 266 (simple_stmt -> requeue_stmt .)
    ID              reduce using rule 266 (simple_stmt -> requeue_stmt .)
    ACCEPT          reduce using rule 266 (simple_stmt -> requeue_stmt .)
    SELECT          reduce using rule 266 (simple_stmt -> requeue_stmt .)
    STRLITERAL      reduce using rule 266 (simple_stmt -> requeue_stmt .)
    WHILE           reduce using rule 266 (simple_stmt -> requeue_stmt .)
    DECLARE         reduce using rule 266 (simple_stmt -> requeue_stmt .)
    FOR             reduce using rule 266 (simple_stmt -> requeue_stmt .)
    LOOP            reduce using rule 266 (simple_stmt -> requeue_stmt .)
    BEGIN           reduce using rule 266 (simple_stmt -> requeue_stmt .)
    EXCEPTION       reduce using rule 266 (simple_stmt -> requeue_stmt .)
    OR              reduce using rule 266 (simple_stmt -> requeue_stmt .)
    ELSE            reduce using rule 266 (simple_stmt -> requeue_stmt .)
    THEN            reduce using rule 266 (simple_stmt -> requeue_stmt .)
    ELSIF           reduce using rule 266 (simple_stmt -> requeue_stmt .)
    WHEN            reduce using rule 266 (simple_stmt -> requeue_stmt .)


state 300

    (264) simple_stmt -> raise_stmt .

    END             reduce using rule 264 (simple_stmt -> raise_stmt .)
    LEFTLABEL       reduce using rule 264 (simple_stmt -> raise_stmt .)
    error           reduce using rule 264 (simple_stmt -> raise_stmt .)
    PRAGMA          reduce using rule 264 (simple_stmt -> raise_stmt .)
    NuLL            reduce using rule 264 (simple_stmt -> raise_stmt .)
    EXIT            reduce using rule 264 (simple_stmt -> raise_stmt .)
    RETURN          reduce using rule 264 (simple_stmt -> raise_stmt .)
    GOTO            reduce using rule 264 (simple_stmt -> raise_stmt .)
    DELAY           reduce using rule 264 (simple_stmt -> raise_stmt .)
    ABORT           reduce using rule 264 (simple_stmt -> raise_stmt .)
    RAISE           reduce using rule 264 (simple_stmt -> raise_stmt .)
    REQUEUE         reduce using rule 264 (simple_stmt -> raise_stmt .)
    IF              reduce using rule 264 (simple_stmt -> raise_stmt .)
    CASE            reduce using rule 264 (simple_stmt -> raise_stmt .)
    ID              reduce using rule 264 (simple_stmt -> raise_stmt .)
    ACCEPT          reduce using rule 264 (simple_stmt -> raise_stmt .)
    SELECT          reduce using rule 264 (simple_stmt -> raise_stmt .)
    STRLITERAL      reduce using rule 264 (simple_stmt -> raise_stmt .)
    WHILE           reduce using rule 264 (simple_stmt -> raise_stmt .)
    DECLARE         reduce using rule 264 (simple_stmt -> raise_stmt .)
    FOR             reduce using rule 264 (simple_stmt -> raise_stmt .)
    LOOP            reduce using rule 264 (simple_stmt -> raise_stmt .)
    BEGIN           reduce using rule 264 (simple_stmt -> raise_stmt .)
    EXCEPTION       reduce using rule 264 (simple_stmt -> raise_stmt .)
    OR              reduce using rule 264 (simple_stmt -> raise_stmt .)
    ELSE            reduce using rule 264 (simple_stmt -> raise_stmt .)
    THEN            reduce using rule 264 (simple_stmt -> raise_stmt .)
    ELSIF           reduce using rule 264 (simple_stmt -> raise_stmt .)
    WHEN            reduce using rule 264 (simple_stmt -> raise_stmt .)


state 301

    (416) select_stmt -> timed_entry_call .

    LEFTLABEL       reduce using rule 416 (select_stmt -> timed_entry_call .)
    error           reduce using rule 416 (select_stmt -> timed_entry_call .)
    PRAGMA          reduce using rule 416 (select_stmt -> timed_entry_call .)
    NuLL            reduce using rule 416 (select_stmt -> timed_entry_call .)
    EXIT            reduce using rule 416 (select_stmt -> timed_entry_call .)
    RETURN          reduce using rule 416 (select_stmt -> timed_entry_call .)
    GOTO            reduce using rule 416 (select_stmt -> timed_entry_call .)
    DELAY           reduce using rule 416 (select_stmt -> timed_entry_call .)
    ABORT           reduce using rule 416 (select_stmt -> timed_entry_call .)
    RAISE           reduce using rule 416 (select_stmt -> timed_entry_call .)
    REQUEUE         reduce using rule 416 (select_stmt -> timed_entry_call .)
    IF              reduce using rule 416 (select_stmt -> timed_entry_call .)
    CASE            reduce using rule 416 (select_stmt -> timed_entry_call .)
    ID              reduce using rule 416 (select_stmt -> timed_entry_call .)
    ACCEPT          reduce using rule 416 (select_stmt -> timed_entry_call .)
    SELECT          reduce using rule 416 (select_stmt -> timed_entry_call .)
    STRLITERAL      reduce using rule 416 (select_stmt -> timed_entry_call .)
    WHILE           reduce using rule 416 (select_stmt -> timed_entry_call .)
    DECLARE         reduce using rule 416 (select_stmt -> timed_entry_call .)
    FOR             reduce using rule 416 (select_stmt -> timed_entry_call .)
    LOOP            reduce using rule 416 (select_stmt -> timed_entry_call .)
    BEGIN           reduce using rule 416 (select_stmt -> timed_entry_call .)
    END             reduce using rule 416 (select_stmt -> timed_entry_call .)
    WHEN            reduce using rule 416 (select_stmt -> timed_entry_call .)
    EXCEPTION       reduce using rule 416 (select_stmt -> timed_entry_call .)
    OR              reduce using rule 416 (select_stmt -> timed_entry_call .)
    ELSE            reduce using rule 416 (select_stmt -> timed_entry_call .)
    THEN            reduce using rule 416 (select_stmt -> timed_entry_call .)
    ELSIF           reduce using rule 416 (select_stmt -> timed_entry_call .)


state 302

    (309) exit_stmt -> EXIT . name_opt when_opt ;
    (310) name_opt -> .
    (311) name_opt -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    WHEN            reduce using rule 310 (name_opt -> .)
    ;               reduce using rule 310 (name_opt -> .)
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 452
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    name_opt                       shift and go to state 458
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 303

    (267) simple_stmt -> error . ;

    ;               shift and go to state 459


state 304

    (263) simple_stmt -> abort_stmt .

    END             reduce using rule 263 (simple_stmt -> abort_stmt .)
    LEFTLABEL       reduce using rule 263 (simple_stmt -> abort_stmt .)
    error           reduce using rule 263 (simple_stmt -> abort_stmt .)
    PRAGMA          reduce using rule 263 (simple_stmt -> abort_stmt .)
    NuLL            reduce using rule 263 (simple_stmt -> abort_stmt .)
    EXIT            reduce using rule 263 (simple_stmt -> abort_stmt .)
    RETURN          reduce using rule 263 (simple_stmt -> abort_stmt .)
    GOTO            reduce using rule 263 (simple_stmt -> abort_stmt .)
    DELAY           reduce using rule 263 (simple_stmt -> abort_stmt .)
    ABORT           reduce using rule 263 (simple_stmt -> abort_stmt .)
    RAISE           reduce using rule 263 (simple_stmt -> abort_stmt .)
    REQUEUE         reduce using rule 263 (simple_stmt -> abort_stmt .)
    IF              reduce using rule 263 (simple_stmt -> abort_stmt .)
    CASE            reduce using rule 263 (simple_stmt -> abort_stmt .)
    ID              reduce using rule 263 (simple_stmt -> abort_stmt .)
    ACCEPT          reduce using rule 263 (simple_stmt -> abort_stmt .)
    SELECT          reduce using rule 263 (simple_stmt -> abort_stmt .)
    STRLITERAL      reduce using rule 263 (simple_stmt -> abort_stmt .)
    WHILE           reduce using rule 263 (simple_stmt -> abort_stmt .)
    DECLARE         reduce using rule 263 (simple_stmt -> abort_stmt .)
    FOR             reduce using rule 263 (simple_stmt -> abort_stmt .)
    LOOP            reduce using rule 263 (simple_stmt -> abort_stmt .)
    BEGIN           reduce using rule 263 (simple_stmt -> abort_stmt .)
    EXCEPTION       reduce using rule 263 (simple_stmt -> abort_stmt .)
    OR              reduce using rule 263 (simple_stmt -> abort_stmt .)
    ELSE            reduce using rule 263 (simple_stmt -> abort_stmt .)
    THEN            reduce using rule 263 (simple_stmt -> abort_stmt .)
    ELSIF           reduce using rule 263 (simple_stmt -> abort_stmt .)
    WHEN            reduce using rule 263 (simple_stmt -> abort_stmt .)


state 305

    (306) handled_stmt_s -> statement_s . except_handler_part_opt
    (250) statement_s -> statement_s . m statement
    (307) except_handler_part_opt -> .
    (308) except_handler_part_opt -> . except_handler_part
    (519) m -> .
    (464) except_handler_part -> . EXCEPTION exception_handler
    (465) except_handler_part -> . except_handler_part exception_handler

    END             reduce using rule 307 (except_handler_part_opt -> .)
    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)
    EXCEPTION       shift and go to state 460

    m                              shift and go to state 461
    except_handler_part            shift and go to state 462
    except_handler_part_opt        shift and go to state 463

state 306

    (265) simple_stmt -> code_stmt .

    END             reduce using rule 265 (simple_stmt -> code_stmt .)
    LEFTLABEL       reduce using rule 265 (simple_stmt -> code_stmt .)
    error           reduce using rule 265 (simple_stmt -> code_stmt .)
    PRAGMA          reduce using rule 265 (simple_stmt -> code_stmt .)
    NuLL            reduce using rule 265 (simple_stmt -> code_stmt .)
    EXIT            reduce using rule 265 (simple_stmt -> code_stmt .)
    RETURN          reduce using rule 265 (simple_stmt -> code_stmt .)
    GOTO            reduce using rule 265 (simple_stmt -> code_stmt .)
    DELAY           reduce using rule 265 (simple_stmt -> code_stmt .)
    ABORT           reduce using rule 265 (simple_stmt -> code_stmt .)
    RAISE           reduce using rule 265 (simple_stmt -> code_stmt .)
    REQUEUE         reduce using rule 265 (simple_stmt -> code_stmt .)
    IF              reduce using rule 265 (simple_stmt -> code_stmt .)
    CASE            reduce using rule 265 (simple_stmt -> code_stmt .)
    ID              reduce using rule 265 (simple_stmt -> code_stmt .)
    ACCEPT          reduce using rule 265 (simple_stmt -> code_stmt .)
    SELECT          reduce using rule 265 (simple_stmt -> code_stmt .)
    STRLITERAL      reduce using rule 265 (simple_stmt -> code_stmt .)
    WHILE           reduce using rule 265 (simple_stmt -> code_stmt .)
    DECLARE         reduce using rule 265 (simple_stmt -> code_stmt .)
    FOR             reduce using rule 265 (simple_stmt -> code_stmt .)
    LOOP            reduce using rule 265 (simple_stmt -> code_stmt .)
    BEGIN           reduce using rule 265 (simple_stmt -> code_stmt .)
    EXCEPTION       reduce using rule 265 (simple_stmt -> code_stmt .)
    OR              reduce using rule 265 (simple_stmt -> code_stmt .)
    ELSE            reduce using rule 265 (simple_stmt -> code_stmt .)
    THEN            reduce using rule 265 (simple_stmt -> code_stmt .)
    ELSIF           reduce using rule 265 (simple_stmt -> code_stmt .)
    WHEN            reduce using rule 265 (simple_stmt -> code_stmt .)


state 307

    (274) label -> LEFTLABEL . ID RIGHTLABEL

    ID              shift and go to state 464


state 308

    (251) statement -> unlabeled .

    LEFTLABEL       reduce using rule 251 (statement -> unlabeled .)
    error           reduce using rule 251 (statement -> unlabeled .)
    PRAGMA          reduce using rule 251 (statement -> unlabeled .)
    NuLL            reduce using rule 251 (statement -> unlabeled .)
    EXIT            reduce using rule 251 (statement -> unlabeled .)
    RETURN          reduce using rule 251 (statement -> unlabeled .)
    GOTO            reduce using rule 251 (statement -> unlabeled .)
    DELAY           reduce using rule 251 (statement -> unlabeled .)
    ABORT           reduce using rule 251 (statement -> unlabeled .)
    RAISE           reduce using rule 251 (statement -> unlabeled .)
    REQUEUE         reduce using rule 251 (statement -> unlabeled .)
    IF              reduce using rule 251 (statement -> unlabeled .)
    CASE            reduce using rule 251 (statement -> unlabeled .)
    ID              reduce using rule 251 (statement -> unlabeled .)
    ACCEPT          reduce using rule 251 (statement -> unlabeled .)
    SELECT          reduce using rule 251 (statement -> unlabeled .)
    STRLITERAL      reduce using rule 251 (statement -> unlabeled .)
    WHILE           reduce using rule 251 (statement -> unlabeled .)
    DECLARE         reduce using rule 251 (statement -> unlabeled .)
    FOR             reduce using rule 251 (statement -> unlabeled .)
    LOOP            reduce using rule 251 (statement -> unlabeled .)
    BEGIN           reduce using rule 251 (statement -> unlabeled .)
    OR              reduce using rule 251 (statement -> unlabeled .)
    ELSE            reduce using rule 251 (statement -> unlabeled .)
    THEN            reduce using rule 251 (statement -> unlabeled .)
    END             reduce using rule 251 (statement -> unlabeled .)
    WHEN            reduce using rule 251 (statement -> unlabeled .)
    EXCEPTION       reduce using rule 251 (statement -> unlabeled .)
    ELSIF           reduce using rule 251 (statement -> unlabeled .)


state 309

    (258) simple_stmt -> exit_stmt .

    END             reduce using rule 258 (simple_stmt -> exit_stmt .)
    LEFTLABEL       reduce using rule 258 (simple_stmt -> exit_stmt .)
    error           reduce using rule 258 (simple_stmt -> exit_stmt .)
    PRAGMA          reduce using rule 258 (simple_stmt -> exit_stmt .)
    NuLL            reduce using rule 258 (simple_stmt -> exit_stmt .)
    EXIT            reduce using rule 258 (simple_stmt -> exit_stmt .)
    RETURN          reduce using rule 258 (simple_stmt -> exit_stmt .)
    GOTO            reduce using rule 258 (simple_stmt -> exit_stmt .)
    DELAY           reduce using rule 258 (simple_stmt -> exit_stmt .)
    ABORT           reduce using rule 258 (simple_stmt -> exit_stmt .)
    RAISE           reduce using rule 258 (simple_stmt -> exit_stmt .)
    REQUEUE         reduce using rule 258 (simple_stmt -> exit_stmt .)
    IF              reduce using rule 258 (simple_stmt -> exit_stmt .)
    CASE            reduce using rule 258 (simple_stmt -> exit_stmt .)
    ID              reduce using rule 258 (simple_stmt -> exit_stmt .)
    ACCEPT          reduce using rule 258 (simple_stmt -> exit_stmt .)
    SELECT          reduce using rule 258 (simple_stmt -> exit_stmt .)
    STRLITERAL      reduce using rule 258 (simple_stmt -> exit_stmt .)
    WHILE           reduce using rule 258 (simple_stmt -> exit_stmt .)
    DECLARE         reduce using rule 258 (simple_stmt -> exit_stmt .)
    FOR             reduce using rule 258 (simple_stmt -> exit_stmt .)
    LOOP            reduce using rule 258 (simple_stmt -> exit_stmt .)
    BEGIN           reduce using rule 258 (simple_stmt -> exit_stmt .)
    EXCEPTION       reduce using rule 258 (simple_stmt -> exit_stmt .)
    OR              reduce using rule 258 (simple_stmt -> exit_stmt .)
    ELSE            reduce using rule 258 (simple_stmt -> exit_stmt .)
    THEN            reduce using rule 258 (simple_stmt -> exit_stmt .)
    ELSIF           reduce using rule 258 (simple_stmt -> exit_stmt .)
    WHEN            reduce using rule 258 (simple_stmt -> exit_stmt .)


state 310

    (414) select_stmt -> select_wait .

    LEFTLABEL       reduce using rule 414 (select_stmt -> select_wait .)
    error           reduce using rule 414 (select_stmt -> select_wait .)
    PRAGMA          reduce using rule 414 (select_stmt -> select_wait .)
    NuLL            reduce using rule 414 (select_stmt -> select_wait .)
    EXIT            reduce using rule 414 (select_stmt -> select_wait .)
    RETURN          reduce using rule 414 (select_stmt -> select_wait .)
    GOTO            reduce using rule 414 (select_stmt -> select_wait .)
    DELAY           reduce using rule 414 (select_stmt -> select_wait .)
    ABORT           reduce using rule 414 (select_stmt -> select_wait .)
    RAISE           reduce using rule 414 (select_stmt -> select_wait .)
    REQUEUE         reduce using rule 414 (select_stmt -> select_wait .)
    IF              reduce using rule 414 (select_stmt -> select_wait .)
    CASE            reduce using rule 414 (select_stmt -> select_wait .)
    ID              reduce using rule 414 (select_stmt -> select_wait .)
    ACCEPT          reduce using rule 414 (select_stmt -> select_wait .)
    SELECT          reduce using rule 414 (select_stmt -> select_wait .)
    STRLITERAL      reduce using rule 414 (select_stmt -> select_wait .)
    WHILE           reduce using rule 414 (select_stmt -> select_wait .)
    DECLARE         reduce using rule 414 (select_stmt -> select_wait .)
    FOR             reduce using rule 414 (select_stmt -> select_wait .)
    LOOP            reduce using rule 414 (select_stmt -> select_wait .)
    BEGIN           reduce using rule 414 (select_stmt -> select_wait .)
    END             reduce using rule 414 (select_stmt -> select_wait .)
    WHEN            reduce using rule 414 (select_stmt -> select_wait .)
    EXCEPTION       reduce using rule 414 (select_stmt -> select_wait .)
    OR              reduce using rule 414 (select_stmt -> select_wait .)
    ELSE            reduce using rule 414 (select_stmt -> select_wait .)
    THEN            reduce using rule 414 (select_stmt -> select_wait .)
    ELSIF           reduce using rule 414 (select_stmt -> select_wait .)


state 311

    (292) label_opt -> ID . :
    (163) simple_name -> ID .

    :               shift and go to state 465
    ASSIGNMENT      reduce using rule 163 (simple_name -> ID .)
    ;               reduce using rule 163 (simple_name -> ID .)
    SINGLEQUOTE     reduce using rule 163 (simple_name -> ID .)
    (               reduce using rule 163 (simple_name -> ID .)
    .               reduce using rule 163 (simple_name -> ID .)


state 312

    (277) if_stmt -> IF . cond_clause_s else_opt END IF ;
    (278) cond_clause_s -> . cond_clause
    (279) cond_clause_s -> . cond_clause ELSIF m cond_clause_s
    (280) cond_clause -> . cond_part m statement_s n
    (281) cond_part -> . condition THEN
    (282) condition -> . expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    cond_clause_s                  shift and go to state 466
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    simple_name                    shift and go to state 160
    indexed_comp                   shift and go to state 130
    cond_clause                    shift and go to state 467
    cond_part                      shift and go to state 468
    literal                        shift and go to state 137
    allocator                      shift and go to state 131
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    condition                      shift and go to state 469
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 470

state 313

    (417) select_stmt -> cond_entry_call .

    LEFTLABEL       reduce using rule 417 (select_stmt -> cond_entry_call .)
    error           reduce using rule 417 (select_stmt -> cond_entry_call .)
    PRAGMA          reduce using rule 417 (select_stmt -> cond_entry_call .)
    NuLL            reduce using rule 417 (select_stmt -> cond_entry_call .)
    EXIT            reduce using rule 417 (select_stmt -> cond_entry_call .)
    RETURN          reduce using rule 417 (select_stmt -> cond_entry_call .)
    GOTO            reduce using rule 417 (select_stmt -> cond_entry_call .)
    DELAY           reduce using rule 417 (select_stmt -> cond_entry_call .)
    ABORT           reduce using rule 417 (select_stmt -> cond_entry_call .)
    RAISE           reduce using rule 417 (select_stmt -> cond_entry_call .)
    REQUEUE         reduce using rule 417 (select_stmt -> cond_entry_call .)
    IF              reduce using rule 417 (select_stmt -> cond_entry_call .)
    CASE            reduce using rule 417 (select_stmt -> cond_entry_call .)
    ID              reduce using rule 417 (select_stmt -> cond_entry_call .)
    ACCEPT          reduce using rule 417 (select_stmt -> cond_entry_call .)
    SELECT          reduce using rule 417 (select_stmt -> cond_entry_call .)
    STRLITERAL      reduce using rule 417 (select_stmt -> cond_entry_call .)
    WHILE           reduce using rule 417 (select_stmt -> cond_entry_call .)
    DECLARE         reduce using rule 417 (select_stmt -> cond_entry_call .)
    FOR             reduce using rule 417 (select_stmt -> cond_entry_call .)
    LOOP            reduce using rule 417 (select_stmt -> cond_entry_call .)
    BEGIN           reduce using rule 417 (select_stmt -> cond_entry_call .)
    END             reduce using rule 417 (select_stmt -> cond_entry_call .)
    WHEN            reduce using rule 417 (select_stmt -> cond_entry_call .)
    EXCEPTION       reduce using rule 417 (select_stmt -> cond_entry_call .)
    OR              reduce using rule 417 (select_stmt -> cond_entry_call .)
    ELSE            reduce using rule 417 (select_stmt -> cond_entry_call .)
    THEN            reduce using rule 417 (select_stmt -> cond_entry_call .)
    ELSIF           reduce using rule 417 (select_stmt -> cond_entry_call .)


state 314

    (256) simple_stmt -> null_stmt .

    END             reduce using rule 256 (simple_stmt -> null_stmt .)
    LEFTLABEL       reduce using rule 256 (simple_stmt -> null_stmt .)
    error           reduce using rule 256 (simple_stmt -> null_stmt .)
    PRAGMA          reduce using rule 256 (simple_stmt -> null_stmt .)
    NuLL            reduce using rule 256 (simple_stmt -> null_stmt .)
    EXIT            reduce using rule 256 (simple_stmt -> null_stmt .)
    RETURN          reduce using rule 256 (simple_stmt -> null_stmt .)
    GOTO            reduce using rule 256 (simple_stmt -> null_stmt .)
    DELAY           reduce using rule 256 (simple_stmt -> null_stmt .)
    ABORT           reduce using rule 256 (simple_stmt -> null_stmt .)
    RAISE           reduce using rule 256 (simple_stmt -> null_stmt .)
    REQUEUE         reduce using rule 256 (simple_stmt -> null_stmt .)
    IF              reduce using rule 256 (simple_stmt -> null_stmt .)
    CASE            reduce using rule 256 (simple_stmt -> null_stmt .)
    ID              reduce using rule 256 (simple_stmt -> null_stmt .)
    ACCEPT          reduce using rule 256 (simple_stmt -> null_stmt .)
    SELECT          reduce using rule 256 (simple_stmt -> null_stmt .)
    STRLITERAL      reduce using rule 256 (simple_stmt -> null_stmt .)
    WHILE           reduce using rule 256 (simple_stmt -> null_stmt .)
    DECLARE         reduce using rule 256 (simple_stmt -> null_stmt .)
    FOR             reduce using rule 256 (simple_stmt -> null_stmt .)
    LOOP            reduce using rule 256 (simple_stmt -> null_stmt .)
    BEGIN           reduce using rule 256 (simple_stmt -> null_stmt .)
    EXCEPTION       reduce using rule 256 (simple_stmt -> null_stmt .)
    OR              reduce using rule 256 (simple_stmt -> null_stmt .)
    ELSE            reduce using rule 256 (simple_stmt -> null_stmt .)
    THEN            reduce using rule 256 (simple_stmt -> null_stmt .)
    ELSIF           reduce using rule 256 (simple_stmt -> null_stmt .)
    WHEN            reduce using rule 256 (simple_stmt -> null_stmt .)


state 315

    (257) simple_stmt -> assign_stmt .

    END             reduce using rule 257 (simple_stmt -> assign_stmt .)
    LEFTLABEL       reduce using rule 257 (simple_stmt -> assign_stmt .)
    error           reduce using rule 257 (simple_stmt -> assign_stmt .)
    PRAGMA          reduce using rule 257 (simple_stmt -> assign_stmt .)
    NuLL            reduce using rule 257 (simple_stmt -> assign_stmt .)
    EXIT            reduce using rule 257 (simple_stmt -> assign_stmt .)
    RETURN          reduce using rule 257 (simple_stmt -> assign_stmt .)
    GOTO            reduce using rule 257 (simple_stmt -> assign_stmt .)
    DELAY           reduce using rule 257 (simple_stmt -> assign_stmt .)
    ABORT           reduce using rule 257 (simple_stmt -> assign_stmt .)
    RAISE           reduce using rule 257 (simple_stmt -> assign_stmt .)
    REQUEUE         reduce using rule 257 (simple_stmt -> assign_stmt .)
    IF              reduce using rule 257 (simple_stmt -> assign_stmt .)
    CASE            reduce using rule 257 (simple_stmt -> assign_stmt .)
    ID              reduce using rule 257 (simple_stmt -> assign_stmt .)
    ACCEPT          reduce using rule 257 (simple_stmt -> assign_stmt .)
    SELECT          reduce using rule 257 (simple_stmt -> assign_stmt .)
    STRLITERAL      reduce using rule 257 (simple_stmt -> assign_stmt .)
    WHILE           reduce using rule 257 (simple_stmt -> assign_stmt .)
    DECLARE         reduce using rule 257 (simple_stmt -> assign_stmt .)
    FOR             reduce using rule 257 (simple_stmt -> assign_stmt .)
    LOOP            reduce using rule 257 (simple_stmt -> assign_stmt .)
    BEGIN           reduce using rule 257 (simple_stmt -> assign_stmt .)
    EXCEPTION       reduce using rule 257 (simple_stmt -> assign_stmt .)
    OR              reduce using rule 257 (simple_stmt -> assign_stmt .)
    ELSE            reduce using rule 257 (simple_stmt -> assign_stmt .)
    THEN            reduce using rule 257 (simple_stmt -> assign_stmt .)
    ELSIF           reduce using rule 257 (simple_stmt -> assign_stmt .)
    WHEN            reduce using rule 257 (simple_stmt -> assign_stmt .)


state 316

    (338) subprog_body -> subprog_spec_is_push decl_part block_body END . id_opt ;
    (300) id_opt -> .
    (301) id_opt -> . designator
    (323) designator -> . compound_name
    (324) designator -> . STRLITERAL
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ;               reduce using rule 300 (id_opt -> .)
    STRLITERAL      shift and go to state 114
    ID              shift and go to state 41

    designator                     shift and go to state 471
    id_opt                         shift and go to state 472
    compound_name                  shift and go to state 116
    simple_name                    shift and go to state 42

state 317

    (511) attrib_def -> FOR mark USE . expression ;
    (512) record_type_spec -> FOR mark USE . RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> FOR mark USE . AT expression ;
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    RECORD          shift and go to state 473
    AT              shift and go to state 474
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 475

state 318

    (161) mark -> mark SINGLEQUOTE . attribute_id
    (182) attribute_id -> . ID
    (183) attribute_id -> . DIGITS
    (184) attribute_id -> . DELTA
    (185) attribute_id -> . ACCESS

    ID              shift and go to state 402
    DIGITS          shift and go to state 397
    DELTA           shift and go to state 400
    ACCESS          shift and go to state 398

    attribute_id                   shift and go to state 476

state 319

    (162) mark -> mark . . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 477

state 320

    (373) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt ;
    (459) body_stub -> TASK BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 478


state 321

    (368) task_spec -> TASK TYPE simple_name . discrim_part_opt task_def
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( BOX )
    (112) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    ;               reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 325

    discrim_part_opt               shift and go to state 479
    discrim_part                   shift and go to state 327

state 322

    (370) task_def -> IS . entry_decl_s rep_spec_s task_private_opt END id_opt
    (396) entry_decl_s -> . pragma_s
    (397) entry_decl_s -> . entry_decl_s entry_decl pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    entry_decl_s                   shift and go to state 480
    pragma_s                       shift and go to state 481

state 323

    (367) task_spec -> TASK simple_name task_def .

    ;               reduce using rule 367 (task_spec -> TASK simple_name task_def .)


state 324

    (347) pkg_start -> PACKAGE BODY compound_name . IS
    (460) body_stub -> PACKAGE BODY compound_name . IS SEPARATE ;
    (165) compound_name -> compound_name . . simple_name

    IS              shift and go to state 482
    .               shift and go to state 120


state 325

    (39) discrim_part_opt -> ( . BOX )
    (112) discrim_part -> ( . discrim_spec_s )
    (113) discrim_spec_s -> . discrim_spec
    (114) discrim_spec_s -> . discrim_spec_s ; discrim_spec
    (115) discrim_spec -> . def_id_s : access_opt mark init_opt
    (116) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . ID

    BOX             shift and go to state 483
    error           shift and go to state 484
    ID              shift and go to state 91

    discrim_spec                   shift and go to state 487
    discrim_spec_s                 shift and go to state 485
    def_id                         shift and go to state 88
    def_id_s                       shift and go to state 486

state 326

    (36) type_decl -> TYPE ID discrim_part_opt . type_completion ;
    (40) type_completion -> .
    (41) type_completion -> . IS type_def

    ;               reduce using rule 40 (type_completion -> .)
    IS              shift and go to state 488

    type_completion                shift and go to state 489

state 327

    (38) discrim_part_opt -> discrim_part .

    IS              reduce using rule 38 (discrim_part_opt -> discrim_part .)
    ;               reduce using rule 38 (discrim_part_opt -> discrim_part .)


state 328

    (50) subtype_decl -> SUBTYPE ID IS . subtype_ind ;
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 490
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    subtype_ind                    shift and go to state 491
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 329

    (461) body_stub -> subprog_spec IS SEPARATE . ;

    ;               shift and go to state 492


state 330

    (25) def_id_s -> def_id_s , def_id .

    :               reduce using rule 25 (def_id_s -> def_id_s , def_id .)
    ,               reduce using rule 25 (def_id_s -> def_id_s , def_id .)


state 331

    (463) exception_decl -> def_id_s : EXCEPTION . ;
    (359) rename_decl -> def_id_s : EXCEPTION . renames ;
    (365) renames -> . RENAMES name

    ;               shift and go to state 494
    RENAMES         shift and go to state 95

    renames                        shift and go to state 493

state 332

    (35) number_decl -> def_id_s : CONSTANT . ASSIGNMENT expression ;
    (29) object_qualifier_opt -> CONSTANT .

    ASSIGNMENT      shift and go to state 495
    ARRAY           reduce using rule 29 (object_qualifier_opt -> CONSTANT .)
    ID              reduce using rule 29 (object_qualifier_opt -> CONSTANT .)
    STRLITERAL      reduce using rule 29 (object_qualifier_opt -> CONSTANT .)


state 333

    (28) object_qualifier_opt -> ALIASED .
    (30) object_qualifier_opt -> ALIASED . CONSTANT

    ARRAY           reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    ID              reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    STRLITERAL      reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    CONSTANT        shift and go to state 496


state 334

    (23) object_decl -> def_id_s : object_qualifier_opt . object_subtype_def init_opt ;
    (358) rename_decl -> def_id_s : object_qualifier_opt . subtype_ind renames ;
    (31) object_subtype_def -> . subtype_ind
    (32) object_subtype_def -> . array_type
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (80) array_type -> . unconstr_array_type
    (81) array_type -> . constr_array_type
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (82) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (83) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ARRAY           shift and go to state 498
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160
    array_type                     shift and go to state 497
    name                           shift and go to state 490
    object_subtype_def             shift and go to state 499
    constr_array_type              shift and go to state 500
    operator_symbol                shift and go to state 139
    subtype_ind                    shift and go to state 501
    unconstr_array_type            shift and go to state 502

state 335

    (507) generic_inst -> NEW name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    ;               reduce using rule 507 (generic_inst -> NEW name .)
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 336

    (347) pkg_start -> PACKAGE BODY compound_name IS .

    TASK            reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    PROTECTED       reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    error           reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    USE             reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    PRAGMA          reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    PACKAGE         reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    TYPE            reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    SUBTYPE         reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    FOR             reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    PROCEDURE       reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    FUNCTION        reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    GENERIC         reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    ID              reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    BEGIN           reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    END             reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)


state 337

    (361) rename_unit -> PACKAGE compound_name renames ; .

    TASK            reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    PROTECTED       reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    error           reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    USE             reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    PRAGMA          reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    PACKAGE         reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    TYPE            reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    SUBTYPE         reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    FOR             reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    PROCEDURE       reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    FUNCTION        reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    GENERIC         reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    ID              reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    BEGIN           reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    END             reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    PRIVATE         reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    WITH            reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    SEPARATE        reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)
    $end            reduce using rule 361 (rename_unit -> PACKAGE compound_name renames ; .)


state 338

    (506) generic_pkg_inst -> PACKAGE compound_name IS generic_inst .

    ;               reduce using rule 506 (generic_pkg_inst -> PACKAGE compound_name IS generic_inst .)


state 339

    (140) decl_item_s -> decl_item_s1 .
    (142) decl_item_s1 -> decl_item_s1 . decl_item
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) subprog_spec_is_push -> . subprog_spec IS
    (26) def_id -> . ID

    END             reduce using rule 140 (decl_item_s -> decl_item_s1 .)
    PRIVATE         reduce using rule 140 (decl_item_s -> decl_item_s1 .)
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 343
    PACKAGE         shift and go to state 344
    PROTECTED       shift and go to state 340
    FOR             shift and go to state 64
    GENERIC         shift and go to state 21
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    ID              shift and go to state 91

    decl                           shift and go to state 51
    task_decl                      shift and go to state 61
    subtype_decl                   shift and go to state 62
    rep_spec                       shift and go to state 82
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    decl_item                      shift and go to state 503
    subprog_spec_is_push           shift and go to state 345
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 346
    def_id_s                       shift and go to state 87
    task_spec                      shift and go to state 66
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 88
    rename_decl                    shift and go to state 89
    type_decl                      shift and go to state 57
    rename_unit                    shift and go to state 90
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    generic_formal_part            shift and go to state 34
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    subprog_decl                   shift and go to state 59
    pragma                         shift and go to state 75
    pkg_spec                       shift and go to state 38
    number_decl                    shift and go to state 93

state 340

    (462) body_stub -> PROTECTED . BODY simple_name IS SEPARATE ;
    (375) prot_spec -> PROTECTED . ID prot_def
    (376) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def

    BODY            shift and go to state 504
    ID              shift and go to state 164
    TYPE            shift and go to state 163


state 341

    (141) decl_item_s1 -> decl_item .

    error           reduce using rule 141 (decl_item_s1 -> decl_item .)
    USE             reduce using rule 141 (decl_item_s1 -> decl_item .)
    PRAGMA          reduce using rule 141 (decl_item_s1 -> decl_item .)
    TYPE            reduce using rule 141 (decl_item_s1 -> decl_item .)
    SUBTYPE         reduce using rule 141 (decl_item_s1 -> decl_item .)
    TASK            reduce using rule 141 (decl_item_s1 -> decl_item .)
    PACKAGE         reduce using rule 141 (decl_item_s1 -> decl_item .)
    PROTECTED       reduce using rule 141 (decl_item_s1 -> decl_item .)
    FOR             reduce using rule 141 (decl_item_s1 -> decl_item .)
    GENERIC         reduce using rule 141 (decl_item_s1 -> decl_item .)
    PROCEDURE       reduce using rule 141 (decl_item_s1 -> decl_item .)
    FUNCTION        reduce using rule 141 (decl_item_s1 -> decl_item .)
    ID              reduce using rule 141 (decl_item_s1 -> decl_item .)
    PRIVATE         reduce using rule 141 (decl_item_s1 -> decl_item .)
    END             reduce using rule 141 (decl_item_s1 -> decl_item .)


state 342

    (342) pkg_spec -> PACKAGE compound_name IS decl_item_s . private_part END c_id_opt
    (343) private_part -> .
    (344) private_part -> . PRIVATE decl_item_s

    END             reduce using rule 343 (private_part -> .)
    PRIVATE         shift and go to state 505

    private_part                   shift and go to state 506

state 343

    (459) body_stub -> TASK . BODY simple_name IS SEPARATE ;
    (367) task_spec -> TASK . simple_name task_def
    (368) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
    (163) simple_name -> . ID

    BODY            shift and go to state 507
    TYPE            shift and go to state 171
    ID              shift and go to state 41

    simple_name                    shift and go to state 172

state 344

    (460) body_stub -> PACKAGE . BODY compound_name IS SEPARATE ;
    (342) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (361) rename_unit -> PACKAGE . compound_name renames ;
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    BODY            shift and go to state 508
    ID              shift and go to state 41

    simple_name                    shift and go to state 42
    compound_name                  shift and go to state 175

state 345

    (319) subprog_decl -> subprog_spec_is_push . ABSTRACT ;

    ABSTRACT        shift and go to state 81


state 346

    (461) body_stub -> subprog_spec . IS SEPARATE ;
    (317) subprog_decl -> subprog_spec . ;
    (362) rename_unit -> subprog_spec . renames ;
    (505) generic_subp_inst -> subprog_spec . IS generic_inst
    (337) subprog_spec_is_push -> subprog_spec . IS
    (365) renames -> . RENAMES name

    IS              shift and go to state 509
    ;               shift and go to state 97
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 347

    (328) param_s -> param .

    )               reduce using rule 328 (param_s -> param .)
    ;               reduce using rule 328 (param_s -> param .)


state 348

    (327) formal_part -> ( param_s . )
    (329) param_s -> param_s . ; param

    )               shift and go to state 510
    ;               shift and go to state 511


state 349

    (348) pkg_body -> pkg_start decl_part body_opt END . c_id_opt ;
    (345) c_id_opt -> .
    (346) c_id_opt -> . compound_name
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ;               reduce using rule 345 (c_id_opt -> .)
    ID              shift and go to state 41

    compound_name                  shift and go to state 513
    c_id_opt                       shift and go to state 512
    simple_name                    shift and go to state 42

state 350

    (482) generic_formal -> WITH FUNCTION designator . formal_part_opt RETURN name subp_default ;
    (325) formal_part_opt -> .
    (326) formal_part_opt -> . formal_part
    (327) formal_part -> . ( param_s )

    RETURN          reduce using rule 325 (formal_part_opt -> .)
    (               shift and go to state 192

    formal_part                    shift and go to state 191
    formal_part_opt                shift and go to state 514

state 351

    (483) generic_formal -> WITH PACKAGE simple_name . IS NEW name ( BOX ) ;
    (484) generic_formal -> WITH PACKAGE simple_name . IS NEW name ;

    IS              shift and go to state 515


state 352

    (481) generic_formal -> WITH PROCEDURE simple_name . formal_part_opt subp_default ;
    (325) formal_part_opt -> .
    (326) formal_part_opt -> . formal_part
    (327) formal_part -> . ( param_s )

    IS              reduce using rule 325 (formal_part_opt -> .)
    ;               reduce using rule 325 (formal_part_opt -> .)
    (               shift and go to state 192

    formal_part                    shift and go to state 191
    formal_part_opt                shift and go to state 516

state 353

    (364) rename_unit -> generic_formal_part subprog_spec renames ; .

    TASK            reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PROTECTED       reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    error           reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    USE             reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PRAGMA          reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PACKAGE         reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    TYPE            reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    SUBTYPE         reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    FOR             reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PROCEDURE       reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    FUNCTION        reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    GENERIC         reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    ID              reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    BEGIN           reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    END             reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PRIVATE         reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    WITH            reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    SEPARATE        reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    $end            reduce using rule 364 (rename_unit -> generic_formal_part subprog_spec renames ; .)


state 354

    (336) mode -> ACCESS .

    ID              reduce using rule 336 (mode -> ACCESS .)


state 355

    (334) mode -> OUT .

    ID              reduce using rule 334 (mode -> OUT .)


state 356

    (333) mode -> IN .
    (335) mode -> IN . OUT

    ID              reduce using rule 333 (mode -> IN .)
    OUT             shift and go to state 517


state 357

    (330) param -> def_id_s : mode . mark init_opt
    (160) mark -> . simple_name
    (161) mark -> . mark SINGLEQUOTE attribute_id
    (162) mark -> . mark . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    mark                           shift and go to state 518
    simple_name                    shift and go to state 168

state 358

    (363) rename_unit -> generic_formal_part PACKAGE compound_name renames . ;

    ;               shift and go to state 519


state 359

    (342) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
    (139) decl_item_s -> .
    (140) decl_item_s -> . decl_item_s1
    (141) decl_item_s1 -> . decl_item
    (142) decl_item_s1 -> . decl_item_s1 decl_item
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) subprog_spec_is_push -> . subprog_spec IS
    (26) def_id -> . ID

    PRIVATE         reduce using rule 139 (decl_item_s -> .)
    END             reduce using rule 139 (decl_item_s -> .)
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 343
    PACKAGE         shift and go to state 344
    PROTECTED       shift and go to state 340
    FOR             shift and go to state 64
    GENERIC         shift and go to state 21
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    ID              shift and go to state 91

    decl                           shift and go to state 51
    task_decl                      shift and go to state 61
    subtype_decl                   shift and go to state 62
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 339
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    subprog_spec_is_push           shift and go to state 345
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 346
    def_id_s                       shift and go to state 87
    decl_item                      shift and go to state 341
    task_spec                      shift and go to state 66
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 88
    rename_decl                    shift and go to state 89
    type_decl                      shift and go to state 57
    rename_unit                    shift and go to state 90
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    generic_formal_part            shift and go to state 34
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    subprog_decl                   shift and go to state 59
    decl_item_s                    shift and go to state 342
    pragma                         shift and go to state 75
    pkg_spec                       shift and go to state 38
    number_decl                    shift and go to state 93

state 360

    (480) generic_formal -> TYPE simple_name generic_discrim_part_opt . IS generic_type_def ;

    IS              shift and go to state 520


state 361

    (488) generic_discrim_part_opt -> ( . BOX )
    (112) discrim_part -> ( . discrim_spec_s )
    (113) discrim_spec_s -> . discrim_spec
    (114) discrim_spec_s -> . discrim_spec_s ; discrim_spec
    (115) discrim_spec -> . def_id_s : access_opt mark init_opt
    (116) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . ID

    BOX             shift and go to state 521
    error           shift and go to state 484
    ID              shift and go to state 91

    discrim_spec                   shift and go to state 487
    discrim_spec_s                 shift and go to state 485
    def_id                         shift and go to state 88
    def_id_s                       shift and go to state 486

state 362

    (487) generic_discrim_part_opt -> discrim_part .

    IS              reduce using rule 487 (generic_discrim_part_opt -> discrim_part .)


state 363

    (321) subprog_spec -> FUNCTION designator formal_part_opt RETURN . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 522
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    indexed_comp                   shift and go to state 130
    operator_symbol                shift and go to state 139
    simple_name                    shift and go to state 160

state 364

    (237) factor -> primary DOUBLESTAR primary .

    *               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    /               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    MOD             reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    REM             reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    =               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    NOTEQUAL        reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    <               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    LEQUAL          reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    >               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    GEQUAL          reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    IN              reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    NOT             reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    +               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    -               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    &               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    ;               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    AND             reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    OR              reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    XOR             reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    )               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    ,               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    DOUBLEDOT       reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    WITH            reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    ARROW           reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    |               reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    IS              reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    THEN            reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    LOOP            reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    RANGE           reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    DIGITS          reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    RENAMES         reduce using rule 237 (factor -> primary DOUBLESTAR primary .)
    ASSIGNMENT      reduce using rule 237 (factor -> primary DOUBLESTAR primary .)


state 365

    (223) simple_expression -> simple_expression adding term .
    (230) term -> term . multiplying factor
    (231) multiplying -> . *
    (232) multiplying -> . /
    (233) multiplying -> . MOD
    (234) multiplying -> . REM

    DOUBLEDOT       reduce using rule 223 (simple_expression -> simple_expression adding term .)
    =               reduce using rule 223 (simple_expression -> simple_expression adding term .)
    NOTEQUAL        reduce using rule 223 (simple_expression -> simple_expression adding term .)
    <               reduce using rule 223 (simple_expression -> simple_expression adding term .)
    LEQUAL          reduce using rule 223 (simple_expression -> simple_expression adding term .)
    >               reduce using rule 223 (simple_expression -> simple_expression adding term .)
    GEQUAL          reduce using rule 223 (simple_expression -> simple_expression adding term .)
    IN              reduce using rule 223 (simple_expression -> simple_expression adding term .)
    NOT             reduce using rule 223 (simple_expression -> simple_expression adding term .)
    +               reduce using rule 223 (simple_expression -> simple_expression adding term .)
    -               reduce using rule 223 (simple_expression -> simple_expression adding term .)
    &               reduce using rule 223 (simple_expression -> simple_expression adding term .)
    AND             reduce using rule 223 (simple_expression -> simple_expression adding term .)
    OR              reduce using rule 223 (simple_expression -> simple_expression adding term .)
    XOR             reduce using rule 223 (simple_expression -> simple_expression adding term .)
    ARROW           reduce using rule 223 (simple_expression -> simple_expression adding term .)
    |               reduce using rule 223 (simple_expression -> simple_expression adding term .)
    THEN            reduce using rule 223 (simple_expression -> simple_expression adding term .)
    )               reduce using rule 223 (simple_expression -> simple_expression adding term .)
    ,               reduce using rule 223 (simple_expression -> simple_expression adding term .)
    WITH            reduce using rule 223 (simple_expression -> simple_expression adding term .)
    ;               reduce using rule 223 (simple_expression -> simple_expression adding term .)
    IS              reduce using rule 223 (simple_expression -> simple_expression adding term .)
    LOOP            reduce using rule 223 (simple_expression -> simple_expression adding term .)
    RANGE           reduce using rule 223 (simple_expression -> simple_expression adding term .)
    DIGITS          reduce using rule 223 (simple_expression -> simple_expression adding term .)
    RENAMES         reduce using rule 223 (simple_expression -> simple_expression adding term .)
    ASSIGNMENT      reduce using rule 223 (simple_expression -> simple_expression adding term .)
    *               shift and go to state 246
    /               shift and go to state 247
    MOD             shift and go to state 248
    REM             shift and go to state 244

    multiplying                    shift and go to state 245

state 366

    (62) range -> simple_expression . DOUBLEDOT simple_expression
    (223) simple_expression -> simple_expression . adding term
    (226) adding -> . +
    (227) adding -> . -
    (228) adding -> . &

    DOUBLEDOT       shift and go to state 372
    +               shift and go to state 217
    -               shift and go to state 219
    &               shift and go to state 218

    adding                         shift and go to state 213

state 367

    (212) relation -> simple_expression membership name .
    (63) range -> name . SINGLEQUOTE RANGE
    (64) range -> name . SINGLEQUOTE RANGE ( expression )
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id
    (240) primary -> name .
    (246) qualified -> name . SINGLEQUOTE parenthesized_primary

    AND             reduce using rule 212 (relation -> simple_expression membership name .)
    OR              reduce using rule 212 (relation -> simple_expression membership name .)
    XOR             reduce using rule 212 (relation -> simple_expression membership name .)
    )               reduce using rule 212 (relation -> simple_expression membership name .)
    ,               reduce using rule 212 (relation -> simple_expression membership name .)
    ;               reduce using rule 212 (relation -> simple_expression membership name .)
    RANGE           reduce using rule 212 (relation -> simple_expression membership name .)
    RENAMES         reduce using rule 212 (relation -> simple_expression membership name .)
    ASSIGNMENT      reduce using rule 212 (relation -> simple_expression membership name .)
    WITH            reduce using rule 212 (relation -> simple_expression membership name .)
    ARROW           reduce using rule 212 (relation -> simple_expression membership name .)
    |               reduce using rule 212 (relation -> simple_expression membership name .)
    THEN            reduce using rule 212 (relation -> simple_expression membership name .)
    LOOP            reduce using rule 212 (relation -> simple_expression membership name .)
    IS              reduce using rule 212 (relation -> simple_expression membership name .)
    DIGITS          reduce using rule 212 (relation -> simple_expression membership name .)
    SINGLEQUOTE     shift and go to state 379
    (               shift and go to state 249
    .               shift and go to state 250
    DOUBLESTAR      reduce using rule 240 (primary -> name .)
    *               reduce using rule 240 (primary -> name .)
    /               reduce using rule 240 (primary -> name .)
    MOD             reduce using rule 240 (primary -> name .)
    REM             reduce using rule 240 (primary -> name .)
    DOUBLEDOT       reduce using rule 240 (primary -> name .)
    +               reduce using rule 240 (primary -> name .)
    -               reduce using rule 240 (primary -> name .)
    &               reduce using rule 240 (primary -> name .)


state 368

    (211) relation -> simple_expression membership range .

    AND             reduce using rule 211 (relation -> simple_expression membership range .)
    OR              reduce using rule 211 (relation -> simple_expression membership range .)
    XOR             reduce using rule 211 (relation -> simple_expression membership range .)
    )               reduce using rule 211 (relation -> simple_expression membership range .)
    ,               reduce using rule 211 (relation -> simple_expression membership range .)
    ;               reduce using rule 211 (relation -> simple_expression membership range .)
    RANGE           reduce using rule 211 (relation -> simple_expression membership range .)
    RENAMES         reduce using rule 211 (relation -> simple_expression membership range .)
    ASSIGNMENT      reduce using rule 211 (relation -> simple_expression membership range .)
    WITH            reduce using rule 211 (relation -> simple_expression membership range .)
    ARROW           reduce using rule 211 (relation -> simple_expression membership range .)
    |               reduce using rule 211 (relation -> simple_expression membership range .)
    THEN            reduce using rule 211 (relation -> simple_expression membership range .)
    LOOP            reduce using rule 211 (relation -> simple_expression membership range .)
    IS              reduce using rule 211 (relation -> simple_expression membership range .)
    DIGITS          reduce using rule 211 (relation -> simple_expression membership range .)


state 369

    (220) membership -> NOT IN .

    ID              reduce using rule 220 (membership -> NOT IN .)
    STRLITERAL      reduce using rule 220 (membership -> NOT IN .)
    +               reduce using rule 220 (membership -> NOT IN .)
    -               reduce using rule 220 (membership -> NOT IN .)
    NOT             reduce using rule 220 (membership -> NOT IN .)
    ABS             reduce using rule 220 (membership -> NOT IN .)
    NuLL            reduce using rule 220 (membership -> NOT IN .)
    NEW             reduce using rule 220 (membership -> NOT IN .)
    (               reduce using rule 220 (membership -> NOT IN .)
    NUMLITERAL_BASE_INT reduce using rule 220 (membership -> NOT IN .)
    NUMLITERAL_BASE_FLOAT reduce using rule 220 (membership -> NOT IN .)
    NUMLITERAL_INT  reduce using rule 220 (membership -> NOT IN .)
    NUMLITERAL_FLOAT reduce using rule 220 (membership -> NOT IN .)
    CHARLITERAL     reduce using rule 220 (membership -> NOT IN .)


state 370

    (210) relation -> simple_expression relational simple_expression .
    (223) simple_expression -> simple_expression . adding term
    (226) adding -> . +
    (227) adding -> . -
    (228) adding -> . &

    AND             reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    OR              reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    XOR             reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    )               reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    ,               reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    ;               reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    RANGE           reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    RENAMES         reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    ASSIGNMENT      reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    WITH            reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    ARROW           reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    |               reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    THEN            reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    LOOP            reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    IS              reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    DIGITS          reduce using rule 210 (relation -> simple_expression relational simple_expression .)
    +               shift and go to state 217
    -               shift and go to state 219
    &               shift and go to state 218

    adding                         shift and go to state 213

state 371

    (7) pragma_arg -> simple_name ARROW expression .
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    )               reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
    ,               reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 372

    (62) range -> simple_expression DOUBLEDOT . simple_expression
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    simple_expression              shift and go to state 523
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    operator_symbol                shift and go to state 139

state 373

    (124) choice_s -> choice_s | . choice
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 228
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 389
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    operator_symbol                shift and go to state 139
    factor                         shift and go to state 138
    choice                         shift and go to state 524
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    discrete_with_range            shift and go to state 525
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 235
    range                          shift and go to state 237
    expression                     shift and go to state 526

state 374

    (200) comp_assoc -> choice_s ARROW . expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 527

state 375

    (193) aggregate -> ( comp_assoc ) .

    DOUBLESTAR      reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    *               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    /               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    MOD             reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    REM             reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    =               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    NOTEQUAL        reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    <               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    LEQUAL          reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    >               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    GEQUAL          reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    IN              reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    NOT             reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    +               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    -               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    &               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    AND             reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    OR              reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    XOR             reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    )               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    ,               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    DOUBLEDOT       reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    WITH            reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    ARROW           reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    |               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    ;               reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    IS              reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    THEN            reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    LOOP            reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    RANGE           reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    DIGITS          reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    RENAMES         reduce using rule 193 (aggregate -> ( comp_assoc ) .)
    ASSIGNMENT      reduce using rule 193 (aggregate -> ( comp_assoc ) .)


state 376

    (194) aggregate -> ( value_s_2 ) .

    DOUBLESTAR      reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    *               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    /               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    MOD             reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    REM             reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    =               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    NOTEQUAL        reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    <               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    LEQUAL          reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    >               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    GEQUAL          reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    IN              reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    NOT             reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    +               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    -               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    &               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    AND             reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    OR              reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    XOR             reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    )               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    ,               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    DOUBLEDOT       reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    WITH            reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    ARROW           reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    |               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    ;               reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    IS              reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    THEN            reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    LOOP            reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    RANGE           reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    DIGITS          reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    RENAMES         reduce using rule 194 (aggregate -> ( value_s_2 ) .)
    ASSIGNMENT      reduce using rule 194 (aggregate -> ( value_s_2 ) .)


state 377

    (199) value_s_2 -> value_s_2 , . value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (200) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 238
    OTHERS          shift and go to state 228
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 389
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    choice_s                       shift and go to state 230
    operator_symbol                shift and go to state 139
    comp_assoc                     shift and go to state 390
    factor                         shift and go to state 138
    choice                         shift and go to state 232
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    discrete_with_range            shift and go to state 234
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 235
    value                          shift and go to state 528
    range                          shift and go to state 237
    expression                     shift and go to state 392

state 378

    (61) range_constraint -> RANGE . range
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    simple_expression              shift and go to state 366
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 529
    operator_symbol                shift and go to state 139
    range                          shift and go to state 530

state 379

    (63) range -> name SINGLEQUOTE . RANGE
    (64) range -> name SINGLEQUOTE . RANGE ( expression )
    (181) attribute -> name SINGLEQUOTE . attribute_id
    (246) qualified -> name SINGLEQUOTE . parenthesized_primary
    (182) attribute_id -> . ID
    (183) attribute_id -> . DIGITS
    (184) attribute_id -> . DELTA
    (185) attribute_id -> . ACCESS
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    RANGE           shift and go to state 531
    ID              shift and go to state 402
    DIGITS          shift and go to state 397
    DELTA           shift and go to state 400
    ACCESS          shift and go to state 398
    (               shift and go to state 134

    attribute_id                   shift and go to state 399
    aggregate                      shift and go to state 145
    parenthesized_primary          shift and go to state 401

state 380

    (128) discrete_with_range -> name range_constraint .

    ARROW           reduce using rule 128 (discrete_with_range -> name range_constraint .)
    |               reduce using rule 128 (discrete_with_range -> name range_constraint .)
    )               reduce using rule 128 (discrete_with_range -> name range_constraint .)
    ,               reduce using rule 128 (discrete_with_range -> name range_constraint .)


state 381

    (198) value_s_2 -> value , . value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (200) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 238
    OTHERS          shift and go to state 228
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 389
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    choice_s                       shift and go to state 230
    operator_symbol                shift and go to state 139
    comp_assoc                     shift and go to state 390
    factor                         shift and go to state 138
    choice                         shift and go to state 232
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    discrete_with_range            shift and go to state 234
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 235
    value                          shift and go to state 532
    range                          shift and go to state 237
    expression                     shift and go to state 392

state 382

    (197) aggregate -> ( NuLL RECORD . )

    )               shift and go to state 533


state 383

    (245) parenthesized_primary -> ( expression ) .

    DOUBLESTAR      reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    *               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    /               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    MOD             reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    REM             reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    =               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    NOTEQUAL        reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    <               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    LEQUAL          reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    >               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    GEQUAL          reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    IN              reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    NOT             reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    +               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    -               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    &               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    AND             reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    OR              reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    XOR             reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    ARROW           reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    )               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    ,               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    WITH            reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    |               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    ;               reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    IS              reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    THEN            reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    LOOP            reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    RANGE           reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    DIGITS          reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    RENAMES         reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    ASSIGNMENT      reduce using rule 245 (parenthesized_primary -> ( expression ) .)
    DOUBLEDOT       reduce using rule 245 (parenthesized_primary -> ( expression ) .)


state 384

    (195) aggregate -> ( expression WITH . value_s )
    (196) aggregate -> ( expression WITH . NuLL RECORD )
    (171) value_s -> . value
    (172) value_s -> . value_s , value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (200) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    NuLL            shift and go to state 535
    error           shift and go to state 238
    OTHERS          shift and go to state 228
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    value_s                        shift and go to state 534
    simple_expression              shift and go to state 389
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    choice_s                       shift and go to state 230
    operator_symbol                shift and go to state 139
    comp_assoc                     shift and go to state 390
    factor                         shift and go to state 138
    choice                         shift and go to state 232
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    discrete_with_range            shift and go to state 234
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 235
    value                          shift and go to state 391
    range                          shift and go to state 237
    expression                     shift and go to state 392

state 385

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .

    error           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    USE             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PRAGMA          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    TYPE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SUBTYPE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    TASK            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PACKAGE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PROTECTED       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    FOR             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    GENERIC         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PROCEDURE       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    FUNCTION        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ID              reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PRIVATE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    END             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ENTRY           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    LEFTLABEL       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    NuLL            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    EXIT            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    RETURN          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    GOTO            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    DELAY           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ABORT           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    RAISE           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    REQUEUE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    IF              reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    CASE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ACCEPT          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SELECT          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    STRLITERAL      reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WHILE           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    DECLARE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    LOOP            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    BEGIN           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WHEN            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WITH            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SEPARATE        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    $end            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    OR              reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ELSE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    EXCEPTION       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    THEN            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ELSIF           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)


state 386

    (5) pragma_arg_s -> pragma_arg_s , pragma_arg .

    )               reduce using rule 5 (pragma_arg_s -> pragma_arg_s , pragma_arg .)
    ,               reduce using rule 5 (pragma_arg_s -> pragma_arg_s , pragma_arg .)


state 387

    (230) term -> term multiplying factor .

    *               reduce using rule 230 (term -> term multiplying factor .)
    /               reduce using rule 230 (term -> term multiplying factor .)
    MOD             reduce using rule 230 (term -> term multiplying factor .)
    REM             reduce using rule 230 (term -> term multiplying factor .)
    =               reduce using rule 230 (term -> term multiplying factor .)
    NOTEQUAL        reduce using rule 230 (term -> term multiplying factor .)
    <               reduce using rule 230 (term -> term multiplying factor .)
    LEQUAL          reduce using rule 230 (term -> term multiplying factor .)
    >               reduce using rule 230 (term -> term multiplying factor .)
    GEQUAL          reduce using rule 230 (term -> term multiplying factor .)
    IN              reduce using rule 230 (term -> term multiplying factor .)
    NOT             reduce using rule 230 (term -> term multiplying factor .)
    +               reduce using rule 230 (term -> term multiplying factor .)
    -               reduce using rule 230 (term -> term multiplying factor .)
    &               reduce using rule 230 (term -> term multiplying factor .)
    AND             reduce using rule 230 (term -> term multiplying factor .)
    OR              reduce using rule 230 (term -> term multiplying factor .)
    XOR             reduce using rule 230 (term -> term multiplying factor .)
    )               reduce using rule 230 (term -> term multiplying factor .)
    ,               reduce using rule 230 (term -> term multiplying factor .)
    DOUBLEDOT       reduce using rule 230 (term -> term multiplying factor .)
    ARROW           reduce using rule 230 (term -> term multiplying factor .)
    |               reduce using rule 230 (term -> term multiplying factor .)
    WITH            reduce using rule 230 (term -> term multiplying factor .)
    ;               reduce using rule 230 (term -> term multiplying factor .)
    IS              reduce using rule 230 (term -> term multiplying factor .)
    THEN            reduce using rule 230 (term -> term multiplying factor .)
    LOOP            reduce using rule 230 (term -> term multiplying factor .)
    RANGE           reduce using rule 230 (term -> term multiplying factor .)
    DIGITS          reduce using rule 230 (term -> term multiplying factor .)
    RENAMES         reduce using rule 230 (term -> term multiplying factor .)
    ASSIGNMENT      reduce using rule 230 (term -> term multiplying factor .)


state 388

    (170) indexed_comp -> name ( value_s . )
    (172) value_s -> value_s . , value

    )               shift and go to state 536
    ,               shift and go to state 537


state 389

    (209) relation -> simple_expression .
    (210) relation -> simple_expression . relational simple_expression
    (211) relation -> simple_expression . membership range
    (212) relation -> simple_expression . membership name
    (62) range -> simple_expression . DOUBLEDOT simple_expression
    (223) simple_expression -> simple_expression . adding term
    (213) relational -> . =
    (214) relational -> . NOTEQUAL
    (215) relational -> . <
    (216) relational -> . LEQUAL
    (217) relational -> . >
    (218) relational -> . GEQUAL
    (219) membership -> . IN
    (220) membership -> . NOT IN
    (226) adding -> . +
    (227) adding -> . -
    (228) adding -> . &

    AND             reduce using rule 209 (relation -> simple_expression .)
    OR              reduce using rule 209 (relation -> simple_expression .)
    XOR             reduce using rule 209 (relation -> simple_expression .)
    )               reduce using rule 209 (relation -> simple_expression .)
    ,               reduce using rule 209 (relation -> simple_expression .)
    ARROW           reduce using rule 209 (relation -> simple_expression .)
    |               reduce using rule 209 (relation -> simple_expression .)
    DOUBLEDOT       shift and go to state 372
    =               shift and go to state 224
    NOTEQUAL        shift and go to state 216
    <               shift and go to state 225
    LEQUAL          shift and go to state 215
    >               shift and go to state 226
    GEQUAL          shift and go to state 214
    IN              shift and go to state 221
    NOT             shift and go to state 222
    +               shift and go to state 217
    -               shift and go to state 219
    &               shift and go to state 218

    adding                         shift and go to state 213
    membership                     shift and go to state 220
    relational                     shift and go to state 223

state 390

    (174) value -> comp_assoc .

    )               reduce using rule 174 (value -> comp_assoc .)
    ,               reduce using rule 174 (value -> comp_assoc .)


state 391

    (171) value_s -> value .

    )               reduce using rule 171 (value_s -> value .)
    ,               reduce using rule 171 (value_s -> value .)


state 392

    (173) value -> expression .
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (125) choice -> expression .
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    )               reduce using rule 173 (value -> expression .)
    ,               reduce using rule 173 (value -> expression .)
    ARROW           reduce using rule 125 (choice -> expression .)
    |               reduce using rule 125 (choice -> expression .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 393

    (180) selected_comp -> name . ALL .

    SINGLEQUOTE     reduce using rule 180 (selected_comp -> name . ALL .)
    (               reduce using rule 180 (selected_comp -> name . ALL .)
    .               reduce using rule 180 (selected_comp -> name . ALL .)
    DOUBLESTAR      reduce using rule 180 (selected_comp -> name . ALL .)
    *               reduce using rule 180 (selected_comp -> name . ALL .)
    /               reduce using rule 180 (selected_comp -> name . ALL .)
    MOD             reduce using rule 180 (selected_comp -> name . ALL .)
    REM             reduce using rule 180 (selected_comp -> name . ALL .)
    =               reduce using rule 180 (selected_comp -> name . ALL .)
    NOTEQUAL        reduce using rule 180 (selected_comp -> name . ALL .)
    <               reduce using rule 180 (selected_comp -> name . ALL .)
    LEQUAL          reduce using rule 180 (selected_comp -> name . ALL .)
    >               reduce using rule 180 (selected_comp -> name . ALL .)
    GEQUAL          reduce using rule 180 (selected_comp -> name . ALL .)
    IN              reduce using rule 180 (selected_comp -> name . ALL .)
    NOT             reduce using rule 180 (selected_comp -> name . ALL .)
    +               reduce using rule 180 (selected_comp -> name . ALL .)
    -               reduce using rule 180 (selected_comp -> name . ALL .)
    &               reduce using rule 180 (selected_comp -> name . ALL .)
    AND             reduce using rule 180 (selected_comp -> name . ALL .)
    OR              reduce using rule 180 (selected_comp -> name . ALL .)
    XOR             reduce using rule 180 (selected_comp -> name . ALL .)
    ;               reduce using rule 180 (selected_comp -> name . ALL .)
    RANGE           reduce using rule 180 (selected_comp -> name . ALL .)
    DOUBLEDOT       reduce using rule 180 (selected_comp -> name . ALL .)
    )               reduce using rule 180 (selected_comp -> name . ALL .)
    ,               reduce using rule 180 (selected_comp -> name . ALL .)
    ARROW           reduce using rule 180 (selected_comp -> name . ALL .)
    |               reduce using rule 180 (selected_comp -> name . ALL .)
    WHEN            reduce using rule 180 (selected_comp -> name . ALL .)
    IS              reduce using rule 180 (selected_comp -> name . ALL .)
    DIGITS          reduce using rule 180 (selected_comp -> name . ALL .)
    RENAMES         reduce using rule 180 (selected_comp -> name . ALL .)
    ASSIGNMENT      reduce using rule 180 (selected_comp -> name . ALL .)
    WITH            reduce using rule 180 (selected_comp -> name . ALL .)
    THEN            reduce using rule 180 (selected_comp -> name . ALL .)
    LOOP            reduce using rule 180 (selected_comp -> name . ALL .)


state 394

    (179) selected_comp -> name . operator_symbol .

    SINGLEQUOTE     reduce using rule 179 (selected_comp -> name . operator_symbol .)
    (               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    .               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    DOUBLESTAR      reduce using rule 179 (selected_comp -> name . operator_symbol .)
    *               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    /               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    MOD             reduce using rule 179 (selected_comp -> name . operator_symbol .)
    REM             reduce using rule 179 (selected_comp -> name . operator_symbol .)
    =               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    NOTEQUAL        reduce using rule 179 (selected_comp -> name . operator_symbol .)
    <               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    LEQUAL          reduce using rule 179 (selected_comp -> name . operator_symbol .)
    >               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    GEQUAL          reduce using rule 179 (selected_comp -> name . operator_symbol .)
    IN              reduce using rule 179 (selected_comp -> name . operator_symbol .)
    NOT             reduce using rule 179 (selected_comp -> name . operator_symbol .)
    +               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    -               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    &               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    AND             reduce using rule 179 (selected_comp -> name . operator_symbol .)
    OR              reduce using rule 179 (selected_comp -> name . operator_symbol .)
    XOR             reduce using rule 179 (selected_comp -> name . operator_symbol .)
    ;               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    RANGE           reduce using rule 179 (selected_comp -> name . operator_symbol .)
    DOUBLEDOT       reduce using rule 179 (selected_comp -> name . operator_symbol .)
    )               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    ,               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    ARROW           reduce using rule 179 (selected_comp -> name . operator_symbol .)
    |               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    WHEN            reduce using rule 179 (selected_comp -> name . operator_symbol .)
    IS              reduce using rule 179 (selected_comp -> name . operator_symbol .)
    DIGITS          reduce using rule 179 (selected_comp -> name . operator_symbol .)
    RENAMES         reduce using rule 179 (selected_comp -> name . operator_symbol .)
    ASSIGNMENT      reduce using rule 179 (selected_comp -> name . operator_symbol .)
    WITH            reduce using rule 179 (selected_comp -> name . operator_symbol .)
    THEN            reduce using rule 179 (selected_comp -> name . operator_symbol .)
    LOOP            reduce using rule 179 (selected_comp -> name . operator_symbol .)


state 395

    (178) selected_comp -> name . used_char .

    SINGLEQUOTE     reduce using rule 178 (selected_comp -> name . used_char .)
    (               reduce using rule 178 (selected_comp -> name . used_char .)
    .               reduce using rule 178 (selected_comp -> name . used_char .)
    DOUBLESTAR      reduce using rule 178 (selected_comp -> name . used_char .)
    *               reduce using rule 178 (selected_comp -> name . used_char .)
    /               reduce using rule 178 (selected_comp -> name . used_char .)
    MOD             reduce using rule 178 (selected_comp -> name . used_char .)
    REM             reduce using rule 178 (selected_comp -> name . used_char .)
    =               reduce using rule 178 (selected_comp -> name . used_char .)
    NOTEQUAL        reduce using rule 178 (selected_comp -> name . used_char .)
    <               reduce using rule 178 (selected_comp -> name . used_char .)
    LEQUAL          reduce using rule 178 (selected_comp -> name . used_char .)
    >               reduce using rule 178 (selected_comp -> name . used_char .)
    GEQUAL          reduce using rule 178 (selected_comp -> name . used_char .)
    IN              reduce using rule 178 (selected_comp -> name . used_char .)
    NOT             reduce using rule 178 (selected_comp -> name . used_char .)
    +               reduce using rule 178 (selected_comp -> name . used_char .)
    -               reduce using rule 178 (selected_comp -> name . used_char .)
    &               reduce using rule 178 (selected_comp -> name . used_char .)
    AND             reduce using rule 178 (selected_comp -> name . used_char .)
    OR              reduce using rule 178 (selected_comp -> name . used_char .)
    XOR             reduce using rule 178 (selected_comp -> name . used_char .)
    ;               reduce using rule 178 (selected_comp -> name . used_char .)
    RANGE           reduce using rule 178 (selected_comp -> name . used_char .)
    DOUBLEDOT       reduce using rule 178 (selected_comp -> name . used_char .)
    )               reduce using rule 178 (selected_comp -> name . used_char .)
    ,               reduce using rule 178 (selected_comp -> name . used_char .)
    ARROW           reduce using rule 178 (selected_comp -> name . used_char .)
    |               reduce using rule 178 (selected_comp -> name . used_char .)
    WHEN            reduce using rule 178 (selected_comp -> name . used_char .)
    IS              reduce using rule 178 (selected_comp -> name . used_char .)
    DIGITS          reduce using rule 178 (selected_comp -> name . used_char .)
    RENAMES         reduce using rule 178 (selected_comp -> name . used_char .)
    ASSIGNMENT      reduce using rule 178 (selected_comp -> name . used_char .)
    WITH            reduce using rule 178 (selected_comp -> name . used_char .)
    THEN            reduce using rule 178 (selected_comp -> name . used_char .)
    LOOP            reduce using rule 178 (selected_comp -> name . used_char .)


state 396

    (177) selected_comp -> name . simple_name .

    SINGLEQUOTE     reduce using rule 177 (selected_comp -> name . simple_name .)
    (               reduce using rule 177 (selected_comp -> name . simple_name .)
    .               reduce using rule 177 (selected_comp -> name . simple_name .)
    DOUBLESTAR      reduce using rule 177 (selected_comp -> name . simple_name .)
    *               reduce using rule 177 (selected_comp -> name . simple_name .)
    /               reduce using rule 177 (selected_comp -> name . simple_name .)
    MOD             reduce using rule 177 (selected_comp -> name . simple_name .)
    REM             reduce using rule 177 (selected_comp -> name . simple_name .)
    =               reduce using rule 177 (selected_comp -> name . simple_name .)
    NOTEQUAL        reduce using rule 177 (selected_comp -> name . simple_name .)
    <               reduce using rule 177 (selected_comp -> name . simple_name .)
    LEQUAL          reduce using rule 177 (selected_comp -> name . simple_name .)
    >               reduce using rule 177 (selected_comp -> name . simple_name .)
    GEQUAL          reduce using rule 177 (selected_comp -> name . simple_name .)
    IN              reduce using rule 177 (selected_comp -> name . simple_name .)
    NOT             reduce using rule 177 (selected_comp -> name . simple_name .)
    +               reduce using rule 177 (selected_comp -> name . simple_name .)
    -               reduce using rule 177 (selected_comp -> name . simple_name .)
    &               reduce using rule 177 (selected_comp -> name . simple_name .)
    AND             reduce using rule 177 (selected_comp -> name . simple_name .)
    OR              reduce using rule 177 (selected_comp -> name . simple_name .)
    XOR             reduce using rule 177 (selected_comp -> name . simple_name .)
    ;               reduce using rule 177 (selected_comp -> name . simple_name .)
    RANGE           reduce using rule 177 (selected_comp -> name . simple_name .)
    DOUBLEDOT       reduce using rule 177 (selected_comp -> name . simple_name .)
    )               reduce using rule 177 (selected_comp -> name . simple_name .)
    ,               reduce using rule 177 (selected_comp -> name . simple_name .)
    ARROW           reduce using rule 177 (selected_comp -> name . simple_name .)
    |               reduce using rule 177 (selected_comp -> name . simple_name .)
    WHEN            reduce using rule 177 (selected_comp -> name . simple_name .)
    IS              reduce using rule 177 (selected_comp -> name . simple_name .)
    DIGITS          reduce using rule 177 (selected_comp -> name . simple_name .)
    RENAMES         reduce using rule 177 (selected_comp -> name . simple_name .)
    ASSIGNMENT      reduce using rule 177 (selected_comp -> name . simple_name .)
    WITH            reduce using rule 177 (selected_comp -> name . simple_name .)
    THEN            reduce using rule 177 (selected_comp -> name . simple_name .)
    LOOP            reduce using rule 177 (selected_comp -> name . simple_name .)


state 397

    (183) attribute_id -> DIGITS .

    SINGLEQUOTE     reduce using rule 183 (attribute_id -> DIGITS .)
    (               reduce using rule 183 (attribute_id -> DIGITS .)
    .               reduce using rule 183 (attribute_id -> DIGITS .)
    RANGE           reduce using rule 183 (attribute_id -> DIGITS .)
    DOUBLESTAR      reduce using rule 183 (attribute_id -> DIGITS .)
    *               reduce using rule 183 (attribute_id -> DIGITS .)
    /               reduce using rule 183 (attribute_id -> DIGITS .)
    MOD             reduce using rule 183 (attribute_id -> DIGITS .)
    REM             reduce using rule 183 (attribute_id -> DIGITS .)
    DOUBLEDOT       reduce using rule 183 (attribute_id -> DIGITS .)
    =               reduce using rule 183 (attribute_id -> DIGITS .)
    NOTEQUAL        reduce using rule 183 (attribute_id -> DIGITS .)
    <               reduce using rule 183 (attribute_id -> DIGITS .)
    LEQUAL          reduce using rule 183 (attribute_id -> DIGITS .)
    >               reduce using rule 183 (attribute_id -> DIGITS .)
    GEQUAL          reduce using rule 183 (attribute_id -> DIGITS .)
    IN              reduce using rule 183 (attribute_id -> DIGITS .)
    NOT             reduce using rule 183 (attribute_id -> DIGITS .)
    +               reduce using rule 183 (attribute_id -> DIGITS .)
    -               reduce using rule 183 (attribute_id -> DIGITS .)
    &               reduce using rule 183 (attribute_id -> DIGITS .)
    )               reduce using rule 183 (attribute_id -> DIGITS .)
    WITH            reduce using rule 183 (attribute_id -> DIGITS .)
    AND             reduce using rule 183 (attribute_id -> DIGITS .)
    OR              reduce using rule 183 (attribute_id -> DIGITS .)
    XOR             reduce using rule 183 (attribute_id -> DIGITS .)
    ,               reduce using rule 183 (attribute_id -> DIGITS .)
    ARROW           reduce using rule 183 (attribute_id -> DIGITS .)
    |               reduce using rule 183 (attribute_id -> DIGITS .)
    ;               reduce using rule 183 (attribute_id -> DIGITS .)
    IS              reduce using rule 183 (attribute_id -> DIGITS .)
    THEN            reduce using rule 183 (attribute_id -> DIGITS .)
    LOOP            reduce using rule 183 (attribute_id -> DIGITS .)
    DIGITS          reduce using rule 183 (attribute_id -> DIGITS .)
    RENAMES         reduce using rule 183 (attribute_id -> DIGITS .)
    ASSIGNMENT      reduce using rule 183 (attribute_id -> DIGITS .)
    USE             reduce using rule 183 (attribute_id -> DIGITS .)
    AT              reduce using rule 183 (attribute_id -> DIGITS .)
    WHEN            reduce using rule 183 (attribute_id -> DIGITS .)


state 398

    (185) attribute_id -> ACCESS .

    SINGLEQUOTE     reduce using rule 185 (attribute_id -> ACCESS .)
    (               reduce using rule 185 (attribute_id -> ACCESS .)
    .               reduce using rule 185 (attribute_id -> ACCESS .)
    RANGE           reduce using rule 185 (attribute_id -> ACCESS .)
    DOUBLESTAR      reduce using rule 185 (attribute_id -> ACCESS .)
    *               reduce using rule 185 (attribute_id -> ACCESS .)
    /               reduce using rule 185 (attribute_id -> ACCESS .)
    MOD             reduce using rule 185 (attribute_id -> ACCESS .)
    REM             reduce using rule 185 (attribute_id -> ACCESS .)
    DOUBLEDOT       reduce using rule 185 (attribute_id -> ACCESS .)
    =               reduce using rule 185 (attribute_id -> ACCESS .)
    NOTEQUAL        reduce using rule 185 (attribute_id -> ACCESS .)
    <               reduce using rule 185 (attribute_id -> ACCESS .)
    LEQUAL          reduce using rule 185 (attribute_id -> ACCESS .)
    >               reduce using rule 185 (attribute_id -> ACCESS .)
    GEQUAL          reduce using rule 185 (attribute_id -> ACCESS .)
    IN              reduce using rule 185 (attribute_id -> ACCESS .)
    NOT             reduce using rule 185 (attribute_id -> ACCESS .)
    +               reduce using rule 185 (attribute_id -> ACCESS .)
    -               reduce using rule 185 (attribute_id -> ACCESS .)
    &               reduce using rule 185 (attribute_id -> ACCESS .)
    )               reduce using rule 185 (attribute_id -> ACCESS .)
    WITH            reduce using rule 185 (attribute_id -> ACCESS .)
    AND             reduce using rule 185 (attribute_id -> ACCESS .)
    OR              reduce using rule 185 (attribute_id -> ACCESS .)
    XOR             reduce using rule 185 (attribute_id -> ACCESS .)
    ,               reduce using rule 185 (attribute_id -> ACCESS .)
    ARROW           reduce using rule 185 (attribute_id -> ACCESS .)
    |               reduce using rule 185 (attribute_id -> ACCESS .)
    ;               reduce using rule 185 (attribute_id -> ACCESS .)
    IS              reduce using rule 185 (attribute_id -> ACCESS .)
    THEN            reduce using rule 185 (attribute_id -> ACCESS .)
    LOOP            reduce using rule 185 (attribute_id -> ACCESS .)
    DIGITS          reduce using rule 185 (attribute_id -> ACCESS .)
    RENAMES         reduce using rule 185 (attribute_id -> ACCESS .)
    ASSIGNMENT      reduce using rule 185 (attribute_id -> ACCESS .)
    USE             reduce using rule 185 (attribute_id -> ACCESS .)
    AT              reduce using rule 185 (attribute_id -> ACCESS .)
    WHEN            reduce using rule 185 (attribute_id -> ACCESS .)


state 399

    (181) attribute -> name SINGLEQUOTE attribute_id .

    SINGLEQUOTE     reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    (               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    .               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    DOUBLESTAR      reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    *               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    /               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    MOD             reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    REM             reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    +               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    -               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    &               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    ,               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    ARROW           reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    |               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    AND             reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    OR              reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    XOR             reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    )               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    WITH            reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    ;               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    IS              reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    THEN            reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    LOOP            reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    RANGE           reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    DIGITS          reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    RENAMES         reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    ASSIGNMENT      reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    =               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    NOTEQUAL        reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    <               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    LEQUAL          reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    >               reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    GEQUAL          reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    IN              reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    NOT             reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    DOUBLEDOT       reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)
    WHEN            reduce using rule 181 (attribute -> name SINGLEQUOTE attribute_id .)


state 400

    (184) attribute_id -> DELTA .

    SINGLEQUOTE     reduce using rule 184 (attribute_id -> DELTA .)
    (               reduce using rule 184 (attribute_id -> DELTA .)
    .               reduce using rule 184 (attribute_id -> DELTA .)
    RANGE           reduce using rule 184 (attribute_id -> DELTA .)
    DOUBLESTAR      reduce using rule 184 (attribute_id -> DELTA .)
    *               reduce using rule 184 (attribute_id -> DELTA .)
    /               reduce using rule 184 (attribute_id -> DELTA .)
    MOD             reduce using rule 184 (attribute_id -> DELTA .)
    REM             reduce using rule 184 (attribute_id -> DELTA .)
    DOUBLEDOT       reduce using rule 184 (attribute_id -> DELTA .)
    =               reduce using rule 184 (attribute_id -> DELTA .)
    NOTEQUAL        reduce using rule 184 (attribute_id -> DELTA .)
    <               reduce using rule 184 (attribute_id -> DELTA .)
    LEQUAL          reduce using rule 184 (attribute_id -> DELTA .)
    >               reduce using rule 184 (attribute_id -> DELTA .)
    GEQUAL          reduce using rule 184 (attribute_id -> DELTA .)
    IN              reduce using rule 184 (attribute_id -> DELTA .)
    NOT             reduce using rule 184 (attribute_id -> DELTA .)
    +               reduce using rule 184 (attribute_id -> DELTA .)
    -               reduce using rule 184 (attribute_id -> DELTA .)
    &               reduce using rule 184 (attribute_id -> DELTA .)
    )               reduce using rule 184 (attribute_id -> DELTA .)
    WITH            reduce using rule 184 (attribute_id -> DELTA .)
    AND             reduce using rule 184 (attribute_id -> DELTA .)
    OR              reduce using rule 184 (attribute_id -> DELTA .)
    XOR             reduce using rule 184 (attribute_id -> DELTA .)
    ,               reduce using rule 184 (attribute_id -> DELTA .)
    ARROW           reduce using rule 184 (attribute_id -> DELTA .)
    |               reduce using rule 184 (attribute_id -> DELTA .)
    ;               reduce using rule 184 (attribute_id -> DELTA .)
    IS              reduce using rule 184 (attribute_id -> DELTA .)
    THEN            reduce using rule 184 (attribute_id -> DELTA .)
    LOOP            reduce using rule 184 (attribute_id -> DELTA .)
    DIGITS          reduce using rule 184 (attribute_id -> DELTA .)
    RENAMES         reduce using rule 184 (attribute_id -> DELTA .)
    ASSIGNMENT      reduce using rule 184 (attribute_id -> DELTA .)
    USE             reduce using rule 184 (attribute_id -> DELTA .)
    AT              reduce using rule 184 (attribute_id -> DELTA .)
    WHEN            reduce using rule 184 (attribute_id -> DELTA .)


state 401

    (246) qualified -> name SINGLEQUOTE parenthesized_primary .

    ;               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    DOUBLESTAR      reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    *               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    /               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    MOD             reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    REM             reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    DOUBLEDOT       reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    =               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    NOTEQUAL        reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    <               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    LEQUAL          reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    >               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    GEQUAL          reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    IN              reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    NOT             reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    +               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    -               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    &               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    AND             reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    OR              reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    XOR             reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    )               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    ,               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    ARROW           reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    |               reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    IS              reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    RANGE           reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    WITH            reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    THEN            reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    LOOP            reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    DIGITS          reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    RENAMES         reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)
    ASSIGNMENT      reduce using rule 246 (qualified -> name SINGLEQUOTE parenthesized_primary .)


state 402

    (182) attribute_id -> ID .

    SINGLEQUOTE     reduce using rule 182 (attribute_id -> ID .)
    (               reduce using rule 182 (attribute_id -> ID .)
    .               reduce using rule 182 (attribute_id -> ID .)
    RANGE           reduce using rule 182 (attribute_id -> ID .)
    DOUBLESTAR      reduce using rule 182 (attribute_id -> ID .)
    *               reduce using rule 182 (attribute_id -> ID .)
    /               reduce using rule 182 (attribute_id -> ID .)
    MOD             reduce using rule 182 (attribute_id -> ID .)
    REM             reduce using rule 182 (attribute_id -> ID .)
    DOUBLEDOT       reduce using rule 182 (attribute_id -> ID .)
    =               reduce using rule 182 (attribute_id -> ID .)
    NOTEQUAL        reduce using rule 182 (attribute_id -> ID .)
    <               reduce using rule 182 (attribute_id -> ID .)
    LEQUAL          reduce using rule 182 (attribute_id -> ID .)
    >               reduce using rule 182 (attribute_id -> ID .)
    GEQUAL          reduce using rule 182 (attribute_id -> ID .)
    IN              reduce using rule 182 (attribute_id -> ID .)
    NOT             reduce using rule 182 (attribute_id -> ID .)
    +               reduce using rule 182 (attribute_id -> ID .)
    -               reduce using rule 182 (attribute_id -> ID .)
    &               reduce using rule 182 (attribute_id -> ID .)
    )               reduce using rule 182 (attribute_id -> ID .)
    WITH            reduce using rule 182 (attribute_id -> ID .)
    AND             reduce using rule 182 (attribute_id -> ID .)
    OR              reduce using rule 182 (attribute_id -> ID .)
    XOR             reduce using rule 182 (attribute_id -> ID .)
    ,               reduce using rule 182 (attribute_id -> ID .)
    ARROW           reduce using rule 182 (attribute_id -> ID .)
    |               reduce using rule 182 (attribute_id -> ID .)
    ;               reduce using rule 182 (attribute_id -> ID .)
    IS              reduce using rule 182 (attribute_id -> ID .)
    THEN            reduce using rule 182 (attribute_id -> ID .)
    LOOP            reduce using rule 182 (attribute_id -> ID .)
    DIGITS          reduce using rule 182 (attribute_id -> ID .)
    RENAMES         reduce using rule 182 (attribute_id -> ID .)
    ASSIGNMENT      reduce using rule 182 (attribute_id -> ID .)
    USE             reduce using rule 182 (attribute_id -> ID .)
    AT              reduce using rule 182 (attribute_id -> ID .)
    WHEN            reduce using rule 182 (attribute_id -> ID .)


state 403

    (207) short_circuit -> AND THEN .

    +               reduce using rule 207 (short_circuit -> AND THEN .)
    -               reduce using rule 207 (short_circuit -> AND THEN .)
    NOT             reduce using rule 207 (short_circuit -> AND THEN .)
    ABS             reduce using rule 207 (short_circuit -> AND THEN .)
    NuLL            reduce using rule 207 (short_circuit -> AND THEN .)
    NEW             reduce using rule 207 (short_circuit -> AND THEN .)
    (               reduce using rule 207 (short_circuit -> AND THEN .)
    NUMLITERAL_BASE_INT reduce using rule 207 (short_circuit -> AND THEN .)
    NUMLITERAL_BASE_FLOAT reduce using rule 207 (short_circuit -> AND THEN .)
    NUMLITERAL_INT  reduce using rule 207 (short_circuit -> AND THEN .)
    NUMLITERAL_FLOAT reduce using rule 207 (short_circuit -> AND THEN .)
    CHARLITERAL     reduce using rule 207 (short_circuit -> AND THEN .)
    ID              reduce using rule 207 (short_circuit -> AND THEN .)
    STRLITERAL      reduce using rule 207 (short_circuit -> AND THEN .)


state 404

    (202) expression -> expression logical m . relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 538
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149

state 405

    (203) expression -> expression short_circuit m . relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 539
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149

state 406

    (208) short_circuit -> OR ELSE .

    +               reduce using rule 208 (short_circuit -> OR ELSE .)
    -               reduce using rule 208 (short_circuit -> OR ELSE .)
    NOT             reduce using rule 208 (short_circuit -> OR ELSE .)
    ABS             reduce using rule 208 (short_circuit -> OR ELSE .)
    NuLL            reduce using rule 208 (short_circuit -> OR ELSE .)
    NEW             reduce using rule 208 (short_circuit -> OR ELSE .)
    (               reduce using rule 208 (short_circuit -> OR ELSE .)
    NUMLITERAL_BASE_INT reduce using rule 208 (short_circuit -> OR ELSE .)
    NUMLITERAL_BASE_FLOAT reduce using rule 208 (short_circuit -> OR ELSE .)
    NUMLITERAL_INT  reduce using rule 208 (short_circuit -> OR ELSE .)
    NUMLITERAL_FLOAT reduce using rule 208 (short_circuit -> OR ELSE .)
    CHARLITERAL     reduce using rule 208 (short_circuit -> OR ELSE .)
    ID              reduce using rule 208 (short_circuit -> OR ELSE .)
    STRLITERAL      reduce using rule 208 (short_circuit -> OR ELSE .)


state 407

    (357) name_s -> name_s , name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    ;               reduce using rule 357 (name_s -> name_s , name .)
    ,               reduce using rule 357 (name_s -> name_s , name .)
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 408

    (355) use_clause -> USE TYPE name_s ; .

    TASK            reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    PROTECTED       reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    error           reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    USE             reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    PRAGMA          reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    PACKAGE         reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    TYPE            reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    SUBTYPE         reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    FOR             reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    PROCEDURE       reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    FUNCTION        reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    GENERIC         reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    ID              reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    BEGIN           reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    END             reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    WITH            reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    PRIVATE         reduce using rule 355 (use_clause -> USE TYPE name_s ; .)
    SEPARATE        reduce using rule 355 (use_clause -> USE TYPE name_s ; .)


state 409

    (455) subunit_body -> subprog_body .

    PRAGMA          reduce using rule 455 (subunit_body -> subprog_body .)
    PRIVATE         reduce using rule 455 (subunit_body -> subprog_body .)
    WITH            reduce using rule 455 (subunit_body -> subprog_body .)
    SEPARATE        reduce using rule 455 (subunit_body -> subprog_body .)
    PACKAGE         reduce using rule 455 (subunit_body -> subprog_body .)
    GENERIC         reduce using rule 455 (subunit_body -> subprog_body .)
    PROCEDURE       reduce using rule 455 (subunit_body -> subprog_body .)
    FUNCTION        reduce using rule 455 (subunit_body -> subprog_body .)
    $end            reduce using rule 455 (subunit_body -> subprog_body .)


state 410

    (457) subunit_body -> task_body .

    PRAGMA          reduce using rule 457 (subunit_body -> task_body .)
    PRIVATE         reduce using rule 457 (subunit_body -> task_body .)
    WITH            reduce using rule 457 (subunit_body -> task_body .)
    SEPARATE        reduce using rule 457 (subunit_body -> task_body .)
    PACKAGE         reduce using rule 457 (subunit_body -> task_body .)
    GENERIC         reduce using rule 457 (subunit_body -> task_body .)
    PROCEDURE       reduce using rule 457 (subunit_body -> task_body .)
    FUNCTION        reduce using rule 457 (subunit_body -> task_body .)
    $end            reduce using rule 457 (subunit_body -> task_body .)


state 411

    (390) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt ;

    BODY            shift and go to state 540


state 412

    (454) subunit -> SEPARATE ( compound_name ) subunit_body .

    PRAGMA          reduce using rule 454 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PRIVATE         reduce using rule 454 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    WITH            reduce using rule 454 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    SEPARATE        reduce using rule 454 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PACKAGE         reduce using rule 454 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    GENERIC         reduce using rule 454 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PROCEDURE       reduce using rule 454 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    FUNCTION        reduce using rule 454 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    $end            reduce using rule 454 (subunit -> SEPARATE ( compound_name ) subunit_body .)


state 413

    (373) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt ;

    BODY            shift and go to state 541


state 414

    (337) subprog_spec_is_push -> subprog_spec . IS

    IS              shift and go to state 542


state 415

    (347) pkg_start -> PACKAGE . BODY compound_name IS

    BODY            shift and go to state 98


state 416

    (338) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (348) pkg_body -> . pkg_start decl_part body_opt END c_id_opt ;
    (373) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (390) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (337) subprog_spec_is_push -> . subprog_spec IS
    (347) pkg_start -> . PACKAGE BODY compound_name IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (26) def_id -> . ID

    BEGIN           reduce using rule 137 (decl_part -> .)
    TASK            shift and go to state 68
    PROTECTED       shift and go to state 52
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    PACKAGE         shift and go to state 73
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 64
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    GENERIC         shift and go to state 21
    ID              shift and go to state 91

    decl                           shift and go to state 51
    subprog_body                   shift and go to state 60
    task_decl                      shift and go to state 61
    type_decl                      shift and go to state 57
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 62
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    subprog_spec_is_push           shift and go to state 24
    decl_part                      shift and go to state 55
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    def_id                         shift and go to state 88
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 86
    def_id_s                       shift and go to state 87
    decl_item_or_body_s1           shift and go to state 72
    decl_item                      shift and go to state 54
    task_spec                      shift and go to state 66
    body                           shift and go to state 63
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    pkg_spec                       shift and go to state 38
    rename_decl                    shift and go to state 89
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 75
    rename_unit                    shift and go to state 90
    generic_formal_part            shift and go to state 34
    subprog_decl                   shift and go to state 59
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    pkg_start                      shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 417

    (458) subunit_body -> prot_body .

    PRAGMA          reduce using rule 458 (subunit_body -> prot_body .)
    PRIVATE         reduce using rule 458 (subunit_body -> prot_body .)
    WITH            reduce using rule 458 (subunit_body -> prot_body .)
    SEPARATE        reduce using rule 458 (subunit_body -> prot_body .)
    PACKAGE         reduce using rule 458 (subunit_body -> prot_body .)
    GENERIC         reduce using rule 458 (subunit_body -> prot_body .)
    PROCEDURE       reduce using rule 458 (subunit_body -> prot_body .)
    FUNCTION        reduce using rule 458 (subunit_body -> prot_body .)
    $end            reduce using rule 458 (subunit_body -> prot_body .)


state 418

    (456) subunit_body -> pkg_body .

    PRAGMA          reduce using rule 456 (subunit_body -> pkg_body .)
    PRIVATE         reduce using rule 456 (subunit_body -> pkg_body .)
    WITH            reduce using rule 456 (subunit_body -> pkg_body .)
    SEPARATE        reduce using rule 456 (subunit_body -> pkg_body .)
    PACKAGE         reduce using rule 456 (subunit_body -> pkg_body .)
    GENERIC         reduce using rule 456 (subunit_body -> pkg_body .)
    PROCEDURE       reduce using rule 456 (subunit_body -> pkg_body .)
    FUNCTION        reduce using rule 456 (subunit_body -> pkg_body .)
    $end            reduce using rule 456 (subunit_body -> pkg_body .)


state 419

    (390) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt ;
    (462) body_stub -> PROTECTED BODY simple_name IS . SEPARATE ;
    (391) prot_op_body_s -> . pragma_s
    (392) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    SEPARATE        shift and go to state 543
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    prot_op_body_s                 shift and go to state 544
    pragma_s                       shift and go to state 545

state 420

    (376) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt . prot_def
    (377) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt

    IS              shift and go to state 265

    prot_def                       shift and go to state 546

state 421

    (377) prot_def -> IS prot_op_decl_s . prot_private_opt END id_opt
    (381) prot_op_decl_s -> prot_op_decl_s . prot_op_decl
    (378) prot_private_opt -> .
    (379) prot_private_opt -> . PRIVATE prot_elem_decl_s
    (382) prot_op_decl -> . entry_decl
    (383) prot_op_decl -> . subprog_spec ;
    (384) prot_op_decl -> . rep_spec
    (385) prot_op_decl -> . pragma
    (398) entry_decl -> . ENTRY ID formal_part_opt ;
    (399) entry_decl -> . ENTRY ID ( discrete_range ) formal_part_opt ;
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 378 (prot_private_opt -> .)
    PRIVATE         shift and go to state 549
    ENTRY           shift and go to state 553
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    PRAGMA          shift and go to state 4
    FOR             shift and go to state 64

    rep_spec                       shift and go to state 547
    entry_decl                     shift and go to state 548
    address_spec                   shift and go to state 53
    record_type_spec               shift and go to state 69
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 550
    prot_private_opt               shift and go to state 551
    pragma                         shift and go to state 552
    prot_op_decl                   shift and go to state 554

state 422

    (413) delay_stmt -> DELAY UNTIL . expression ;
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 555

state 423

    (412) delay_stmt -> DELAY expression . ;
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ;               shift and go to state 556
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 424

    (295) iteration -> iter_part . reverse_opt discrete_range
    (297) reverse_opt -> .
    (298) reverse_opt -> . REVERSE

    ID              reduce using rule 297 (reverse_opt -> .)
    STRLITERAL      reduce using rule 297 (reverse_opt -> .)
    +               reduce using rule 297 (reverse_opt -> .)
    -               reduce using rule 297 (reverse_opt -> .)
    NOT             reduce using rule 297 (reverse_opt -> .)
    ABS             reduce using rule 297 (reverse_opt -> .)
    NuLL            reduce using rule 297 (reverse_opt -> .)
    NEW             reduce using rule 297 (reverse_opt -> .)
    (               reduce using rule 297 (reverse_opt -> .)
    NUMLITERAL_BASE_INT reduce using rule 297 (reverse_opt -> .)
    NUMLITERAL_BASE_FLOAT reduce using rule 297 (reverse_opt -> .)
    NUMLITERAL_INT  reduce using rule 297 (reverse_opt -> .)
    NUMLITERAL_FLOAT reduce using rule 297 (reverse_opt -> .)
    CHARLITERAL     reduce using rule 297 (reverse_opt -> .)
    REVERSE         shift and go to state 558

    reverse_opt                    shift and go to state 557

state 425

    (296) iter_part -> FOR . ID IN

    ID              shift and go to state 559


state 426

    (290) loop_stmt -> label_opt iteration . m basic_loop id_opt ;
    (519) m -> .

    LOOP            reduce using rule 519 (m -> .)

    m                              shift and go to state 560

state 427

    (302) block -> label_opt block_decl . block_body END id_opt ;
    (305) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 165

    block_body                     shift and go to state 561

state 428

    (294) iteration -> WHILE . m condition
    (519) m -> .

    +               reduce using rule 519 (m -> .)
    -               reduce using rule 519 (m -> .)
    NOT             reduce using rule 519 (m -> .)
    ABS             reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    NEW             reduce using rule 519 (m -> .)
    (               reduce using rule 519 (m -> .)
    NUMLITERAL_BASE_INT reduce using rule 519 (m -> .)
    NUMLITERAL_BASE_FLOAT reduce using rule 519 (m -> .)
    NUMLITERAL_INT  reduce using rule 519 (m -> .)
    NUMLITERAL_FLOAT reduce using rule 519 (m -> .)
    CHARLITERAL     reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)

    m                              shift and go to state 562

state 429

    (304) block_decl -> DECLARE . decl_part
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (348) pkg_body -> . pkg_start decl_part body_opt END c_id_opt ;
    (373) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (390) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (337) subprog_spec_is_push -> . subprog_spec IS
    (347) pkg_start -> . PACKAGE BODY compound_name IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (26) def_id -> . ID

    BEGIN           reduce using rule 137 (decl_part -> .)
    TASK            shift and go to state 68
    PROTECTED       shift and go to state 52
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    PACKAGE         shift and go to state 73
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 64
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    GENERIC         shift and go to state 21
    ID              shift and go to state 91

    decl                           shift and go to state 51
    subprog_body                   shift and go to state 60
    task_decl                      shift and go to state 61
    type_decl                      shift and go to state 57
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 62
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    subprog_spec_is_push           shift and go to state 24
    decl_part                      shift and go to state 563
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    def_id                         shift and go to state 88
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 86
    def_id_s                       shift and go to state 87
    decl_item_or_body_s1           shift and go to state 72
    decl_item                      shift and go to state 54
    task_spec                      shift and go to state 66
    body                           shift and go to state 63
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    pkg_spec                       shift and go to state 38
    rename_decl                    shift and go to state 89
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 75
    rename_unit                    shift and go to state 90
    generic_formal_part            shift and go to state 34
    subprog_decl                   shift and go to state 59
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    pkg_start                      shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 430

    (316) goto_stmt -> GOTO name . ;
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    ;               shift and go to state 564
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 431

    (518) code_stmt -> qualified ; .

    LEFTLABEL       reduce using rule 518 (code_stmt -> qualified ; .)
    error           reduce using rule 518 (code_stmt -> qualified ; .)
    PRAGMA          reduce using rule 518 (code_stmt -> qualified ; .)
    NuLL            reduce using rule 518 (code_stmt -> qualified ; .)
    EXIT            reduce using rule 518 (code_stmt -> qualified ; .)
    RETURN          reduce using rule 518 (code_stmt -> qualified ; .)
    GOTO            reduce using rule 518 (code_stmt -> qualified ; .)
    DELAY           reduce using rule 518 (code_stmt -> qualified ; .)
    ABORT           reduce using rule 518 (code_stmt -> qualified ; .)
    RAISE           reduce using rule 518 (code_stmt -> qualified ; .)
    REQUEUE         reduce using rule 518 (code_stmt -> qualified ; .)
    IF              reduce using rule 518 (code_stmt -> qualified ; .)
    CASE            reduce using rule 518 (code_stmt -> qualified ; .)
    ID              reduce using rule 518 (code_stmt -> qualified ; .)
    ACCEPT          reduce using rule 518 (code_stmt -> qualified ; .)
    SELECT          reduce using rule 518 (code_stmt -> qualified ; .)
    STRLITERAL      reduce using rule 518 (code_stmt -> qualified ; .)
    WHILE           reduce using rule 518 (code_stmt -> qualified ; .)
    DECLARE         reduce using rule 518 (code_stmt -> qualified ; .)
    FOR             reduce using rule 518 (code_stmt -> qualified ; .)
    LOOP            reduce using rule 518 (code_stmt -> qualified ; .)
    BEGIN           reduce using rule 518 (code_stmt -> qualified ; .)
    END             reduce using rule 518 (code_stmt -> qualified ; .)
    ELSIF           reduce using rule 518 (code_stmt -> qualified ; .)
    ELSE            reduce using rule 518 (code_stmt -> qualified ; .)
    EXCEPTION       reduce using rule 518 (code_stmt -> qualified ; .)
    OR              reduce using rule 518 (code_stmt -> qualified ; .)
    THEN            reduce using rule 518 (code_stmt -> qualified ; .)
    WHEN            reduce using rule 518 (code_stmt -> qualified ; .)


state 432

    (276) assign_stmt -> name ASSIGNMENT . expression ;
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 565

state 433

    (339) procedure_call -> name ; .

    END             reduce using rule 339 (procedure_call -> name ; .)
    LEFTLABEL       reduce using rule 339 (procedure_call -> name ; .)
    error           reduce using rule 339 (procedure_call -> name ; .)
    PRAGMA          reduce using rule 339 (procedure_call -> name ; .)
    NuLL            reduce using rule 339 (procedure_call -> name ; .)
    EXIT            reduce using rule 339 (procedure_call -> name ; .)
    RETURN          reduce using rule 339 (procedure_call -> name ; .)
    GOTO            reduce using rule 339 (procedure_call -> name ; .)
    DELAY           reduce using rule 339 (procedure_call -> name ; .)
    ABORT           reduce using rule 339 (procedure_call -> name ; .)
    RAISE           reduce using rule 339 (procedure_call -> name ; .)
    REQUEUE         reduce using rule 339 (procedure_call -> name ; .)
    IF              reduce using rule 339 (procedure_call -> name ; .)
    CASE            reduce using rule 339 (procedure_call -> name ; .)
    ID              reduce using rule 339 (procedure_call -> name ; .)
    ACCEPT          reduce using rule 339 (procedure_call -> name ; .)
    SELECT          reduce using rule 339 (procedure_call -> name ; .)
    STRLITERAL      reduce using rule 339 (procedure_call -> name ; .)
    WHILE           reduce using rule 339 (procedure_call -> name ; .)
    DECLARE         reduce using rule 339 (procedure_call -> name ; .)
    FOR             reduce using rule 339 (procedure_call -> name ; .)
    LOOP            reduce using rule 339 (procedure_call -> name ; .)
    BEGIN           reduce using rule 339 (procedure_call -> name ; .)
    WHEN            reduce using rule 339 (procedure_call -> name ; .)
    EXCEPTION       reduce using rule 339 (procedure_call -> name ; .)
    ELSIF           reduce using rule 339 (procedure_call -> name ; .)
    ELSE            reduce using rule 339 (procedure_call -> name ; .)
    THEN            reduce using rule 339 (procedure_call -> name ; .)
    OR              reduce using rule 339 (procedure_call -> name ; .)


state 434

    (433) abort_stmt -> ABORT name_s . ;
    (357) name_s -> name_s . , name

    ;               shift and go to state 566
    ,               shift and go to state 259


state 435

    (275) null_stmt -> NuLL ; .

    EXCEPTION       reduce using rule 275 (null_stmt -> NuLL ; .)
    LEFTLABEL       reduce using rule 275 (null_stmt -> NuLL ; .)
    error           reduce using rule 275 (null_stmt -> NuLL ; .)
    PRAGMA          reduce using rule 275 (null_stmt -> NuLL ; .)
    NuLL            reduce using rule 275 (null_stmt -> NuLL ; .)
    EXIT            reduce using rule 275 (null_stmt -> NuLL ; .)
    RETURN          reduce using rule 275 (null_stmt -> NuLL ; .)
    GOTO            reduce using rule 275 (null_stmt -> NuLL ; .)
    DELAY           reduce using rule 275 (null_stmt -> NuLL ; .)
    ABORT           reduce using rule 275 (null_stmt -> NuLL ; .)
    RAISE           reduce using rule 275 (null_stmt -> NuLL ; .)
    REQUEUE         reduce using rule 275 (null_stmt -> NuLL ; .)
    IF              reduce using rule 275 (null_stmt -> NuLL ; .)
    CASE            reduce using rule 275 (null_stmt -> NuLL ; .)
    ID              reduce using rule 275 (null_stmt -> NuLL ; .)
    ACCEPT          reduce using rule 275 (null_stmt -> NuLL ; .)
    SELECT          reduce using rule 275 (null_stmt -> NuLL ; .)
    STRLITERAL      reduce using rule 275 (null_stmt -> NuLL ; .)
    WHILE           reduce using rule 275 (null_stmt -> NuLL ; .)
    DECLARE         reduce using rule 275 (null_stmt -> NuLL ; .)
    FOR             reduce using rule 275 (null_stmt -> NuLL ; .)
    LOOP            reduce using rule 275 (null_stmt -> NuLL ; .)
    BEGIN           reduce using rule 275 (null_stmt -> NuLL ; .)
    END             reduce using rule 275 (null_stmt -> NuLL ; .)
    OR              reduce using rule 275 (null_stmt -> NuLL ; .)
    ELSE            reduce using rule 275 (null_stmt -> NuLL ; .)
    THEN            reduce using rule 275 (null_stmt -> NuLL ; .)
    ELSIF           reduce using rule 275 (null_stmt -> NuLL ; .)
    WHEN            reduce using rule 275 (null_stmt -> NuLL ; .)


state 436

    (314) return_stmt -> RETURN ; .

    EXCEPTION       reduce using rule 314 (return_stmt -> RETURN ; .)
    LEFTLABEL       reduce using rule 314 (return_stmt -> RETURN ; .)
    error           reduce using rule 314 (return_stmt -> RETURN ; .)
    PRAGMA          reduce using rule 314 (return_stmt -> RETURN ; .)
    NuLL            reduce using rule 314 (return_stmt -> RETURN ; .)
    EXIT            reduce using rule 314 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 314 (return_stmt -> RETURN ; .)
    GOTO            reduce using rule 314 (return_stmt -> RETURN ; .)
    DELAY           reduce using rule 314 (return_stmt -> RETURN ; .)
    ABORT           reduce using rule 314 (return_stmt -> RETURN ; .)
    RAISE           reduce using rule 314 (return_stmt -> RETURN ; .)
    REQUEUE         reduce using rule 314 (return_stmt -> RETURN ; .)
    IF              reduce using rule 314 (return_stmt -> RETURN ; .)
    CASE            reduce using rule 314 (return_stmt -> RETURN ; .)
    ID              reduce using rule 314 (return_stmt -> RETURN ; .)
    ACCEPT          reduce using rule 314 (return_stmt -> RETURN ; .)
    SELECT          reduce using rule 314 (return_stmt -> RETURN ; .)
    STRLITERAL      reduce using rule 314 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 314 (return_stmt -> RETURN ; .)
    DECLARE         reduce using rule 314 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 314 (return_stmt -> RETURN ; .)
    LOOP            reduce using rule 314 (return_stmt -> RETURN ; .)
    BEGIN           reduce using rule 314 (return_stmt -> RETURN ; .)
    END             reduce using rule 314 (return_stmt -> RETURN ; .)
    OR              reduce using rule 314 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 314 (return_stmt -> RETURN ; .)
    THEN            reduce using rule 314 (return_stmt -> RETURN ; .)
    ELSIF           reduce using rule 314 (return_stmt -> RETURN ; .)
    WHEN            reduce using rule 314 (return_stmt -> RETURN ; .)


state 437

    (315) return_stmt -> RETURN expression . ;
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ;               shift and go to state 567
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 438

    (409) accept_hdr -> ACCEPT entry_name . formal_part_opt
    (411) entry_name -> entry_name . ( expression )
    (325) formal_part_opt -> .
    (326) formal_part_opt -> . formal_part
    (327) formal_part -> . ( param_s )

    (               shift and go to state 568
    ;               reduce using rule 325 (formal_part_opt -> .)
    DO              reduce using rule 325 (formal_part_opt -> .)

    formal_part                    shift and go to state 191
    formal_part_opt                shift and go to state 569

state 439

    (410) entry_name -> simple_name .

    (               reduce using rule 410 (entry_name -> simple_name .)
    ;               reduce using rule 410 (entry_name -> simple_name .)
    DO              reduce using rule 410 (entry_name -> simple_name .)


state 440

    (423) select_alt -> accept_stmt . stmts_opt
    (431) stmts_opt -> .
    (432) stmts_opt -> . statement_s
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    OR              reduce using rule 431 (stmts_opt -> .)
    ELSE            reduce using rule 431 (stmts_opt -> .)
    END             reduce using rule 431 (stmts_opt -> .)
    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 571
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    stmts_opt                      shift and go to state 570
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 441

    (429) timed_entry_call -> SELECT entry_call . stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> SELECT entry_call . stmts_opt ELSE statement_s END SELECT ;
    (427) delay_or_entry_alt -> entry_call . stmts_opt
    (431) stmts_opt -> .
    (432) stmts_opt -> . statement_s
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    OR              reduce using rule 431 (stmts_opt -> .)
    ELSE            reduce using rule 431 (stmts_opt -> .)
    THEN            reduce using rule 431 (stmts_opt -> .)
    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 571
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    stmts_opt                      shift and go to state 572
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 442

    (406) entry_call -> procedure_call .

    LEFTLABEL       reduce using rule 406 (entry_call -> procedure_call .)
    error           reduce using rule 406 (entry_call -> procedure_call .)
    PRAGMA          reduce using rule 406 (entry_call -> procedure_call .)
    NuLL            reduce using rule 406 (entry_call -> procedure_call .)
    EXIT            reduce using rule 406 (entry_call -> procedure_call .)
    RETURN          reduce using rule 406 (entry_call -> procedure_call .)
    GOTO            reduce using rule 406 (entry_call -> procedure_call .)
    DELAY           reduce using rule 406 (entry_call -> procedure_call .)
    ABORT           reduce using rule 406 (entry_call -> procedure_call .)
    RAISE           reduce using rule 406 (entry_call -> procedure_call .)
    REQUEUE         reduce using rule 406 (entry_call -> procedure_call .)
    IF              reduce using rule 406 (entry_call -> procedure_call .)
    CASE            reduce using rule 406 (entry_call -> procedure_call .)
    ID              reduce using rule 406 (entry_call -> procedure_call .)
    ACCEPT          reduce using rule 406 (entry_call -> procedure_call .)
    SELECT          reduce using rule 406 (entry_call -> procedure_call .)
    STRLITERAL      reduce using rule 406 (entry_call -> procedure_call .)
    OR              reduce using rule 406 (entry_call -> procedure_call .)
    ELSE            reduce using rule 406 (entry_call -> procedure_call .)
    WHILE           reduce using rule 406 (entry_call -> procedure_call .)
    DECLARE         reduce using rule 406 (entry_call -> procedure_call .)
    FOR             reduce using rule 406 (entry_call -> procedure_call .)
    LOOP            reduce using rule 406 (entry_call -> procedure_call .)
    BEGIN           reduce using rule 406 (entry_call -> procedure_call .)
    THEN            reduce using rule 406 (entry_call -> procedure_call .)


state 443

    (428) async_select -> SELECT delay_or_entry_alt . THEN ABORT statement_s END SELECT ;

    THEN            shift and go to state 573


state 444

    (420) guarded_select_alt -> WHEN . condition ARROW select_alt
    (282) condition -> . expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    condition                      shift and go to state 574
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 470

state 445

    (418) select_wait -> SELECT guarded_select_alt . or_select else_opt END SELECT ;
    (421) or_select -> .
    (422) or_select -> . or_select OR guarded_select_alt

    OR              reduce using rule 421 (or_select -> .)
    ELSE            reduce using rule 421 (or_select -> .)
    END             reduce using rule 421 (or_select -> .)

    or_select                      shift and go to state 575

state 446

    (419) guarded_select_alt -> select_alt .

    OR              reduce using rule 419 (guarded_select_alt -> select_alt .)
    ELSE            reduce using rule 419 (guarded_select_alt -> select_alt .)
    END             reduce using rule 419 (guarded_select_alt -> select_alt .)


state 447

    (426) delay_or_entry_alt -> delay_stmt . stmts_opt
    (424) select_alt -> delay_stmt . stmts_opt
    (431) stmts_opt -> .
    (432) stmts_opt -> . statement_s
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    THEN            reduce using rule 431 (stmts_opt -> .)
    OR              reduce using rule 431 (stmts_opt -> .)
    ELSE            reduce using rule 431 (stmts_opt -> .)
    END             reduce using rule 431 (stmts_opt -> .)
    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 571
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    stmts_opt                      shift and go to state 576
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 448

    (339) procedure_call -> name . ;
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    ;               shift and go to state 433
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 449

    (425) select_alt -> TERMINATE . ;

    ;               shift and go to state 577


state 450

    (252) statement -> label statement .

    LEFTLABEL       reduce using rule 252 (statement -> label statement .)
    error           reduce using rule 252 (statement -> label statement .)
    PRAGMA          reduce using rule 252 (statement -> label statement .)
    NuLL            reduce using rule 252 (statement -> label statement .)
    EXIT            reduce using rule 252 (statement -> label statement .)
    RETURN          reduce using rule 252 (statement -> label statement .)
    GOTO            reduce using rule 252 (statement -> label statement .)
    DELAY           reduce using rule 252 (statement -> label statement .)
    ABORT           reduce using rule 252 (statement -> label statement .)
    RAISE           reduce using rule 252 (statement -> label statement .)
    REQUEUE         reduce using rule 252 (statement -> label statement .)
    IF              reduce using rule 252 (statement -> label statement .)
    CASE            reduce using rule 252 (statement -> label statement .)
    ID              reduce using rule 252 (statement -> label statement .)
    ACCEPT          reduce using rule 252 (statement -> label statement .)
    SELECT          reduce using rule 252 (statement -> label statement .)
    STRLITERAL      reduce using rule 252 (statement -> label statement .)
    WHILE           reduce using rule 252 (statement -> label statement .)
    DECLARE         reduce using rule 252 (statement -> label statement .)
    FOR             reduce using rule 252 (statement -> label statement .)
    LOOP            reduce using rule 252 (statement -> label statement .)
    BEGIN           reduce using rule 252 (statement -> label statement .)
    OR              reduce using rule 252 (statement -> label statement .)
    ELSE            reduce using rule 252 (statement -> label statement .)
    THEN            reduce using rule 252 (statement -> label statement .)
    END             reduce using rule 252 (statement -> label statement .)
    WHEN            reduce using rule 252 (statement -> label statement .)
    EXCEPTION       reduce using rule 252 (statement -> label statement .)
    ELSIF           reduce using rule 252 (statement -> label statement .)


state 451

    (285) case_stmt -> case_hdr pragma_s . alternative_s END CASE ;
    (9) pragma_s -> pragma_s . pragma
    (287) alternative_s -> .
    (288) alternative_s -> . alternative_s alternative
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 287 (alternative_s -> .)
    WHEN            reduce using rule 287 (alternative_s -> .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14
    alternative_s                  shift and go to state 578

state 452

    (311) name_opt -> name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    WHEN            reduce using rule 311 (name_opt -> name .)
    ;               reduce using rule 311 (name_opt -> name .)
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 453

    (472) raise_stmt -> RAISE name_opt . ;

    ;               shift and go to state 579


state 454

    (286) case_hdr -> CASE expression . IS
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    IS              shift and go to state 580
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 455

    (473) requeue_stmt -> REQUEUE name . ;
    (474) requeue_stmt -> REQUEUE name . WITH ABORT ;
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    ;               shift and go to state 581
    WITH            shift and go to state 582
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 456

    (408) accept_stmt -> accept_hdr DO . handled_stmt_s END id_opt ;
    (306) handled_stmt_s -> . statement_s except_handler_part_opt
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    label                          shift and go to state 285
    statement_s                    shift and go to state 305
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    handled_stmt_s                 shift and go to state 583
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    assign_stmt                    shift and go to state 315
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    accept_hdr                     shift and go to state 297
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    qualified                      shift and go to state 274
    label_opt                      shift and go to state 270
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 457

    (407) accept_stmt -> accept_hdr ; .

    LEFTLABEL       reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    error           reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    PRAGMA          reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    NuLL            reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    EXIT            reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    RETURN          reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    GOTO            reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    DELAY           reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    ABORT           reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    RAISE           reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    REQUEUE         reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    IF              reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    CASE            reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    ID              reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    ACCEPT          reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    SELECT          reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    STRLITERAL      reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    WHILE           reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    DECLARE         reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    FOR             reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    LOOP            reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    BEGIN           reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    OR              reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    ELSE            reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    END             reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    EXCEPTION       reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    THEN            reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    ELSIF           reduce using rule 407 (accept_stmt -> accept_hdr ; .)
    WHEN            reduce using rule 407 (accept_stmt -> accept_hdr ; .)


state 458

    (309) exit_stmt -> EXIT name_opt . when_opt ;
    (312) when_opt -> .
    (313) when_opt -> . WHEN condition

    ;               reduce using rule 312 (when_opt -> .)
    WHEN            shift and go to state 585

    when_opt                       shift and go to state 584

state 459

    (267) simple_stmt -> error ; .

    END             reduce using rule 267 (simple_stmt -> error ; .)
    LEFTLABEL       reduce using rule 267 (simple_stmt -> error ; .)
    error           reduce using rule 267 (simple_stmt -> error ; .)
    PRAGMA          reduce using rule 267 (simple_stmt -> error ; .)
    NuLL            reduce using rule 267 (simple_stmt -> error ; .)
    EXIT            reduce using rule 267 (simple_stmt -> error ; .)
    RETURN          reduce using rule 267 (simple_stmt -> error ; .)
    GOTO            reduce using rule 267 (simple_stmt -> error ; .)
    DELAY           reduce using rule 267 (simple_stmt -> error ; .)
    ABORT           reduce using rule 267 (simple_stmt -> error ; .)
    RAISE           reduce using rule 267 (simple_stmt -> error ; .)
    REQUEUE         reduce using rule 267 (simple_stmt -> error ; .)
    IF              reduce using rule 267 (simple_stmt -> error ; .)
    CASE            reduce using rule 267 (simple_stmt -> error ; .)
    ID              reduce using rule 267 (simple_stmt -> error ; .)
    ACCEPT          reduce using rule 267 (simple_stmt -> error ; .)
    SELECT          reduce using rule 267 (simple_stmt -> error ; .)
    STRLITERAL      reduce using rule 267 (simple_stmt -> error ; .)
    WHILE           reduce using rule 267 (simple_stmt -> error ; .)
    DECLARE         reduce using rule 267 (simple_stmt -> error ; .)
    FOR             reduce using rule 267 (simple_stmt -> error ; .)
    LOOP            reduce using rule 267 (simple_stmt -> error ; .)
    BEGIN           reduce using rule 267 (simple_stmt -> error ; .)
    EXCEPTION       reduce using rule 267 (simple_stmt -> error ; .)
    OR              reduce using rule 267 (simple_stmt -> error ; .)
    ELSE            reduce using rule 267 (simple_stmt -> error ; .)
    THEN            reduce using rule 267 (simple_stmt -> error ; .)
    ELSIF           reduce using rule 267 (simple_stmt -> error ; .)
    WHEN            reduce using rule 267 (simple_stmt -> error ; .)


state 460

    (464) except_handler_part -> EXCEPTION . exception_handler
    (466) exception_handler -> . WHEN except_choice_s ARROW statement_s
    (467) exception_handler -> . WHEN ID : except_choice_s ARROW statement_s

    WHEN            shift and go to state 587

    exception_handler              shift and go to state 586

state 461

    (250) statement_s -> statement_s m . statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 588
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 462

    (308) except_handler_part_opt -> except_handler_part .
    (465) except_handler_part -> except_handler_part . exception_handler
    (466) exception_handler -> . WHEN except_choice_s ARROW statement_s
    (467) exception_handler -> . WHEN ID : except_choice_s ARROW statement_s

    END             reduce using rule 308 (except_handler_part_opt -> except_handler_part .)
    WHEN            shift and go to state 587

    exception_handler              shift and go to state 589

state 463

    (306) handled_stmt_s -> statement_s except_handler_part_opt .

    END             reduce using rule 306 (handled_stmt_s -> statement_s except_handler_part_opt .)


state 464

    (274) label -> LEFTLABEL ID . RIGHTLABEL

    RIGHTLABEL      shift and go to state 590


state 465

    (292) label_opt -> ID : .

    WHILE           reduce using rule 292 (label_opt -> ID : .)
    DECLARE         reduce using rule 292 (label_opt -> ID : .)
    FOR             reduce using rule 292 (label_opt -> ID : .)
    LOOP            reduce using rule 292 (label_opt -> ID : .)
    BEGIN           reduce using rule 292 (label_opt -> ID : .)


state 466

    (277) if_stmt -> IF cond_clause_s . else_opt END IF ;
    (283) else_opt -> .
    (284) else_opt -> . ELSE m statement_s

    END             reduce using rule 283 (else_opt -> .)
    ELSE            shift and go to state 591

    else_opt                       shift and go to state 592

state 467

    (278) cond_clause_s -> cond_clause .
    (279) cond_clause_s -> cond_clause . ELSIF m cond_clause_s

    ELSE            reduce using rule 278 (cond_clause_s -> cond_clause .)
    END             reduce using rule 278 (cond_clause_s -> cond_clause .)
    ELSIF           shift and go to state 593


state 468

    (280) cond_clause -> cond_part . m statement_s n
    (519) m -> .

    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)

    m                              shift and go to state 594

state 469

    (281) cond_part -> condition . THEN

    THEN            shift and go to state 595


state 470

    (282) condition -> expression .
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ARROW           reduce using rule 282 (condition -> expression .)
    THEN            reduce using rule 282 (condition -> expression .)
    ;               reduce using rule 282 (condition -> expression .)
    IS              reduce using rule 282 (condition -> expression .)
    LOOP            reduce using rule 282 (condition -> expression .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 471

    (301) id_opt -> designator .

    ;               reduce using rule 301 (id_opt -> designator .)


state 472

    (338) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt . ;

    ;               shift and go to state 596


state 473

    (512) record_type_spec -> FOR mark USE RECORD . align_opt comp_loc_s END RECORD ;
    (513) align_opt -> .
    (514) align_opt -> . AT MOD expression ;

    END             reduce using rule 513 (align_opt -> .)
    ID              reduce using rule 513 (align_opt -> .)
    AT              shift and go to state 598

    align_opt                      shift and go to state 597

state 474

    (517) address_spec -> FOR mark USE AT . expression ;
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 599

state 475

    (511) attrib_def -> FOR mark USE expression . ;
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ;               shift and go to state 600
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 476

    (161) mark -> mark SINGLEQUOTE attribute_id .

    USE             reduce using rule 161 (mark -> mark SINGLEQUOTE attribute_id .)
    SINGLEQUOTE     reduce using rule 161 (mark -> mark SINGLEQUOTE attribute_id .)
    .               reduce using rule 161 (mark -> mark SINGLEQUOTE attribute_id .)
    ;               reduce using rule 161 (mark -> mark SINGLEQUOTE attribute_id .)
    ASSIGNMENT      reduce using rule 161 (mark -> mark SINGLEQUOTE attribute_id .)
    )               reduce using rule 161 (mark -> mark SINGLEQUOTE attribute_id .)
    AT              reduce using rule 161 (mark -> mark SINGLEQUOTE attribute_id .)


state 477

    (162) mark -> mark . simple_name .

    USE             reduce using rule 162 (mark -> mark . simple_name .)
    SINGLEQUOTE     reduce using rule 162 (mark -> mark . simple_name .)
    .               reduce using rule 162 (mark -> mark . simple_name .)
    ;               reduce using rule 162 (mark -> mark . simple_name .)
    ASSIGNMENT      reduce using rule 162 (mark -> mark . simple_name .)
    )               reduce using rule 162 (mark -> mark . simple_name .)
    AT              reduce using rule 162 (mark -> mark . simple_name .)


state 478

    (373) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt ;
    (459) body_stub -> TASK BODY simple_name IS . SEPARATE ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (348) pkg_body -> . pkg_start decl_part body_opt END c_id_opt ;
    (373) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (390) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (337) subprog_spec_is_push -> . subprog_spec IS
    (347) pkg_start -> . PACKAGE BODY compound_name IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (26) def_id -> . ID

    SEPARATE        shift and go to state 601
    BEGIN           reduce using rule 137 (decl_part -> .)
    TASK            shift and go to state 68
    PROTECTED       shift and go to state 52
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    PACKAGE         shift and go to state 73
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 64
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    GENERIC         shift and go to state 21
    ID              shift and go to state 91

    decl                           shift and go to state 51
    subprog_body                   shift and go to state 60
    task_decl                      shift and go to state 61
    type_decl                      shift and go to state 57
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 62
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    decl_item                      shift and go to state 54
    subprog_spec_is_push           shift and go to state 24
    decl_part                      shift and go to state 602
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    def_id                         shift and go to state 88
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 86
    def_id_s                       shift and go to state 87
    decl_item_or_body_s1           shift and go to state 72
    task_spec                      shift and go to state 66
    body                           shift and go to state 63
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    pkg_spec                       shift and go to state 38
    rename_decl                    shift and go to state 89
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 75
    rename_unit                    shift and go to state 90
    generic_formal_part            shift and go to state 34
    subprog_decl                   shift and go to state 59
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    pkg_start                      shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 479

    (368) task_spec -> TASK TYPE simple_name discrim_part_opt . task_def
    (369) task_def -> .
    (370) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt

    ;               reduce using rule 369 (task_def -> .)
    IS              shift and go to state 322

    task_def                       shift and go to state 603

state 480

    (370) task_def -> IS entry_decl_s . rep_spec_s task_private_opt END id_opt
    (397) entry_decl_s -> entry_decl_s . entry_decl pragma_s
    (404) rep_spec_s -> .
    (405) rep_spec_s -> . rep_spec_s rep_spec pragma_s
    (398) entry_decl -> . ENTRY ID formal_part_opt ;
    (399) entry_decl -> . ENTRY ID ( discrete_range ) formal_part_opt ;

    PRIVATE         reduce using rule 404 (rep_spec_s -> .)
    FOR             reduce using rule 404 (rep_spec_s -> .)
    END             reduce using rule 404 (rep_spec_s -> .)
    ENTRY           shift and go to state 553

    rep_spec_s                     shift and go to state 604
    entry_decl                     shift and go to state 605

state 481

    (396) entry_decl_s -> pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    ENTRY           reduce using rule 396 (entry_decl_s -> pragma_s .)
    FOR             reduce using rule 396 (entry_decl_s -> pragma_s .)
    END             reduce using rule 396 (entry_decl_s -> pragma_s .)
    PRIVATE         reduce using rule 396 (entry_decl_s -> pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 482

    (347) pkg_start -> PACKAGE BODY compound_name IS .
    (460) body_stub -> PACKAGE BODY compound_name IS . SEPARATE ;

    TASK            reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    PROTECTED       reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    error           reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    USE             reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    PRAGMA          reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    PACKAGE         reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    TYPE            reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    SUBTYPE         reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    FOR             reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    PROCEDURE       reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    FUNCTION        reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    GENERIC         reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    ID              reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    BEGIN           reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    END             reduce using rule 347 (pkg_start -> PACKAGE BODY compound_name IS .)
    SEPARATE        shift and go to state 606


state 483

    (39) discrim_part_opt -> ( BOX . )

    )               shift and go to state 607


state 484

    (116) discrim_spec -> error .

    )               reduce using rule 116 (discrim_spec -> error .)
    ;               reduce using rule 116 (discrim_spec -> error .)


state 485

    (112) discrim_part -> ( discrim_spec_s . )
    (114) discrim_spec_s -> discrim_spec_s . ; discrim_spec

    )               shift and go to state 608
    ;               shift and go to state 609


state 486

    (115) discrim_spec -> def_id_s . : access_opt mark init_opt
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 610
    ,               shift and go to state 182


state 487

    (113) discrim_spec_s -> discrim_spec .

    )               reduce using rule 113 (discrim_spec_s -> discrim_spec .)
    ;               reduce using rule 113 (discrim_spec_s -> discrim_spec .)


state 488

    (41) type_completion -> IS . type_def
    (42) type_def -> . enumeration_type
    (43) type_def -> . integer_type
    (44) type_def -> . real_type
    (45) type_def -> . array_type
    (46) type_def -> . record_type
    (47) type_def -> . access_type
    (48) type_def -> . derived_type
    (49) type_def -> . private_type
    (65) enumeration_type -> . ( enum_id_s )
    (70) integer_type -> . range_spec
    (71) integer_type -> . MOD expression
    (75) real_type -> . float_type
    (76) real_type -> . fixed_type
    (80) array_type -> . unconstr_array_type
    (81) array_type -> . constr_array_type
    (97) record_type -> . tagged_opt limited_opt record_def
    (130) access_type -> . ACCESS subtype_ind
    (131) access_type -> . ACCESS CONSTANT subtype_ind
    (132) access_type -> . ACCESS ALL subtype_ind
    (133) access_type -> . ACCESS prot_opt PROCEDURE formal_part_opt
    (134) access_type -> . ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
    (56) derived_type -> . NEW subtype_ind
    (57) derived_type -> . NEW subtype_ind WITH PRIVATE
    (58) derived_type -> . NEW subtype_ind WITH record_def
    (59) derived_type -> . ABSTRACT NEW subtype_ind WITH PRIVATE
    (60) derived_type -> . ABSTRACT NEW subtype_ind WITH record_def
    (351) private_type -> . tagged_opt limited_opt PRIVATE
    (72) range_spec -> . range_constraint
    (77) float_type -> . DIGITS expression range_spec_opt
    (78) fixed_type -> . DELTA expression range_spec
    (79) fixed_type -> . DELTA expression DIGITS expression range_spec_opt
    (82) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (83) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (100) tagged_opt -> .
    (101) tagged_opt -> . TAGGED
    (102) tagged_opt -> . ABSTRACT TAGGED
    (61) range_constraint -> . RANGE range

    (               shift and go to state 620
    MOD             shift and go to state 632
    ACCESS          shift and go to state 628
    NEW             shift and go to state 616
    ABSTRACT        shift and go to state 611
    DIGITS          shift and go to state 621
    DELTA           shift and go to state 623
    ARRAY           shift and go to state 498
    LIMITED         reduce using rule 100 (tagged_opt -> .)
    PRIVATE         reduce using rule 100 (tagged_opt -> .)
    RECORD          reduce using rule 100 (tagged_opt -> .)
    NuLL            reduce using rule 100 (tagged_opt -> .)
    TAGGED          shift and go to state 622
    RANGE           shift and go to state 378

    access_type                    shift and go to state 613
    record_type                    shift and go to state 614
    real_type                      shift and go to state 615
    range_constraint               shift and go to state 612
    enumeration_type               shift and go to state 617
    private_type                   shift and go to state 618
    float_type                     shift and go to state 619
    tagged_opt                     shift and go to state 629
    integer_type                   shift and go to state 624
    array_type                     shift and go to state 625
    range_spec                     shift and go to state 626
    type_def                       shift and go to state 627
    constr_array_type              shift and go to state 500
    derived_type                   shift and go to state 630
    fixed_type                     shift and go to state 631
    unconstr_array_type            shift and go to state 502

state 489

    (36) type_decl -> TYPE ID discrim_part_opt type_completion . ;

    ;               shift and go to state 633


state 490

    (51) subtype_ind -> name . constraint
    (52) subtype_ind -> name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id
    (53) constraint -> . range_constraint
    (54) constraint -> . decimal_digits_constraint
    (61) range_constraint -> . RANGE range
    (55) decimal_digits_constraint -> . DIGITS expression range_constr_opt

    WITH            reduce using rule 52 (subtype_ind -> name .)
    ;               reduce using rule 52 (subtype_ind -> name .)
    RENAMES         reduce using rule 52 (subtype_ind -> name .)
    ASSIGNMENT      reduce using rule 52 (subtype_ind -> name .)
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260
    RANGE           shift and go to state 378
    DIGITS          shift and go to state 634

    constraint                     shift and go to state 635
    range_constraint               shift and go to state 636
    decimal_digits_constraint      shift and go to state 637

state 491

    (50) subtype_decl -> SUBTYPE ID IS subtype_ind . ;

    ;               shift and go to state 638


state 492

    (461) body_stub -> subprog_spec IS SEPARATE ; .

    error           reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    USE             reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    PRAGMA          reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    TYPE            reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    SUBTYPE         reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    TASK            reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    PACKAGE         reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    PROTECTED       reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    FOR             reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    GENERIC         reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    PROCEDURE       reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    FUNCTION        reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    ID              reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    PRIVATE         reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    END             reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)
    BEGIN           reduce using rule 461 (body_stub -> subprog_spec IS SEPARATE ; .)


state 493

    (359) rename_decl -> def_id_s : EXCEPTION renames . ;

    ;               shift and go to state 639


state 494

    (463) exception_decl -> def_id_s : EXCEPTION ; .

    TASK            reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    PROTECTED       reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    error           reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    USE             reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    PRAGMA          reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    PACKAGE         reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    TYPE            reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    SUBTYPE         reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    FOR             reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    PROCEDURE       reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    FUNCTION        reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    GENERIC         reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    ID              reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    BEGIN           reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    END             reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)
    PRIVATE         reduce using rule 463 (exception_decl -> def_id_s : EXCEPTION ; .)


state 495

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT . expression ;
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 640

state 496

    (30) object_qualifier_opt -> ALIASED CONSTANT .

    ARRAY           reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)
    ID              reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)
    STRLITERAL      reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)


state 497

    (32) object_subtype_def -> array_type .

    ASSIGNMENT      reduce using rule 32 (object_subtype_def -> array_type .)
    ;               reduce using rule 32 (object_subtype_def -> array_type .)


state 498

    (82) unconstr_array_type -> ARRAY . ( index_s ) OF component_subtype_def
    (83) constr_array_type -> ARRAY . iter_index_constraint OF component_subtype_def
    (90) iter_index_constraint -> . ( iter_discrete_range_s )

    (               shift and go to state 641

    iter_index_constraint          shift and go to state 642

state 499

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def . init_opt ;
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 643

    init_opt                       shift and go to state 644

state 500

    (81) array_type -> constr_array_type .

    ;               reduce using rule 81 (array_type -> constr_array_type .)
    ASSIGNMENT      reduce using rule 81 (array_type -> constr_array_type .)


state 501

    (358) rename_decl -> def_id_s : object_qualifier_opt subtype_ind . renames ;
    (31) object_subtype_def -> subtype_ind .
    (365) renames -> . RENAMES name

    ASSIGNMENT      reduce using rule 31 (object_subtype_def -> subtype_ind .)
    ;               reduce using rule 31 (object_subtype_def -> subtype_ind .)
    RENAMES         shift and go to state 95

    renames                        shift and go to state 645

state 502

    (80) array_type -> unconstr_array_type .

    ;               reduce using rule 80 (array_type -> unconstr_array_type .)
    ASSIGNMENT      reduce using rule 80 (array_type -> unconstr_array_type .)


state 503

    (142) decl_item_s1 -> decl_item_s1 decl_item .

    error           reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    USE             reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    PRAGMA          reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    TYPE            reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    SUBTYPE         reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    TASK            reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    PACKAGE         reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    PROTECTED       reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    FOR             reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    GENERIC         reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    PROCEDURE       reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    FUNCTION        reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    ID              reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    PRIVATE         reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    END             reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)


state 504

    (462) body_stub -> PROTECTED BODY . simple_name IS SEPARATE ;
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 646

state 505

    (344) private_part -> PRIVATE . decl_item_s
    (139) decl_item_s -> .
    (140) decl_item_s -> . decl_item_s1
    (141) decl_item_s1 -> . decl_item
    (142) decl_item_s1 -> . decl_item_s1 decl_item
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) subprog_spec_is_push -> . subprog_spec IS
    (26) def_id -> . ID

    END             reduce using rule 139 (decl_item_s -> .)
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 343
    PACKAGE         shift and go to state 344
    PROTECTED       shift and go to state 340
    FOR             shift and go to state 64
    GENERIC         shift and go to state 21
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    ID              shift and go to state 91

    decl                           shift and go to state 51
    task_decl                      shift and go to state 61
    subtype_decl                   shift and go to state 62
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 339
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    decl_item                      shift and go to state 341
    subprog_spec_is_push           shift and go to state 345
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 346
    def_id_s                       shift and go to state 87
    task_spec                      shift and go to state 66
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 88
    rename_decl                    shift and go to state 89
    type_decl                      shift and go to state 57
    rename_unit                    shift and go to state 90
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    generic_formal_part            shift and go to state 34
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    subprog_decl                   shift and go to state 59
    decl_item_s                    shift and go to state 647
    pragma                         shift and go to state 75
    pkg_spec                       shift and go to state 38
    number_decl                    shift and go to state 93

state 506

    (342) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part . END c_id_opt

    END             shift and go to state 648


state 507

    (459) body_stub -> TASK BODY . simple_name IS SEPARATE ;
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 649

state 508

    (460) body_stub -> PACKAGE BODY . compound_name IS SEPARATE ;
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    compound_name                  shift and go to state 650
    simple_name                    shift and go to state 42

state 509

    (461) body_stub -> subprog_spec IS . SEPARATE ;
    (505) generic_subp_inst -> subprog_spec IS . generic_inst
    (337) subprog_spec_is_push -> subprog_spec IS .
    (507) generic_inst -> . NEW name

    SEPARATE        shift and go to state 329
    ABSTRACT        reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    NEW             shift and go to state 186

    generic_inst                   shift and go to state 187

state 510

    (327) formal_part -> ( param_s ) .

    ;               reduce using rule 327 (formal_part -> ( param_s ) .)
    DO              reduce using rule 327 (formal_part -> ( param_s ) .)
    WHEN            reduce using rule 327 (formal_part -> ( param_s ) .)
    IS              reduce using rule 327 (formal_part -> ( param_s ) .)
    RENAMES         reduce using rule 327 (formal_part -> ( param_s ) .)
    RETURN          reduce using rule 327 (formal_part -> ( param_s ) .)


state 511

    (329) param_s -> param_s ; . param
    (330) param -> . def_id_s : mode mark init_opt
    (331) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . ID

    error           shift and go to state 110
    ID              shift and go to state 91

    param                          shift and go to state 651
    def_id                         shift and go to state 88
    def_id_s                       shift and go to state 106

state 512

    (348) pkg_body -> pkg_start decl_part body_opt END c_id_opt . ;

    ;               shift and go to state 652


state 513

    (346) c_id_opt -> compound_name .
    (165) compound_name -> compound_name . . simple_name

    ;               reduce using rule 346 (c_id_opt -> compound_name .)
    .               shift and go to state 120


state 514

    (482) generic_formal -> WITH FUNCTION designator formal_part_opt . RETURN name subp_default ;

    RETURN          shift and go to state 653


state 515

    (483) generic_formal -> WITH PACKAGE simple_name IS . NEW name ( BOX ) ;
    (484) generic_formal -> WITH PACKAGE simple_name IS . NEW name ;

    NEW             shift and go to state 654


state 516

    (481) generic_formal -> WITH PROCEDURE simple_name formal_part_opt . subp_default ;
    (489) subp_default -> .
    (490) subp_default -> . IS name
    (491) subp_default -> . IS BOX

    ;               reduce using rule 489 (subp_default -> .)
    IS              shift and go to state 655

    subp_default                   shift and go to state 656

state 517

    (335) mode -> IN OUT .

    ID              reduce using rule 335 (mode -> IN OUT .)


state 518

    (330) param -> def_id_s : mode mark . init_opt
    (161) mark -> mark . SINGLEQUOTE attribute_id
    (162) mark -> mark . . simple_name
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    SINGLEQUOTE     shift and go to state 318
    .               shift and go to state 319
    ;               reduce using rule 33 (init_opt -> .)
    )               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 643

    init_opt                       shift and go to state 657

state 519

    (363) rename_unit -> generic_formal_part PACKAGE compound_name renames ; .

    TASK            reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PROTECTED       reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    error           reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    USE             reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PRAGMA          reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PACKAGE         reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    TYPE            reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    SUBTYPE         reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    FOR             reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PROCEDURE       reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    FUNCTION        reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    GENERIC         reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    ID              reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    BEGIN           reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    END             reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PRIVATE         reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    WITH            reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    SEPARATE        reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    $end            reduce using rule 363 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)


state 520

    (480) generic_formal -> TYPE simple_name generic_discrim_part_opt IS . generic_type_def ;
    (492) generic_type_def -> . ( BOX )
    (493) generic_type_def -> . RANGE BOX
    (494) generic_type_def -> . MOD BOX
    (495) generic_type_def -> . DELTA BOX
    (496) generic_type_def -> . DELTA BOX DIGITS BOX
    (497) generic_type_def -> . DIGITS BOX
    (498) generic_type_def -> . array_type
    (499) generic_type_def -> . access_type
    (500) generic_type_def -> . private_type
    (501) generic_type_def -> . generic_derived_type
    (80) array_type -> . unconstr_array_type
    (81) array_type -> . constr_array_type
    (130) access_type -> . ACCESS subtype_ind
    (131) access_type -> . ACCESS CONSTANT subtype_ind
    (132) access_type -> . ACCESS ALL subtype_ind
    (133) access_type -> . ACCESS prot_opt PROCEDURE formal_part_opt
    (134) access_type -> . ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
    (351) private_type -> . tagged_opt limited_opt PRIVATE
    (502) generic_derived_type -> . NEW subtype_ind
    (503) generic_derived_type -> . NEW subtype_ind WITH PRIVATE
    (504) generic_derived_type -> . ABSTRACT NEW subtype_ind WITH PRIVATE
    (82) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (83) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (100) tagged_opt -> .
    (101) tagged_opt -> . TAGGED
    (102) tagged_opt -> . ABSTRACT TAGGED

    (               shift and go to state 663
    RANGE           shift and go to state 665
    MOD             shift and go to state 670
    DELTA           shift and go to state 669
    DIGITS          shift and go to state 662
    ACCESS          shift and go to state 628
    NEW             shift and go to state 660
    ABSTRACT        shift and go to state 658
    ARRAY           shift and go to state 498
    LIMITED         reduce using rule 100 (tagged_opt -> .)
    PRIVATE         reduce using rule 100 (tagged_opt -> .)
    TAGGED          shift and go to state 622

    private_type                   shift and go to state 664
    tagged_opt                     shift and go to state 668
    constr_array_type              shift and go to state 500
    access_type                    shift and go to state 666
    generic_derived_type           shift and go to state 661
    generic_type_def               shift and go to state 659
    array_type                     shift and go to state 667
    unconstr_array_type            shift and go to state 502

state 521

    (488) generic_discrim_part_opt -> ( BOX . )

    )               shift and go to state 671


state 522

    (321) subprog_spec -> FUNCTION designator formal_part_opt RETURN name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    IS              reduce using rule 321 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    ;               reduce using rule 321 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    RENAMES         reduce using rule 321 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 523

    (62) range -> simple_expression DOUBLEDOT simple_expression .
    (223) simple_expression -> simple_expression . adding term
    (226) adding -> . +
    (227) adding -> . -
    (228) adding -> . &

    AND             reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    OR              reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    XOR             reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    )               reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    ,               reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    WITH            reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    ARROW           reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    |               reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    ;               reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    IS              reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    THEN            reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    LOOP            reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    RANGE           reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    DIGITS          reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    RENAMES         reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    ASSIGNMENT      reduce using rule 62 (range -> simple_expression DOUBLEDOT simple_expression .)
    +               shift and go to state 217
    -               shift and go to state 219
    &               shift and go to state 218

    adding                         shift and go to state 213

state 524

    (124) choice_s -> choice_s | choice .

    ARROW           reduce using rule 124 (choice_s -> choice_s | choice .)
    |               reduce using rule 124 (choice_s -> choice_s | choice .)


state 525

    (126) choice -> discrete_with_range .

    ARROW           reduce using rule 126 (choice -> discrete_with_range .)
    |               reduce using rule 126 (choice -> discrete_with_range .)


state 526

    (125) choice -> expression .
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ARROW           reduce using rule 125 (choice -> expression .)
    |               reduce using rule 125 (choice -> expression .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 527

    (200) comp_assoc -> choice_s ARROW expression .
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    )               reduce using rule 200 (comp_assoc -> choice_s ARROW expression .)
    ,               reduce using rule 200 (comp_assoc -> choice_s ARROW expression .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 528

    (199) value_s_2 -> value_s_2 , value .

    )               reduce using rule 199 (value_s_2 -> value_s_2 , value .)
    ,               reduce using rule 199 (value_s_2 -> value_s_2 , value .)


state 529

    (63) range -> name . SINGLEQUOTE RANGE
    (64) range -> name . SINGLEQUOTE RANGE ( expression )
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id
    (240) primary -> name .
    (246) qualified -> name . SINGLEQUOTE parenthesized_primary

    SINGLEQUOTE     shift and go to state 379
    (               shift and go to state 249
    .               shift and go to state 250
    DOUBLESTAR      reduce using rule 240 (primary -> name .)
    *               reduce using rule 240 (primary -> name .)
    /               reduce using rule 240 (primary -> name .)
    MOD             reduce using rule 240 (primary -> name .)
    REM             reduce using rule 240 (primary -> name .)
    DOUBLEDOT       reduce using rule 240 (primary -> name .)
    +               reduce using rule 240 (primary -> name .)
    -               reduce using rule 240 (primary -> name .)
    &               reduce using rule 240 (primary -> name .)


state 530

    (61) range_constraint -> RANGE range .

    )               reduce using rule 61 (range_constraint -> RANGE range .)
    ,               reduce using rule 61 (range_constraint -> RANGE range .)
    ;               reduce using rule 61 (range_constraint -> RANGE range .)
    RENAMES         reduce using rule 61 (range_constraint -> RANGE range .)
    ASSIGNMENT      reduce using rule 61 (range_constraint -> RANGE range .)
    WITH            reduce using rule 61 (range_constraint -> RANGE range .)
    LOOP            reduce using rule 61 (range_constraint -> RANGE range .)
    ARROW           reduce using rule 61 (range_constraint -> RANGE range .)
    |               reduce using rule 61 (range_constraint -> RANGE range .)


state 531

    (63) range -> name SINGLEQUOTE RANGE .
    (64) range -> name SINGLEQUOTE RANGE . ( expression )

    AND             reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    OR              reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    XOR             reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    )               reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    ,               reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    WITH            reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    ARROW           reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    |               reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    ;               reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    IS              reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    THEN            reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    LOOP            reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    RANGE           reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    DIGITS          reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    RENAMES         reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    ASSIGNMENT      reduce using rule 63 (range -> name SINGLEQUOTE RANGE .)
    (               shift and go to state 672


state 532

    (198) value_s_2 -> value , value .

    )               reduce using rule 198 (value_s_2 -> value , value .)
    ,               reduce using rule 198 (value_s_2 -> value , value .)


state 533

    (197) aggregate -> ( NuLL RECORD ) .

    DOUBLESTAR      reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    *               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    /               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    MOD             reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    REM             reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    =               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    NOTEQUAL        reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    <               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    LEQUAL          reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    >               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    GEQUAL          reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    IN              reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    NOT             reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    +               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    -               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    &               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    AND             reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    OR              reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    XOR             reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    )               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    ,               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    DOUBLEDOT       reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    WITH            reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    ARROW           reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    |               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    ;               reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    IS              reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    THEN            reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    LOOP            reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    RANGE           reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    DIGITS          reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    RENAMES         reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)
    ASSIGNMENT      reduce using rule 197 (aggregate -> ( NuLL RECORD ) .)


state 534

    (195) aggregate -> ( expression WITH value_s . )
    (172) value_s -> value_s . , value

    )               shift and go to state 673
    ,               shift and go to state 537


state 535

    (196) aggregate -> ( expression WITH NuLL . RECORD )
    (192) literal -> NuLL .

    RECORD          shift and go to state 674
    DOUBLESTAR      reduce using rule 192 (literal -> NuLL .)
    *               reduce using rule 192 (literal -> NuLL .)
    /               reduce using rule 192 (literal -> NuLL .)
    MOD             reduce using rule 192 (literal -> NuLL .)
    REM             reduce using rule 192 (literal -> NuLL .)
    DOUBLEDOT       reduce using rule 192 (literal -> NuLL .)
    =               reduce using rule 192 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 192 (literal -> NuLL .)
    <               reduce using rule 192 (literal -> NuLL .)
    LEQUAL          reduce using rule 192 (literal -> NuLL .)
    >               reduce using rule 192 (literal -> NuLL .)
    GEQUAL          reduce using rule 192 (literal -> NuLL .)
    IN              reduce using rule 192 (literal -> NuLL .)
    NOT             reduce using rule 192 (literal -> NuLL .)
    +               reduce using rule 192 (literal -> NuLL .)
    -               reduce using rule 192 (literal -> NuLL .)
    &               reduce using rule 192 (literal -> NuLL .)
    AND             reduce using rule 192 (literal -> NuLL .)
    OR              reduce using rule 192 (literal -> NuLL .)
    XOR             reduce using rule 192 (literal -> NuLL .)
    )               reduce using rule 192 (literal -> NuLL .)
    ,               reduce using rule 192 (literal -> NuLL .)
    ARROW           reduce using rule 192 (literal -> NuLL .)
    |               reduce using rule 192 (literal -> NuLL .)


state 536

    (170) indexed_comp -> name ( value_s ) .

    SINGLEQUOTE     reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    (               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    .               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    DOUBLESTAR      reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    *               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    /               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    MOD             reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    REM             reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    =               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    NOTEQUAL        reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    <               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    LEQUAL          reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    >               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    GEQUAL          reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    IN              reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    NOT             reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    +               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    -               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    &               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    AND             reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    OR              reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    XOR             reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    LOOP            reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    RANGE           reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    ;               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    IS              reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    RENAMES         reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    THEN            reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    DOUBLEDOT       reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    )               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    ,               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    ARROW           reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    |               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    ASSIGNMENT      reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    DIGITS          reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    WITH            reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    WHEN            reduce using rule 170 (indexed_comp -> name ( value_s ) .)


state 537

    (172) value_s -> value_s , . value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (200) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 238
    OTHERS          shift and go to state 228
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 389
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    choice_s                       shift and go to state 230
    operator_symbol                shift and go to state 139
    comp_assoc                     shift and go to state 390
    factor                         shift and go to state 138
    choice                         shift and go to state 232
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    discrete_with_range            shift and go to state 234
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 235
    value                          shift and go to state 675
    range                          shift and go to state 237
    expression                     shift and go to state 392

state 538

    (202) expression -> expression logical m relation .

    IS              reduce using rule 202 (expression -> expression logical m relation .)
    AND             reduce using rule 202 (expression -> expression logical m relation .)
    OR              reduce using rule 202 (expression -> expression logical m relation .)
    XOR             reduce using rule 202 (expression -> expression logical m relation .)
    ;               reduce using rule 202 (expression -> expression logical m relation .)
    )               reduce using rule 202 (expression -> expression logical m relation .)
    WITH            reduce using rule 202 (expression -> expression logical m relation .)
    ,               reduce using rule 202 (expression -> expression logical m relation .)
    ARROW           reduce using rule 202 (expression -> expression logical m relation .)
    |               reduce using rule 202 (expression -> expression logical m relation .)
    THEN            reduce using rule 202 (expression -> expression logical m relation .)
    RANGE           reduce using rule 202 (expression -> expression logical m relation .)
    RENAMES         reduce using rule 202 (expression -> expression logical m relation .)
    ASSIGNMENT      reduce using rule 202 (expression -> expression logical m relation .)
    LOOP            reduce using rule 202 (expression -> expression logical m relation .)
    DIGITS          reduce using rule 202 (expression -> expression logical m relation .)


state 539

    (203) expression -> expression short_circuit m relation .

    IS              reduce using rule 203 (expression -> expression short_circuit m relation .)
    AND             reduce using rule 203 (expression -> expression short_circuit m relation .)
    OR              reduce using rule 203 (expression -> expression short_circuit m relation .)
    XOR             reduce using rule 203 (expression -> expression short_circuit m relation .)
    ;               reduce using rule 203 (expression -> expression short_circuit m relation .)
    )               reduce using rule 203 (expression -> expression short_circuit m relation .)
    WITH            reduce using rule 203 (expression -> expression short_circuit m relation .)
    ,               reduce using rule 203 (expression -> expression short_circuit m relation .)
    ARROW           reduce using rule 203 (expression -> expression short_circuit m relation .)
    |               reduce using rule 203 (expression -> expression short_circuit m relation .)
    THEN            reduce using rule 203 (expression -> expression short_circuit m relation .)
    RANGE           reduce using rule 203 (expression -> expression short_circuit m relation .)
    RENAMES         reduce using rule 203 (expression -> expression short_circuit m relation .)
    ASSIGNMENT      reduce using rule 203 (expression -> expression short_circuit m relation .)
    LOOP            reduce using rule 203 (expression -> expression short_circuit m relation .)
    DIGITS          reduce using rule 203 (expression -> expression short_circuit m relation .)


state 540

    (390) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt ;
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 676

state 541

    (373) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt ;
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 677

state 542

    (337) subprog_spec_is_push -> subprog_spec IS .

    TASK            reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PACKAGE         reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    ID              reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 337 (subprog_spec_is_push -> subprog_spec IS .)


state 543

    (462) body_stub -> PROTECTED BODY simple_name IS SEPARATE . ;

    ;               shift and go to state 678


state 544

    (390) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s . END id_opt ;
    (392) prot_op_body_s -> prot_op_body_s . prot_op_body pragma_s
    (393) prot_op_body -> . entry_body
    (394) prot_op_body -> . subprog_body
    (395) prot_op_body -> . subprog_spec ;
    (400) entry_body -> . ENTRY ID formal_part_opt WHEN condition entry_body_part
    (401) entry_body -> . ENTRY ID ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (337) subprog_spec_is_push -> . subprog_spec IS

    END             shift and go to state 681
    ENTRY           shift and go to state 684
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37

    subprog_body                   shift and go to state 679
    prot_op_body                   shift and go to state 683
    entry_body                     shift and go to state 682
    subprog_spec                   shift and go to state 680
    subprog_spec_is_push           shift and go to state 416

state 545

    (391) prot_op_body_s -> pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 391 (prot_op_body_s -> pragma_s .)
    ENTRY           reduce using rule 391 (prot_op_body_s -> pragma_s .)
    PROCEDURE       reduce using rule 391 (prot_op_body_s -> pragma_s .)
    FUNCTION        reduce using rule 391 (prot_op_body_s -> pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 546

    (376) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .

    ;               reduce using rule 376 (prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .)


state 547

    (384) prot_op_decl -> rep_spec .

    PRIVATE         reduce using rule 384 (prot_op_decl -> rep_spec .)
    ENTRY           reduce using rule 384 (prot_op_decl -> rep_spec .)
    PROCEDURE       reduce using rule 384 (prot_op_decl -> rep_spec .)
    FUNCTION        reduce using rule 384 (prot_op_decl -> rep_spec .)
    PRAGMA          reduce using rule 384 (prot_op_decl -> rep_spec .)
    FOR             reduce using rule 384 (prot_op_decl -> rep_spec .)
    END             reduce using rule 384 (prot_op_decl -> rep_spec .)
    error           reduce using rule 384 (prot_op_decl -> rep_spec .)
    ID              reduce using rule 384 (prot_op_decl -> rep_spec .)


state 548

    (382) prot_op_decl -> entry_decl .

    PRIVATE         reduce using rule 382 (prot_op_decl -> entry_decl .)
    ENTRY           reduce using rule 382 (prot_op_decl -> entry_decl .)
    PROCEDURE       reduce using rule 382 (prot_op_decl -> entry_decl .)
    FUNCTION        reduce using rule 382 (prot_op_decl -> entry_decl .)
    PRAGMA          reduce using rule 382 (prot_op_decl -> entry_decl .)
    FOR             reduce using rule 382 (prot_op_decl -> entry_decl .)
    END             reduce using rule 382 (prot_op_decl -> entry_decl .)
    error           reduce using rule 382 (prot_op_decl -> entry_decl .)
    ID              reduce using rule 382 (prot_op_decl -> entry_decl .)


state 549

    (379) prot_private_opt -> PRIVATE . prot_elem_decl_s
    (386) prot_elem_decl_s -> .
    (387) prot_elem_decl_s -> . prot_elem_decl_s prot_elem_decl

    error           reduce using rule 386 (prot_elem_decl_s -> .)
    ENTRY           reduce using rule 386 (prot_elem_decl_s -> .)
    PROCEDURE       reduce using rule 386 (prot_elem_decl_s -> .)
    FUNCTION        reduce using rule 386 (prot_elem_decl_s -> .)
    PRAGMA          reduce using rule 386 (prot_elem_decl_s -> .)
    FOR             reduce using rule 386 (prot_elem_decl_s -> .)
    ID              reduce using rule 386 (prot_elem_decl_s -> .)
    END             reduce using rule 386 (prot_elem_decl_s -> .)

    prot_elem_decl_s               shift and go to state 685

state 550

    (383) prot_op_decl -> subprog_spec . ;

    ;               shift and go to state 686


state 551

    (377) prot_def -> IS prot_op_decl_s prot_private_opt . END id_opt

    END             shift and go to state 687


state 552

    (385) prot_op_decl -> pragma .

    PRIVATE         reduce using rule 385 (prot_op_decl -> pragma .)
    ENTRY           reduce using rule 385 (prot_op_decl -> pragma .)
    PROCEDURE       reduce using rule 385 (prot_op_decl -> pragma .)
    FUNCTION        reduce using rule 385 (prot_op_decl -> pragma .)
    PRAGMA          reduce using rule 385 (prot_op_decl -> pragma .)
    FOR             reduce using rule 385 (prot_op_decl -> pragma .)
    END             reduce using rule 385 (prot_op_decl -> pragma .)
    error           reduce using rule 385 (prot_op_decl -> pragma .)
    ID              reduce using rule 385 (prot_op_decl -> pragma .)


state 553

    (398) entry_decl -> ENTRY . ID formal_part_opt ;
    (399) entry_decl -> ENTRY . ID ( discrete_range ) formal_part_opt ;

    ID              shift and go to state 688


state 554

    (381) prot_op_decl_s -> prot_op_decl_s prot_op_decl .

    PRIVATE         reduce using rule 381 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    ENTRY           reduce using rule 381 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    PROCEDURE       reduce using rule 381 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    FUNCTION        reduce using rule 381 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    PRAGMA          reduce using rule 381 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    FOR             reduce using rule 381 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    END             reduce using rule 381 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)


state 555

    (413) delay_stmt -> DELAY UNTIL expression . ;
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ;               shift and go to state 689
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 556

    (412) delay_stmt -> DELAY expression ; .

    LEFTLABEL       reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    error           reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    PRAGMA          reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    NuLL            reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    EXIT            reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    RETURN          reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    GOTO            reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    DELAY           reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    ABORT           reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    RAISE           reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    REQUEUE         reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    IF              reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    CASE            reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    ID              reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    ACCEPT          reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    SELECT          reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    STRLITERAL      reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    WHILE           reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    DECLARE         reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    FOR             reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    LOOP            reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    BEGIN           reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    OR              reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    ELSE            reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    END             reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    WHEN            reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    ELSIF           reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    EXCEPTION       reduce using rule 412 (delay_stmt -> DELAY expression ; .)
    THEN            reduce using rule 412 (delay_stmt -> DELAY expression ; .)


state 557

    (295) iteration -> iter_part reverse_opt . discrete_range
    (93) discrete_range -> . name range_constr_opt
    (94) discrete_range -> . range
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    simple_expression              shift and go to state 366
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    parenthesized_primary          shift and go to state 142
    discrete_range                 shift and go to state 690
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 691
    operator_symbol                shift and go to state 139
    range                          shift and go to state 692
    qualified                      shift and go to state 151

state 558

    (298) reverse_opt -> REVERSE .

    ID              reduce using rule 298 (reverse_opt -> REVERSE .)
    STRLITERAL      reduce using rule 298 (reverse_opt -> REVERSE .)
    +               reduce using rule 298 (reverse_opt -> REVERSE .)
    -               reduce using rule 298 (reverse_opt -> REVERSE .)
    NOT             reduce using rule 298 (reverse_opt -> REVERSE .)
    ABS             reduce using rule 298 (reverse_opt -> REVERSE .)
    NuLL            reduce using rule 298 (reverse_opt -> REVERSE .)
    NEW             reduce using rule 298 (reverse_opt -> REVERSE .)
    (               reduce using rule 298 (reverse_opt -> REVERSE .)
    NUMLITERAL_BASE_INT reduce using rule 298 (reverse_opt -> REVERSE .)
    NUMLITERAL_BASE_FLOAT reduce using rule 298 (reverse_opt -> REVERSE .)
    NUMLITERAL_INT  reduce using rule 298 (reverse_opt -> REVERSE .)
    NUMLITERAL_FLOAT reduce using rule 298 (reverse_opt -> REVERSE .)
    CHARLITERAL     reduce using rule 298 (reverse_opt -> REVERSE .)


state 559

    (296) iter_part -> FOR ID . IN

    IN              shift and go to state 693


state 560

    (290) loop_stmt -> label_opt iteration m . basic_loop id_opt ;
    (299) basic_loop -> . LOOP statement_s END LOOP

    LOOP            shift and go to state 695

    basic_loop                     shift and go to state 694

state 561

    (302) block -> label_opt block_decl block_body . END id_opt ;

    END             shift and go to state 696


state 562

    (294) iteration -> WHILE m . condition
    (282) condition -> . expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    condition                      shift and go to state 697
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 470

state 563

    (304) block_decl -> DECLARE decl_part .

    BEGIN           reduce using rule 304 (block_decl -> DECLARE decl_part .)


state 564

    (316) goto_stmt -> GOTO name ; .

    LEFTLABEL       reduce using rule 316 (goto_stmt -> GOTO name ; .)
    error           reduce using rule 316 (goto_stmt -> GOTO name ; .)
    PRAGMA          reduce using rule 316 (goto_stmt -> GOTO name ; .)
    NuLL            reduce using rule 316 (goto_stmt -> GOTO name ; .)
    EXIT            reduce using rule 316 (goto_stmt -> GOTO name ; .)
    RETURN          reduce using rule 316 (goto_stmt -> GOTO name ; .)
    GOTO            reduce using rule 316 (goto_stmt -> GOTO name ; .)
    DELAY           reduce using rule 316 (goto_stmt -> GOTO name ; .)
    ABORT           reduce using rule 316 (goto_stmt -> GOTO name ; .)
    RAISE           reduce using rule 316 (goto_stmt -> GOTO name ; .)
    REQUEUE         reduce using rule 316 (goto_stmt -> GOTO name ; .)
    IF              reduce using rule 316 (goto_stmt -> GOTO name ; .)
    CASE            reduce using rule 316 (goto_stmt -> GOTO name ; .)
    ID              reduce using rule 316 (goto_stmt -> GOTO name ; .)
    ACCEPT          reduce using rule 316 (goto_stmt -> GOTO name ; .)
    SELECT          reduce using rule 316 (goto_stmt -> GOTO name ; .)
    STRLITERAL      reduce using rule 316 (goto_stmt -> GOTO name ; .)
    WHILE           reduce using rule 316 (goto_stmt -> GOTO name ; .)
    DECLARE         reduce using rule 316 (goto_stmt -> GOTO name ; .)
    FOR             reduce using rule 316 (goto_stmt -> GOTO name ; .)
    LOOP            reduce using rule 316 (goto_stmt -> GOTO name ; .)
    BEGIN           reduce using rule 316 (goto_stmt -> GOTO name ; .)
    WHEN            reduce using rule 316 (goto_stmt -> GOTO name ; .)
    END             reduce using rule 316 (goto_stmt -> GOTO name ; .)
    EXCEPTION       reduce using rule 316 (goto_stmt -> GOTO name ; .)
    OR              reduce using rule 316 (goto_stmt -> GOTO name ; .)
    ELSE            reduce using rule 316 (goto_stmt -> GOTO name ; .)
    THEN            reduce using rule 316 (goto_stmt -> GOTO name ; .)
    ELSIF           reduce using rule 316 (goto_stmt -> GOTO name ; .)


state 565

    (276) assign_stmt -> name ASSIGNMENT expression . ;
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ;               shift and go to state 698
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 566

    (433) abort_stmt -> ABORT name_s ; .

    END             reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    LEFTLABEL       reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    error           reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    PRAGMA          reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    NuLL            reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    EXIT            reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    RETURN          reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    GOTO            reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    DELAY           reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    ABORT           reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    RAISE           reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    REQUEUE         reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    IF              reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    CASE            reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    ID              reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    ACCEPT          reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    SELECT          reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    STRLITERAL      reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    WHILE           reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    DECLARE         reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    FOR             reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    LOOP            reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    BEGIN           reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    EXCEPTION       reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    WHEN            reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    OR              reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    ELSE            reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    THEN            reduce using rule 433 (abort_stmt -> ABORT name_s ; .)
    ELSIF           reduce using rule 433 (abort_stmt -> ABORT name_s ; .)


state 567

    (315) return_stmt -> RETURN expression ; .

    EXCEPTION       reduce using rule 315 (return_stmt -> RETURN expression ; .)
    LEFTLABEL       reduce using rule 315 (return_stmt -> RETURN expression ; .)
    error           reduce using rule 315 (return_stmt -> RETURN expression ; .)
    PRAGMA          reduce using rule 315 (return_stmt -> RETURN expression ; .)
    NuLL            reduce using rule 315 (return_stmt -> RETURN expression ; .)
    EXIT            reduce using rule 315 (return_stmt -> RETURN expression ; .)
    RETURN          reduce using rule 315 (return_stmt -> RETURN expression ; .)
    GOTO            reduce using rule 315 (return_stmt -> RETURN expression ; .)
    DELAY           reduce using rule 315 (return_stmt -> RETURN expression ; .)
    ABORT           reduce using rule 315 (return_stmt -> RETURN expression ; .)
    RAISE           reduce using rule 315 (return_stmt -> RETURN expression ; .)
    REQUEUE         reduce using rule 315 (return_stmt -> RETURN expression ; .)
    IF              reduce using rule 315 (return_stmt -> RETURN expression ; .)
    CASE            reduce using rule 315 (return_stmt -> RETURN expression ; .)
    ID              reduce using rule 315 (return_stmt -> RETURN expression ; .)
    ACCEPT          reduce using rule 315 (return_stmt -> RETURN expression ; .)
    SELECT          reduce using rule 315 (return_stmt -> RETURN expression ; .)
    STRLITERAL      reduce using rule 315 (return_stmt -> RETURN expression ; .)
    WHILE           reduce using rule 315 (return_stmt -> RETURN expression ; .)
    DECLARE         reduce using rule 315 (return_stmt -> RETURN expression ; .)
    FOR             reduce using rule 315 (return_stmt -> RETURN expression ; .)
    LOOP            reduce using rule 315 (return_stmt -> RETURN expression ; .)
    BEGIN           reduce using rule 315 (return_stmt -> RETURN expression ; .)
    END             reduce using rule 315 (return_stmt -> RETURN expression ; .)
    OR              reduce using rule 315 (return_stmt -> RETURN expression ; .)
    ELSE            reduce using rule 315 (return_stmt -> RETURN expression ; .)
    THEN            reduce using rule 315 (return_stmt -> RETURN expression ; .)
    ELSIF           reduce using rule 315 (return_stmt -> RETURN expression ; .)
    WHEN            reduce using rule 315 (return_stmt -> RETURN expression ; .)


state 568

    (411) entry_name -> entry_name ( . expression )
    (327) formal_part -> ( . param_s )
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (328) param_s -> . param
    (329) param_s -> . param_s ; param
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (330) param -> . def_id_s : mode mark init_opt
    (331) param -> . error
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (26) def_id -> . ID
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 110
    +               shift and go to state 135
    -               shift and go to state 136
    ID              shift and go to state 699
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    param                          shift and go to state 347
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    param_s                        shift and go to state 348
    literal                        shift and go to state 137
    def_id_s                       shift and go to state 106
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    def_id                         shift and go to state 88
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    relation                       shift and go to state 126
    expression                     shift and go to state 700

state 569

    (409) accept_hdr -> ACCEPT entry_name formal_part_opt .

    ;               reduce using rule 409 (accept_hdr -> ACCEPT entry_name formal_part_opt .)
    DO              reduce using rule 409 (accept_hdr -> ACCEPT entry_name formal_part_opt .)


state 570

    (423) select_alt -> accept_stmt stmts_opt .

    OR              reduce using rule 423 (select_alt -> accept_stmt stmts_opt .)
    ELSE            reduce using rule 423 (select_alt -> accept_stmt stmts_opt .)
    END             reduce using rule 423 (select_alt -> accept_stmt stmts_opt .)


state 571

    (432) stmts_opt -> statement_s .
    (250) statement_s -> statement_s . m statement
    (519) m -> .

    END             reduce using rule 432 (stmts_opt -> statement_s .)
    OR              reduce using rule 432 (stmts_opt -> statement_s .)
    ELSE            reduce using rule 432 (stmts_opt -> statement_s .)
    THEN            reduce using rule 432 (stmts_opt -> statement_s .)
    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)

    m                              shift and go to state 461

state 572

    (429) timed_entry_call -> SELECT entry_call stmts_opt . OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> SELECT entry_call stmts_opt . ELSE statement_s END SELECT ;
    (427) delay_or_entry_alt -> entry_call stmts_opt .

    OR              shift and go to state 702
    ELSE            shift and go to state 701
    THEN            reduce using rule 427 (delay_or_entry_alt -> entry_call stmts_opt .)


state 573

    (428) async_select -> SELECT delay_or_entry_alt THEN . ABORT statement_s END SELECT ;

    ABORT           shift and go to state 703


state 574

    (420) guarded_select_alt -> WHEN condition . ARROW select_alt

    ARROW           shift and go to state 704


state 575

    (418) select_wait -> SELECT guarded_select_alt or_select . else_opt END SELECT ;
    (422) or_select -> or_select . OR guarded_select_alt
    (283) else_opt -> .
    (284) else_opt -> . ELSE m statement_s

    OR              shift and go to state 706
    END             reduce using rule 283 (else_opt -> .)
    ELSE            shift and go to state 591

    else_opt                       shift and go to state 705

state 576

    (426) delay_or_entry_alt -> delay_stmt stmts_opt .
    (424) select_alt -> delay_stmt stmts_opt .

    THEN            reduce using rule 426 (delay_or_entry_alt -> delay_stmt stmts_opt .)
    OR              reduce using rule 424 (select_alt -> delay_stmt stmts_opt .)
    ELSE            reduce using rule 424 (select_alt -> delay_stmt stmts_opt .)
    END             reduce using rule 424 (select_alt -> delay_stmt stmts_opt .)


state 577

    (425) select_alt -> TERMINATE ; .

    OR              reduce using rule 425 (select_alt -> TERMINATE ; .)
    ELSE            reduce using rule 425 (select_alt -> TERMINATE ; .)
    END             reduce using rule 425 (select_alt -> TERMINATE ; .)


state 578

    (285) case_stmt -> case_hdr pragma_s alternative_s . END CASE ;
    (288) alternative_s -> alternative_s . alternative
    (289) alternative -> . WHEN choice_s ARROW statement_s

    END             shift and go to state 708
    WHEN            shift and go to state 709

    alternative                    shift and go to state 707

state 579

    (472) raise_stmt -> RAISE name_opt ; .

    LEFTLABEL       reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    error           reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    PRAGMA          reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    NuLL            reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    EXIT            reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    RETURN          reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    GOTO            reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    DELAY           reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    ABORT           reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    RAISE           reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    REQUEUE         reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    IF              reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    CASE            reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    ID              reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    ACCEPT          reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    SELECT          reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    STRLITERAL      reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    WHILE           reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    DECLARE         reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    FOR             reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    LOOP            reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    BEGIN           reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    END             reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    WHEN            reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    OR              reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    ELSE            reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    EXCEPTION       reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    ELSIF           reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)
    THEN            reduce using rule 472 (raise_stmt -> RAISE name_opt ; .)


state 580

    (286) case_hdr -> CASE expression IS .

    PRAGMA          reduce using rule 286 (case_hdr -> CASE expression IS .)
    END             reduce using rule 286 (case_hdr -> CASE expression IS .)
    WHEN            reduce using rule 286 (case_hdr -> CASE expression IS .)


state 581

    (473) requeue_stmt -> REQUEUE name ; .

    EXCEPTION       reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    LEFTLABEL       reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    error           reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    PRAGMA          reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    NuLL            reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    EXIT            reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    RETURN          reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    GOTO            reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    DELAY           reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    ABORT           reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    RAISE           reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    REQUEUE         reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    IF              reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    CASE            reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    ID              reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    ACCEPT          reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    SELECT          reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    STRLITERAL      reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    WHILE           reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    DECLARE         reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    FOR             reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    LOOP            reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    BEGIN           reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    END             reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    OR              reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    ELSE            reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    THEN            reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    ELSIF           reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)
    WHEN            reduce using rule 473 (requeue_stmt -> REQUEUE name ; .)


state 582

    (474) requeue_stmt -> REQUEUE name WITH . ABORT ;

    ABORT           shift and go to state 710


state 583

    (408) accept_stmt -> accept_hdr DO handled_stmt_s . END id_opt ;

    END             shift and go to state 711


state 584

    (309) exit_stmt -> EXIT name_opt when_opt . ;

    ;               shift and go to state 712


state 585

    (313) when_opt -> WHEN . condition
    (282) condition -> . expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    condition                      shift and go to state 713
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 470

state 586

    (464) except_handler_part -> EXCEPTION exception_handler .

    WHEN            reduce using rule 464 (except_handler_part -> EXCEPTION exception_handler .)
    END             reduce using rule 464 (except_handler_part -> EXCEPTION exception_handler .)


state 587

    (466) exception_handler -> WHEN . except_choice_s ARROW statement_s
    (467) exception_handler -> WHEN . ID : except_choice_s ARROW statement_s
    (468) except_choice_s -> . except_choice
    (469) except_choice_s -> . except_choice_s | except_choice
    (470) except_choice -> . name
    (471) except_choice -> . OTHERS
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 717
    OTHERS          shift and go to state 716
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 718
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    except_choice_s                shift and go to state 714
    except_choice                  shift and go to state 715
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 588

    (250) statement_s -> statement_s m statement .

    END             reduce using rule 250 (statement_s -> statement_s m statement .)
    LEFTLABEL       reduce using rule 250 (statement_s -> statement_s m statement .)
    error           reduce using rule 250 (statement_s -> statement_s m statement .)
    PRAGMA          reduce using rule 250 (statement_s -> statement_s m statement .)
    NuLL            reduce using rule 250 (statement_s -> statement_s m statement .)
    EXIT            reduce using rule 250 (statement_s -> statement_s m statement .)
    RETURN          reduce using rule 250 (statement_s -> statement_s m statement .)
    GOTO            reduce using rule 250 (statement_s -> statement_s m statement .)
    DELAY           reduce using rule 250 (statement_s -> statement_s m statement .)
    ABORT           reduce using rule 250 (statement_s -> statement_s m statement .)
    RAISE           reduce using rule 250 (statement_s -> statement_s m statement .)
    REQUEUE         reduce using rule 250 (statement_s -> statement_s m statement .)
    IF              reduce using rule 250 (statement_s -> statement_s m statement .)
    CASE            reduce using rule 250 (statement_s -> statement_s m statement .)
    ID              reduce using rule 250 (statement_s -> statement_s m statement .)
    ACCEPT          reduce using rule 250 (statement_s -> statement_s m statement .)
    SELECT          reduce using rule 250 (statement_s -> statement_s m statement .)
    STRLITERAL      reduce using rule 250 (statement_s -> statement_s m statement .)
    WHILE           reduce using rule 250 (statement_s -> statement_s m statement .)
    DECLARE         reduce using rule 250 (statement_s -> statement_s m statement .)
    FOR             reduce using rule 250 (statement_s -> statement_s m statement .)
    LOOP            reduce using rule 250 (statement_s -> statement_s m statement .)
    BEGIN           reduce using rule 250 (statement_s -> statement_s m statement .)
    ELSIF           reduce using rule 250 (statement_s -> statement_s m statement .)
    ELSE            reduce using rule 250 (statement_s -> statement_s m statement .)
    WHEN            reduce using rule 250 (statement_s -> statement_s m statement .)
    THEN            reduce using rule 250 (statement_s -> statement_s m statement .)
    OR              reduce using rule 250 (statement_s -> statement_s m statement .)
    EXCEPTION       reduce using rule 250 (statement_s -> statement_s m statement .)


state 589

    (465) except_handler_part -> except_handler_part exception_handler .

    WHEN            reduce using rule 465 (except_handler_part -> except_handler_part exception_handler .)
    END             reduce using rule 465 (except_handler_part -> except_handler_part exception_handler .)


state 590

    (274) label -> LEFTLABEL ID RIGHTLABEL .

    LEFTLABEL       reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    error           reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    PRAGMA          reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    NuLL            reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    EXIT            reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    RETURN          reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    GOTO            reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    DELAY           reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    ABORT           reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    RAISE           reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    REQUEUE         reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    IF              reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    CASE            reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    ID              reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    ACCEPT          reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    SELECT          reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    STRLITERAL      reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    WHILE           reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    DECLARE         reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    FOR             reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    LOOP            reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)
    BEGIN           reduce using rule 274 (label -> LEFTLABEL ID RIGHTLABEL .)


state 591

    (284) else_opt -> ELSE . m statement_s
    (519) m -> .

    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)

    m                              shift and go to state 719

state 592

    (277) if_stmt -> IF cond_clause_s else_opt . END IF ;

    END             shift and go to state 720


state 593

    (279) cond_clause_s -> cond_clause ELSIF . m cond_clause_s
    (519) m -> .

    +               reduce using rule 519 (m -> .)
    -               reduce using rule 519 (m -> .)
    NOT             reduce using rule 519 (m -> .)
    ABS             reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    NEW             reduce using rule 519 (m -> .)
    (               reduce using rule 519 (m -> .)
    NUMLITERAL_BASE_INT reduce using rule 519 (m -> .)
    NUMLITERAL_BASE_FLOAT reduce using rule 519 (m -> .)
    NUMLITERAL_INT  reduce using rule 519 (m -> .)
    NUMLITERAL_FLOAT reduce using rule 519 (m -> .)
    CHARLITERAL     reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)

    m                              shift and go to state 721

state 594

    (280) cond_clause -> cond_part m . statement_s n
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    label                          shift and go to state 285
    statement_s                    shift and go to state 722
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    assign_stmt                    shift and go to state 315
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    timed_entry_call               shift and go to state 301
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 595

    (281) cond_part -> condition THEN .

    LEFTLABEL       reduce using rule 281 (cond_part -> condition THEN .)
    error           reduce using rule 281 (cond_part -> condition THEN .)
    PRAGMA          reduce using rule 281 (cond_part -> condition THEN .)
    NuLL            reduce using rule 281 (cond_part -> condition THEN .)
    EXIT            reduce using rule 281 (cond_part -> condition THEN .)
    RETURN          reduce using rule 281 (cond_part -> condition THEN .)
    GOTO            reduce using rule 281 (cond_part -> condition THEN .)
    DELAY           reduce using rule 281 (cond_part -> condition THEN .)
    ABORT           reduce using rule 281 (cond_part -> condition THEN .)
    RAISE           reduce using rule 281 (cond_part -> condition THEN .)
    REQUEUE         reduce using rule 281 (cond_part -> condition THEN .)
    IF              reduce using rule 281 (cond_part -> condition THEN .)
    CASE            reduce using rule 281 (cond_part -> condition THEN .)
    ID              reduce using rule 281 (cond_part -> condition THEN .)
    ACCEPT          reduce using rule 281 (cond_part -> condition THEN .)
    SELECT          reduce using rule 281 (cond_part -> condition THEN .)
    STRLITERAL      reduce using rule 281 (cond_part -> condition THEN .)
    WHILE           reduce using rule 281 (cond_part -> condition THEN .)
    DECLARE         reduce using rule 281 (cond_part -> condition THEN .)
    FOR             reduce using rule 281 (cond_part -> condition THEN .)
    LOOP            reduce using rule 281 (cond_part -> condition THEN .)
    BEGIN           reduce using rule 281 (cond_part -> condition THEN .)


state 596

    (338) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .

    TASK            reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PROTECTED       reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    error           reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    USE             reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PRAGMA          reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PACKAGE         reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    TYPE            reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    SUBTYPE         reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    FOR             reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    GENERIC         reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    ID              reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    BEGIN           reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    END             reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PRIVATE         reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    WITH            reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    SEPARATE        reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    $end            reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    ENTRY           reduce using rule 338 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)


state 597

    (512) record_type_spec -> FOR mark USE RECORD align_opt . comp_loc_s END RECORD ;
    (515) comp_loc_s -> .
    (516) comp_loc_s -> . comp_loc_s mark AT expression RANGE range ;

    END             reduce using rule 515 (comp_loc_s -> .)
    ID              reduce using rule 515 (comp_loc_s -> .)

    comp_loc_s                     shift and go to state 723

state 598

    (514) align_opt -> AT . MOD expression ;

    MOD             shift and go to state 724


state 599

    (517) address_spec -> FOR mark USE AT expression . ;
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ;               shift and go to state 725
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 600

    (511) attrib_def -> FOR mark USE expression ; .

    TASK            reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    PROTECTED       reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    error           reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    USE             reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    PRAGMA          reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    PACKAGE         reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    TYPE            reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    SUBTYPE         reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    FOR             reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    PROCEDURE       reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    FUNCTION        reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    GENERIC         reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    ID              reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    BEGIN           reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    PRIVATE         reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    END             reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)
    ENTRY           reduce using rule 511 (attrib_def -> FOR mark USE expression ; .)


state 601

    (459) body_stub -> TASK BODY simple_name IS SEPARATE . ;

    ;               shift and go to state 726


state 602

    (373) task_body -> TASK BODY simple_name IS decl_part . block_body END id_opt ;
    (305) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 165

    block_body                     shift and go to state 727

state 603

    (368) task_spec -> TASK TYPE simple_name discrim_part_opt task_def .

    ;               reduce using rule 368 (task_spec -> TASK TYPE simple_name discrim_part_opt task_def .)


state 604

    (370) task_def -> IS entry_decl_s rep_spec_s . task_private_opt END id_opt
    (405) rep_spec_s -> rep_spec_s . rep_spec pragma_s
    (371) task_private_opt -> .
    (372) task_private_opt -> . PRIVATE entry_decl_s rep_spec_s
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 371 (task_private_opt -> .)
    PRIVATE         shift and go to state 729
    FOR             shift and go to state 64

    record_type_spec               shift and go to state 69
    rep_spec                       shift and go to state 728
    attrib_def                     shift and go to state 71
    address_spec                   shift and go to state 53
    task_private_opt               shift and go to state 730

state 605

    (397) entry_decl_s -> entry_decl_s entry_decl . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 731

state 606

    (460) body_stub -> PACKAGE BODY compound_name IS SEPARATE . ;

    ;               shift and go to state 732


state 607

    (39) discrim_part_opt -> ( BOX ) .

    IS              reduce using rule 39 (discrim_part_opt -> ( BOX ) .)
    ;               reduce using rule 39 (discrim_part_opt -> ( BOX ) .)


state 608

    (112) discrim_part -> ( discrim_spec_s ) .

    IS              reduce using rule 112 (discrim_part -> ( discrim_spec_s ) .)
    ;               reduce using rule 112 (discrim_part -> ( discrim_spec_s ) .)


state 609

    (114) discrim_spec_s -> discrim_spec_s ; . discrim_spec
    (115) discrim_spec -> . def_id_s : access_opt mark init_opt
    (116) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . ID

    error           shift and go to state 484
    ID              shift and go to state 91

    discrim_spec                   shift and go to state 733
    def_id                         shift and go to state 88
    def_id_s                       shift and go to state 486

state 610

    (115) discrim_spec -> def_id_s : . access_opt mark init_opt
    (117) access_opt -> .
    (118) access_opt -> . ACCESS

    ID              reduce using rule 117 (access_opt -> .)
    ACCESS          shift and go to state 734

    access_opt                     shift and go to state 735

state 611

    (59) derived_type -> ABSTRACT . NEW subtype_ind WITH PRIVATE
    (60) derived_type -> ABSTRACT . NEW subtype_ind WITH record_def
    (102) tagged_opt -> ABSTRACT . TAGGED

    NEW             shift and go to state 737
    TAGGED          shift and go to state 736


state 612

    (72) range_spec -> range_constraint .

    ;               reduce using rule 72 (range_spec -> range_constraint .)


state 613

    (47) type_def -> access_type .

    ;               reduce using rule 47 (type_def -> access_type .)


state 614

    (46) type_def -> record_type .

    ;               reduce using rule 46 (type_def -> record_type .)


state 615

    (44) type_def -> real_type .

    ;               reduce using rule 44 (type_def -> real_type .)


state 616

    (56) derived_type -> NEW . subtype_ind
    (57) derived_type -> NEW . subtype_ind WITH PRIVATE
    (58) derived_type -> NEW . subtype_ind WITH record_def
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 490
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    subtype_ind                    shift and go to state 738
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 617

    (42) type_def -> enumeration_type .

    ;               reduce using rule 42 (type_def -> enumeration_type .)


state 618

    (49) type_def -> private_type .

    ;               reduce using rule 49 (type_def -> private_type .)


state 619

    (75) real_type -> float_type .

    ;               reduce using rule 75 (real_type -> float_type .)


state 620

    (65) enumeration_type -> ( . enum_id_s )
    (66) enum_id_s -> . enum_id
    (67) enum_id_s -> . enum_id_s , enum_id
    (68) enum_id -> . ID
    (69) enum_id -> . CHARLITERAL

    ID              shift and go to state 741
    CHARLITERAL     shift and go to state 740

    enum_id                        shift and go to state 742
    enum_id_s                      shift and go to state 739

state 621

    (77) float_type -> DIGITS . expression range_spec_opt
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 743

state 622

    (101) tagged_opt -> TAGGED .

    LIMITED         reduce using rule 101 (tagged_opt -> TAGGED .)
    PRIVATE         reduce using rule 101 (tagged_opt -> TAGGED .)
    RECORD          reduce using rule 101 (tagged_opt -> TAGGED .)
    NuLL            reduce using rule 101 (tagged_opt -> TAGGED .)


state 623

    (78) fixed_type -> DELTA . expression range_spec
    (79) fixed_type -> DELTA . expression DIGITS expression range_spec_opt
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 744

state 624

    (43) type_def -> integer_type .

    ;               reduce using rule 43 (type_def -> integer_type .)


state 625

    (45) type_def -> array_type .

    ;               reduce using rule 45 (type_def -> array_type .)


state 626

    (70) integer_type -> range_spec .

    ;               reduce using rule 70 (integer_type -> range_spec .)


state 627

    (41) type_completion -> IS type_def .

    ;               reduce using rule 41 (type_completion -> IS type_def .)


state 628

    (130) access_type -> ACCESS . subtype_ind
    (131) access_type -> ACCESS . CONSTANT subtype_ind
    (132) access_type -> ACCESS . ALL subtype_ind
    (133) access_type -> ACCESS . prot_opt PROCEDURE formal_part_opt
    (134) access_type -> ACCESS . prot_opt FUNCTION formal_part_opt RETURN mark
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (135) prot_opt -> .
    (136) prot_opt -> . PROTECTED
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    CONSTANT        shift and go to state 745
    ALL             shift and go to state 748
    PROCEDURE       reduce using rule 135 (prot_opt -> .)
    FUNCTION        reduce using rule 135 (prot_opt -> .)
    PROTECTED       shift and go to state 747
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 490
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    prot_opt                       shift and go to state 746
    subtype_ind                    shift and go to state 749
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 629

    (97) record_type -> tagged_opt . limited_opt record_def
    (351) private_type -> tagged_opt . limited_opt PRIVATE
    (352) limited_opt -> .
    (353) limited_opt -> . LIMITED

    PRIVATE         reduce using rule 352 (limited_opt -> .)
    RECORD          reduce using rule 352 (limited_opt -> .)
    NuLL            reduce using rule 352 (limited_opt -> .)
    LIMITED         shift and go to state 750

    limited_opt                    shift and go to state 751

state 630

    (48) type_def -> derived_type .

    ;               reduce using rule 48 (type_def -> derived_type .)


state 631

    (76) real_type -> fixed_type .

    ;               reduce using rule 76 (real_type -> fixed_type .)


state 632

    (71) integer_type -> MOD . expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 752

state 633

    (36) type_decl -> TYPE ID discrim_part_opt type_completion ; .

    TASK            reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    PROTECTED       reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    error           reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    USE             reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    PRAGMA          reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    PACKAGE         reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    TYPE            reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    SUBTYPE         reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    FOR             reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    PROCEDURE       reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    FUNCTION        reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    GENERIC         reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    ID              reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    BEGIN           reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    PRIVATE         reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)
    END             reduce using rule 36 (type_decl -> TYPE ID discrim_part_opt type_completion ; .)


state 634

    (55) decimal_digits_constraint -> DIGITS . expression range_constr_opt
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 753

state 635

    (51) subtype_ind -> name constraint .

    WITH            reduce using rule 51 (subtype_ind -> name constraint .)
    ;               reduce using rule 51 (subtype_ind -> name constraint .)
    RENAMES         reduce using rule 51 (subtype_ind -> name constraint .)
    ASSIGNMENT      reduce using rule 51 (subtype_ind -> name constraint .)


state 636

    (53) constraint -> range_constraint .

    ;               reduce using rule 53 (constraint -> range_constraint .)
    RENAMES         reduce using rule 53 (constraint -> range_constraint .)
    ASSIGNMENT      reduce using rule 53 (constraint -> range_constraint .)
    WITH            reduce using rule 53 (constraint -> range_constraint .)


state 637

    (54) constraint -> decimal_digits_constraint .

    ;               reduce using rule 54 (constraint -> decimal_digits_constraint .)
    RENAMES         reduce using rule 54 (constraint -> decimal_digits_constraint .)
    ASSIGNMENT      reduce using rule 54 (constraint -> decimal_digits_constraint .)
    WITH            reduce using rule 54 (constraint -> decimal_digits_constraint .)


state 638

    (50) subtype_decl -> SUBTYPE ID IS subtype_ind ; .

    error           reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    USE             reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    PRAGMA          reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    TYPE            reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    SUBTYPE         reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    TASK            reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    PACKAGE         reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    PROTECTED       reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    FOR             reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    GENERIC         reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    PROCEDURE       reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    FUNCTION        reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    ID              reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    PRIVATE         reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    END             reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)
    BEGIN           reduce using rule 50 (subtype_decl -> SUBTYPE ID IS subtype_ind ; .)


state 639

    (359) rename_decl -> def_id_s : EXCEPTION renames ; .

    error           reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    USE             reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PRAGMA          reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    TYPE            reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    SUBTYPE         reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    TASK            reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PACKAGE         reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PROTECTED       reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    FOR             reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    GENERIC         reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PROCEDURE       reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    FUNCTION        reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    ID              reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PRIVATE         reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    END             reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    BEGIN           reduce using rule 359 (rename_decl -> def_id_s : EXCEPTION renames ; .)


state 640

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT expression . ;
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ;               shift and go to state 754
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 641

    (82) unconstr_array_type -> ARRAY ( . index_s ) OF component_subtype_def
    (90) iter_index_constraint -> ( . iter_discrete_range_s )
    (87) index_s -> . index
    (88) index_s -> . index_s , index
    (91) iter_discrete_range_s -> . discrete_range
    (92) iter_discrete_range_s -> . iter_discrete_range_s , discrete_range
    (89) index -> . name RANGE BOX
    (93) discrete_range -> . name range_constr_opt
    (94) discrete_range -> . range
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    iter_discrete_range_s          shift and go to state 755
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    simple_expression              shift and go to state 366
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    index                          shift and go to state 756
    index_s                        shift and go to state 757
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    primary                        shift and go to state 123
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    discrete_range                 shift and go to state 758
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 759
    operator_symbol                shift and go to state 139
    range                          shift and go to state 692

state 642

    (83) constr_array_type -> ARRAY iter_index_constraint . OF component_subtype_def

    OF              shift and go to state 760


state 643

    (34) init_opt -> ASSIGNMENT . expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 761

state 644

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt . ;

    ;               shift and go to state 762


state 645

    (358) rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames . ;

    ;               shift and go to state 763


state 646

    (462) body_stub -> PROTECTED BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 764


state 647

    (344) private_part -> PRIVATE decl_item_s .

    END             reduce using rule 344 (private_part -> PRIVATE decl_item_s .)


state 648

    (342) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END . c_id_opt
    (345) c_id_opt -> .
    (346) c_id_opt -> . compound_name
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ;               reduce using rule 345 (c_id_opt -> .)
    ID              shift and go to state 41

    simple_name                    shift and go to state 42
    compound_name                  shift and go to state 513
    c_id_opt                       shift and go to state 765

state 649

    (459) body_stub -> TASK BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 766


state 650

    (460) body_stub -> PACKAGE BODY compound_name . IS SEPARATE ;
    (165) compound_name -> compound_name . . simple_name

    IS              shift and go to state 767
    .               shift and go to state 120


state 651

    (329) param_s -> param_s ; param .

    )               reduce using rule 329 (param_s -> param_s ; param .)
    ;               reduce using rule 329 (param_s -> param_s ; param .)


state 652

    (348) pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .

    TASK            reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    PROTECTED       reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    error           reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    USE             reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    PRAGMA          reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    PACKAGE         reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    TYPE            reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    SUBTYPE         reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    FOR             reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    PROCEDURE       reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    FUNCTION        reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    GENERIC         reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    ID              reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    BEGIN           reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    END             reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    PRIVATE         reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    WITH            reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    SEPARATE        reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)
    $end            reduce using rule 348 (pkg_body -> pkg_start decl_part body_opt END c_id_opt ; .)


state 653

    (482) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN . name subp_default ;
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 768
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    indexed_comp                   shift and go to state 130
    operator_symbol                shift and go to state 139
    simple_name                    shift and go to state 160

state 654

    (483) generic_formal -> WITH PACKAGE simple_name IS NEW . name ( BOX ) ;
    (484) generic_formal -> WITH PACKAGE simple_name IS NEW . name ;
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 769
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 655

    (490) subp_default -> IS . name
    (491) subp_default -> IS . BOX
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    BOX             shift and go to state 770
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 771
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 656

    (481) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default . ;

    ;               shift and go to state 772


state 657

    (330) param -> def_id_s : mode mark init_opt .

    )               reduce using rule 330 (param -> def_id_s : mode mark init_opt .)
    ;               reduce using rule 330 (param -> def_id_s : mode mark init_opt .)


state 658

    (504) generic_derived_type -> ABSTRACT . NEW subtype_ind WITH PRIVATE
    (102) tagged_opt -> ABSTRACT . TAGGED

    NEW             shift and go to state 773
    TAGGED          shift and go to state 736


state 659

    (480) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def . ;

    ;               shift and go to state 774


state 660

    (502) generic_derived_type -> NEW . subtype_ind
    (503) generic_derived_type -> NEW . subtype_ind WITH PRIVATE
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 490
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    subtype_ind                    shift and go to state 775
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 661

    (501) generic_type_def -> generic_derived_type .

    ;               reduce using rule 501 (generic_type_def -> generic_derived_type .)


state 662

    (497) generic_type_def -> DIGITS . BOX

    BOX             shift and go to state 776


state 663

    (492) generic_type_def -> ( . BOX )

    BOX             shift and go to state 777


state 664

    (500) generic_type_def -> private_type .

    ;               reduce using rule 500 (generic_type_def -> private_type .)


state 665

    (493) generic_type_def -> RANGE . BOX

    BOX             shift and go to state 778


state 666

    (499) generic_type_def -> access_type .

    ;               reduce using rule 499 (generic_type_def -> access_type .)


state 667

    (498) generic_type_def -> array_type .

    ;               reduce using rule 498 (generic_type_def -> array_type .)


state 668

    (351) private_type -> tagged_opt . limited_opt PRIVATE
    (352) limited_opt -> .
    (353) limited_opt -> . LIMITED

    PRIVATE         reduce using rule 352 (limited_opt -> .)
    LIMITED         shift and go to state 750

    limited_opt                    shift and go to state 779

state 669

    (495) generic_type_def -> DELTA . BOX
    (496) generic_type_def -> DELTA . BOX DIGITS BOX

    BOX             shift and go to state 780


state 670

    (494) generic_type_def -> MOD . BOX

    BOX             shift and go to state 781


state 671

    (488) generic_discrim_part_opt -> ( BOX ) .

    IS              reduce using rule 488 (generic_discrim_part_opt -> ( BOX ) .)


state 672

    (64) range -> name SINGLEQUOTE RANGE ( . expression )
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 782

state 673

    (195) aggregate -> ( expression WITH value_s ) .

    DOUBLESTAR      reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    *               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    /               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    MOD             reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    REM             reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    =               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    NOTEQUAL        reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    <               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    LEQUAL          reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    >               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    GEQUAL          reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    IN              reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    NOT             reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    +               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    -               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    &               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    AND             reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    OR              reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    XOR             reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    )               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    ,               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    DOUBLEDOT       reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    WITH            reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    ARROW           reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    |               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    ;               reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    IS              reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    THEN            reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    LOOP            reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    RANGE           reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    DIGITS          reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    RENAMES         reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)
    ASSIGNMENT      reduce using rule 195 (aggregate -> ( expression WITH value_s ) .)


state 674

    (196) aggregate -> ( expression WITH NuLL RECORD . )

    )               shift and go to state 783


state 675

    (172) value_s -> value_s , value .

    )               reduce using rule 172 (value_s -> value_s , value .)
    ,               reduce using rule 172 (value_s -> value_s , value .)


state 676

    (390) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt ;

    IS              shift and go to state 784


state 677

    (373) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt ;

    IS              shift and go to state 785


state 678

    (462) body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .

    error           reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    USE             reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    TYPE            reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    TASK            reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PACKAGE         reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    FOR             reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    GENERIC         reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    ID              reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    END             reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    BEGIN           reduce using rule 462 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)


state 679

    (394) prot_op_body -> subprog_body .

    PRAGMA          reduce using rule 394 (prot_op_body -> subprog_body .)
    END             reduce using rule 394 (prot_op_body -> subprog_body .)
    ENTRY           reduce using rule 394 (prot_op_body -> subprog_body .)
    PROCEDURE       reduce using rule 394 (prot_op_body -> subprog_body .)
    FUNCTION        reduce using rule 394 (prot_op_body -> subprog_body .)


state 680

    (395) prot_op_body -> subprog_spec . ;
    (337) subprog_spec_is_push -> subprog_spec . IS

    ;               shift and go to state 786
    IS              shift and go to state 542


state 681

    (390) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END . id_opt ;
    (300) id_opt -> .
    (301) id_opt -> . designator
    (323) designator -> . compound_name
    (324) designator -> . STRLITERAL
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ;               reduce using rule 300 (id_opt -> .)
    STRLITERAL      shift and go to state 114
    ID              shift and go to state 41

    compound_name                  shift and go to state 116
    id_opt                         shift and go to state 787
    designator                     shift and go to state 471
    simple_name                    shift and go to state 42

state 682

    (393) prot_op_body -> entry_body .

    PRAGMA          reduce using rule 393 (prot_op_body -> entry_body .)
    END             reduce using rule 393 (prot_op_body -> entry_body .)
    ENTRY           reduce using rule 393 (prot_op_body -> entry_body .)
    PROCEDURE       reduce using rule 393 (prot_op_body -> entry_body .)
    FUNCTION        reduce using rule 393 (prot_op_body -> entry_body .)


state 683

    (392) prot_op_body_s -> prot_op_body_s prot_op_body . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 788

state 684

    (400) entry_body -> ENTRY . ID formal_part_opt WHEN condition entry_body_part
    (401) entry_body -> ENTRY . ID ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part

    ID              shift and go to state 789


state 685

    (379) prot_private_opt -> PRIVATE prot_elem_decl_s .
    (387) prot_elem_decl_s -> prot_elem_decl_s . prot_elem_decl
    (388) prot_elem_decl -> . prot_op_decl
    (389) prot_elem_decl -> . comp_decl
    (382) prot_op_decl -> . entry_decl
    (383) prot_op_decl -> . subprog_spec ;
    (384) prot_op_decl -> . rep_spec
    (385) prot_op_decl -> . pragma
    (110) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (111) comp_decl -> . error ;
    (398) entry_decl -> . ENTRY ID formal_part_opt ;
    (399) entry_decl -> . ENTRY ID ( discrete_range ) formal_part_opt ;
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (26) def_id -> . ID

    END             reduce using rule 379 (prot_private_opt -> PRIVATE prot_elem_decl_s .)
    error           shift and go to state 794
    ENTRY           shift and go to state 553
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    PRAGMA          shift and go to state 4
    FOR             shift and go to state 64
    ID              shift and go to state 91

    rep_spec                       shift and go to state 547
    entry_decl                     shift and go to state 548
    address_spec                   shift and go to state 53
    record_type_spec               shift and go to state 69
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 550
    def_id_s                       shift and go to state 790
    comp_decl                      shift and go to state 791
    def_id                         shift and go to state 88
    pragma                         shift and go to state 552
    prot_op_decl                   shift and go to state 792
    prot_elem_decl                 shift and go to state 793

state 686

    (383) prot_op_decl -> subprog_spec ; .

    PRIVATE         reduce using rule 383 (prot_op_decl -> subprog_spec ; .)
    ENTRY           reduce using rule 383 (prot_op_decl -> subprog_spec ; .)
    PROCEDURE       reduce using rule 383 (prot_op_decl -> subprog_spec ; .)
    FUNCTION        reduce using rule 383 (prot_op_decl -> subprog_spec ; .)
    PRAGMA          reduce using rule 383 (prot_op_decl -> subprog_spec ; .)
    FOR             reduce using rule 383 (prot_op_decl -> subprog_spec ; .)
    END             reduce using rule 383 (prot_op_decl -> subprog_spec ; .)
    error           reduce using rule 383 (prot_op_decl -> subprog_spec ; .)
    ID              reduce using rule 383 (prot_op_decl -> subprog_spec ; .)


state 687

    (377) prot_def -> IS prot_op_decl_s prot_private_opt END . id_opt
    (300) id_opt -> .
    (301) id_opt -> . designator
    (323) designator -> . compound_name
    (324) designator -> . STRLITERAL
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ;               reduce using rule 300 (id_opt -> .)
    STRLITERAL      shift and go to state 114
    ID              shift and go to state 41

    designator                     shift and go to state 471
    id_opt                         shift and go to state 795
    compound_name                  shift and go to state 116
    simple_name                    shift and go to state 42

state 688

    (398) entry_decl -> ENTRY ID . formal_part_opt ;
    (399) entry_decl -> ENTRY ID . ( discrete_range ) formal_part_opt ;
    (325) formal_part_opt -> .
    (326) formal_part_opt -> . formal_part
    (327) formal_part -> . ( param_s )

    (               shift and go to state 796
    ;               reduce using rule 325 (formal_part_opt -> .)

    formal_part                    shift and go to state 191
    formal_part_opt                shift and go to state 797

state 689

    (413) delay_stmt -> DELAY UNTIL expression ; .

    LEFTLABEL       reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    error           reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    PRAGMA          reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    NuLL            reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    EXIT            reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    RETURN          reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    GOTO            reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    DELAY           reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    ABORT           reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    RAISE           reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    REQUEUE         reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    IF              reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    CASE            reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    ID              reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    ACCEPT          reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    SELECT          reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    STRLITERAL      reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    WHILE           reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    DECLARE         reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    FOR             reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    LOOP            reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    BEGIN           reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    OR              reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    ELSE            reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    END             reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    WHEN            reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    ELSIF           reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    EXCEPTION       reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)
    THEN            reduce using rule 413 (delay_stmt -> DELAY UNTIL expression ; .)


state 690

    (295) iteration -> iter_part reverse_opt discrete_range .

    LOOP            reduce using rule 295 (iteration -> iter_part reverse_opt discrete_range .)


state 691

    (93) discrete_range -> name . range_constr_opt
    (63) range -> name . SINGLEQUOTE RANGE
    (64) range -> name . SINGLEQUOTE RANGE ( expression )
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id
    (240) primary -> name .
    (246) qualified -> name . SINGLEQUOTE parenthesized_primary
    (95) range_constr_opt -> .
    (96) range_constr_opt -> . range_constraint
    (61) range_constraint -> . RANGE range

    SINGLEQUOTE     shift and go to state 379
    (               shift and go to state 249
    .               shift and go to state 250
    DOUBLESTAR      reduce using rule 240 (primary -> name .)
    *               reduce using rule 240 (primary -> name .)
    /               reduce using rule 240 (primary -> name .)
    MOD             reduce using rule 240 (primary -> name .)
    REM             reduce using rule 240 (primary -> name .)
    DOUBLEDOT       reduce using rule 240 (primary -> name .)
    +               reduce using rule 240 (primary -> name .)
    -               reduce using rule 240 (primary -> name .)
    &               reduce using rule 240 (primary -> name .)
    LOOP            reduce using rule 95 (range_constr_opt -> .)
    )               reduce using rule 95 (range_constr_opt -> .)
    ,               reduce using rule 95 (range_constr_opt -> .)
    RANGE           shift and go to state 378

    range_constr_opt               shift and go to state 798
    range_constraint               shift and go to state 799

state 692

    (94) discrete_range -> range .

    )               reduce using rule 94 (discrete_range -> range .)
    ,               reduce using rule 94 (discrete_range -> range .)
    LOOP            reduce using rule 94 (discrete_range -> range .)


state 693

    (296) iter_part -> FOR ID IN .

    REVERSE         reduce using rule 296 (iter_part -> FOR ID IN .)
    ID              reduce using rule 296 (iter_part -> FOR ID IN .)
    STRLITERAL      reduce using rule 296 (iter_part -> FOR ID IN .)
    +               reduce using rule 296 (iter_part -> FOR ID IN .)
    -               reduce using rule 296 (iter_part -> FOR ID IN .)
    NOT             reduce using rule 296 (iter_part -> FOR ID IN .)
    ABS             reduce using rule 296 (iter_part -> FOR ID IN .)
    NuLL            reduce using rule 296 (iter_part -> FOR ID IN .)
    NEW             reduce using rule 296 (iter_part -> FOR ID IN .)
    (               reduce using rule 296 (iter_part -> FOR ID IN .)
    NUMLITERAL_BASE_INT reduce using rule 296 (iter_part -> FOR ID IN .)
    NUMLITERAL_BASE_FLOAT reduce using rule 296 (iter_part -> FOR ID IN .)
    NUMLITERAL_INT  reduce using rule 296 (iter_part -> FOR ID IN .)
    NUMLITERAL_FLOAT reduce using rule 296 (iter_part -> FOR ID IN .)
    CHARLITERAL     reduce using rule 296 (iter_part -> FOR ID IN .)


state 694

    (290) loop_stmt -> label_opt iteration m basic_loop . id_opt ;
    (300) id_opt -> .
    (301) id_opt -> . designator
    (323) designator -> . compound_name
    (324) designator -> . STRLITERAL
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ;               reduce using rule 300 (id_opt -> .)
    STRLITERAL      shift and go to state 114
    ID              shift and go to state 41

    designator                     shift and go to state 471
    id_opt                         shift and go to state 800
    compound_name                  shift and go to state 116
    simple_name                    shift and go to state 42

state 695

    (299) basic_loop -> LOOP . statement_s END LOOP
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 801
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 696

    (302) block -> label_opt block_decl block_body END . id_opt ;
    (300) id_opt -> .
    (301) id_opt -> . designator
    (323) designator -> . compound_name
    (324) designator -> . STRLITERAL
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ;               reduce using rule 300 (id_opt -> .)
    STRLITERAL      shift and go to state 114
    ID              shift and go to state 41

    designator                     shift and go to state 471
    id_opt                         shift and go to state 802
    compound_name                  shift and go to state 116
    simple_name                    shift and go to state 42

state 697

    (294) iteration -> WHILE m condition .

    LOOP            reduce using rule 294 (iteration -> WHILE m condition .)


state 698

    (276) assign_stmt -> name ASSIGNMENT expression ; .

    EXCEPTION       reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    LEFTLABEL       reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    error           reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    PRAGMA          reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    NuLL            reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    EXIT            reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    RETURN          reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    GOTO            reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    DELAY           reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    ABORT           reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    RAISE           reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    REQUEUE         reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    IF              reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    CASE            reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    ID              reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    ACCEPT          reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    SELECT          reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    STRLITERAL      reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    WHILE           reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    DECLARE         reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    FOR             reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    LOOP            reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    BEGIN           reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    END             reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    OR              reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    ELSE            reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    THEN            reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    ELSIF           reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)
    WHEN            reduce using rule 276 (assign_stmt -> name ASSIGNMENT expression ; .)


state 699

    (26) def_id -> ID .
    (163) simple_name -> ID .

    :               reduce using rule 26 (def_id -> ID .)
    ,               reduce using rule 26 (def_id -> ID .)
    SINGLEQUOTE     reduce using rule 163 (simple_name -> ID .)
    (               reduce using rule 163 (simple_name -> ID .)
    .               reduce using rule 163 (simple_name -> ID .)
    DOUBLESTAR      reduce using rule 163 (simple_name -> ID .)
    *               reduce using rule 163 (simple_name -> ID .)
    /               reduce using rule 163 (simple_name -> ID .)
    MOD             reduce using rule 163 (simple_name -> ID .)
    REM             reduce using rule 163 (simple_name -> ID .)
    =               reduce using rule 163 (simple_name -> ID .)
    NOTEQUAL        reduce using rule 163 (simple_name -> ID .)
    <               reduce using rule 163 (simple_name -> ID .)
    LEQUAL          reduce using rule 163 (simple_name -> ID .)
    >               reduce using rule 163 (simple_name -> ID .)
    GEQUAL          reduce using rule 163 (simple_name -> ID .)
    IN              reduce using rule 163 (simple_name -> ID .)
    NOT             reduce using rule 163 (simple_name -> ID .)
    +               reduce using rule 163 (simple_name -> ID .)
    -               reduce using rule 163 (simple_name -> ID .)
    &               reduce using rule 163 (simple_name -> ID .)
    )               reduce using rule 163 (simple_name -> ID .)
    AND             reduce using rule 163 (simple_name -> ID .)
    OR              reduce using rule 163 (simple_name -> ID .)
    XOR             reduce using rule 163 (simple_name -> ID .)


state 700

    (411) entry_name -> entry_name ( expression . )
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    )               shift and go to state 803
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 701

    (430) cond_entry_call -> SELECT entry_call stmts_opt ELSE . statement_s END SELECT ;
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 804
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 702

    (429) timed_entry_call -> SELECT entry_call stmts_opt OR . delay_stmt stmts_opt END SELECT ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;

    DELAY           shift and go to state 267

    delay_stmt                     shift and go to state 805

state 703

    (428) async_select -> SELECT delay_or_entry_alt THEN ABORT . statement_s END SELECT ;
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 806
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    procedure_call                 shift and go to state 282
    block                          shift and go to state 289

state 704

    (420) guarded_select_alt -> WHEN condition ARROW . select_alt
    (423) select_alt -> . accept_stmt stmts_opt
    (424) select_alt -> . delay_stmt stmts_opt
    (425) select_alt -> . TERMINATE ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt

    TERMINATE       shift and go to state 449
    DELAY           shift and go to state 267
    ACCEPT          shift and go to state 281

    delay_stmt                     shift and go to state 807
    accept_hdr                     shift and go to state 297
    accept_stmt                    shift and go to state 440
    select_alt                     shift and go to state 808

state 705

    (418) select_wait -> SELECT guarded_select_alt or_select else_opt . END SELECT ;

    END             shift and go to state 809


state 706

    (422) or_select -> or_select OR . guarded_select_alt
    (419) guarded_select_alt -> . select_alt
    (420) guarded_select_alt -> . WHEN condition ARROW select_alt
    (423) select_alt -> . accept_stmt stmts_opt
    (424) select_alt -> . delay_stmt stmts_opt
    (425) select_alt -> . TERMINATE ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt

    WHEN            shift and go to state 444
    TERMINATE       shift and go to state 449
    DELAY           shift and go to state 267
    ACCEPT          shift and go to state 281

    delay_stmt                     shift and go to state 807
    accept_hdr                     shift and go to state 297
    accept_stmt                    shift and go to state 440
    guarded_select_alt             shift and go to state 810
    select_alt                     shift and go to state 446

state 707

    (288) alternative_s -> alternative_s alternative .

    END             reduce using rule 288 (alternative_s -> alternative_s alternative .)
    WHEN            reduce using rule 288 (alternative_s -> alternative_s alternative .)


state 708

    (285) case_stmt -> case_hdr pragma_s alternative_s END . CASE ;

    CASE            shift and go to state 811


state 709

    (289) alternative -> WHEN . choice_s ARROW statement_s
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 228
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 389
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    allocator                      shift and go to state 131
    choice_s                       shift and go to state 812
    operator_symbol                shift and go to state 139
    factor                         shift and go to state 138
    choice                         shift and go to state 232
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    discrete_with_range            shift and go to state 525
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 235
    range                          shift and go to state 237
    expression                     shift and go to state 526

state 710

    (474) requeue_stmt -> REQUEUE name WITH ABORT . ;

    ;               shift and go to state 813


state 711

    (408) accept_stmt -> accept_hdr DO handled_stmt_s END . id_opt ;
    (300) id_opt -> .
    (301) id_opt -> . designator
    (323) designator -> . compound_name
    (324) designator -> . STRLITERAL
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ;               reduce using rule 300 (id_opt -> .)
    STRLITERAL      shift and go to state 114
    ID              shift and go to state 41

    designator                     shift and go to state 471
    id_opt                         shift and go to state 814
    compound_name                  shift and go to state 116
    simple_name                    shift and go to state 42

state 712

    (309) exit_stmt -> EXIT name_opt when_opt ; .

    LEFTLABEL       reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    error           reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    PRAGMA          reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    NuLL            reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    EXIT            reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    RETURN          reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    GOTO            reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    DELAY           reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    ABORT           reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    RAISE           reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    REQUEUE         reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    IF              reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    CASE            reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    ID              reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    ACCEPT          reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    SELECT          reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    STRLITERAL      reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    WHILE           reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    DECLARE         reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    FOR             reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    LOOP            reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    BEGIN           reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    OR              reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    ELSE            reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    THEN            reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    END             reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    WHEN            reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    EXCEPTION       reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)
    ELSIF           reduce using rule 309 (exit_stmt -> EXIT name_opt when_opt ; .)


state 713

    (313) when_opt -> WHEN condition .

    ;               reduce using rule 313 (when_opt -> WHEN condition .)


state 714

    (466) exception_handler -> WHEN except_choice_s . ARROW statement_s
    (469) except_choice_s -> except_choice_s . | except_choice

    ARROW           shift and go to state 815
    |               shift and go to state 816


state 715

    (468) except_choice_s -> except_choice .

    ARROW           reduce using rule 468 (except_choice_s -> except_choice .)
    |               reduce using rule 468 (except_choice_s -> except_choice .)


state 716

    (471) except_choice -> OTHERS .

    ARROW           reduce using rule 471 (except_choice -> OTHERS .)
    |               reduce using rule 471 (except_choice -> OTHERS .)


state 717

    (467) exception_handler -> WHEN ID . : except_choice_s ARROW statement_s
    (163) simple_name -> ID .

    :               shift and go to state 817
    (               reduce using rule 163 (simple_name -> ID .)
    .               reduce using rule 163 (simple_name -> ID .)
    SINGLEQUOTE     reduce using rule 163 (simple_name -> ID .)
    ARROW           reduce using rule 163 (simple_name -> ID .)
    |               reduce using rule 163 (simple_name -> ID .)


state 718

    (470) except_choice -> name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    ARROW           reduce using rule 470 (except_choice -> name .)
    |               reduce using rule 470 (except_choice -> name .)
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 719

    (284) else_opt -> ELSE m . statement_s
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 818
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 720

    (277) if_stmt -> IF cond_clause_s else_opt END . IF ;

    IF              shift and go to state 819


state 721

    (279) cond_clause_s -> cond_clause ELSIF m . cond_clause_s
    (278) cond_clause_s -> . cond_clause
    (279) cond_clause_s -> . cond_clause ELSIF m cond_clause_s
    (280) cond_clause -> . cond_part m statement_s n
    (281) cond_part -> . condition THEN
    (282) condition -> . expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    cond_clause_s                  shift and go to state 820
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    simple_name                    shift and go to state 160
    indexed_comp                   shift and go to state 130
    cond_clause                    shift and go to state 467
    cond_part                      shift and go to state 468
    literal                        shift and go to state 137
    allocator                      shift and go to state 131
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    condition                      shift and go to state 469
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 470

state 722

    (280) cond_clause -> cond_part m statement_s . n
    (250) statement_s -> statement_s . m statement
    (520) n -> .
    (519) m -> .

    ELSIF           reduce using rule 520 (n -> .)
    ELSE            reduce using rule 520 (n -> .)
    END             reduce using rule 520 (n -> .)
    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)

    m                              shift and go to state 461
    n                              shift and go to state 821

state 723

    (512) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s . END RECORD ;
    (516) comp_loc_s -> comp_loc_s . mark AT expression RANGE range ;
    (160) mark -> . simple_name
    (161) mark -> . mark SINGLEQUOTE attribute_id
    (162) mark -> . mark . simple_name
    (163) simple_name -> . ID

    END             shift and go to state 822
    ID              shift and go to state 41

    mark                           shift and go to state 823
    simple_name                    shift and go to state 168

state 724

    (514) align_opt -> AT MOD . expression ;
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 824

state 725

    (517) address_spec -> FOR mark USE AT expression ; .

    error           reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    USE             reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    PRAGMA          reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    TYPE            reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    SUBTYPE         reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    TASK            reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    PACKAGE         reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    PROTECTED       reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    FOR             reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    GENERIC         reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    PROCEDURE       reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    FUNCTION        reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    ID              reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    PRIVATE         reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    END             reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    ENTRY           reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)
    BEGIN           reduce using rule 517 (address_spec -> FOR mark USE AT expression ; .)


state 726

    (459) body_stub -> TASK BODY simple_name IS SEPARATE ; .

    error           reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    USE             reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    TYPE            reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    TASK            reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PACKAGE         reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    FOR             reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    GENERIC         reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    ID              reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    END             reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    BEGIN           reduce using rule 459 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)


state 727

    (373) task_body -> TASK BODY simple_name IS decl_part block_body . END id_opt ;

    END             shift and go to state 825


state 728

    (405) rep_spec_s -> rep_spec_s rep_spec . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 826

state 729

    (372) task_private_opt -> PRIVATE . entry_decl_s rep_spec_s
    (396) entry_decl_s -> . pragma_s
    (397) entry_decl_s -> . entry_decl_s entry_decl pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    entry_decl_s                   shift and go to state 827
    pragma_s                       shift and go to state 481

state 730

    (370) task_def -> IS entry_decl_s rep_spec_s task_private_opt . END id_opt

    END             shift and go to state 828


state 731

    (397) entry_decl_s -> entry_decl_s entry_decl pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    ENTRY           reduce using rule 397 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    FOR             reduce using rule 397 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    END             reduce using rule 397 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    PRIVATE         reduce using rule 397 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 732

    (460) body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .

    error           reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    USE             reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    TYPE            reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    TASK            reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PACKAGE         reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    FOR             reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    GENERIC         reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    ID              reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    END             reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    BEGIN           reduce using rule 460 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)


state 733

    (114) discrim_spec_s -> discrim_spec_s ; discrim_spec .

    )               reduce using rule 114 (discrim_spec_s -> discrim_spec_s ; discrim_spec .)
    ;               reduce using rule 114 (discrim_spec_s -> discrim_spec_s ; discrim_spec .)


state 734

    (118) access_opt -> ACCESS .

    ID              reduce using rule 118 (access_opt -> ACCESS .)


state 735

    (115) discrim_spec -> def_id_s : access_opt . mark init_opt
    (160) mark -> . simple_name
    (161) mark -> . mark SINGLEQUOTE attribute_id
    (162) mark -> . mark . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    mark                           shift and go to state 829
    simple_name                    shift and go to state 168

state 736

    (102) tagged_opt -> ABSTRACT TAGGED .

    LIMITED         reduce using rule 102 (tagged_opt -> ABSTRACT TAGGED .)
    PRIVATE         reduce using rule 102 (tagged_opt -> ABSTRACT TAGGED .)
    RECORD          reduce using rule 102 (tagged_opt -> ABSTRACT TAGGED .)
    NuLL            reduce using rule 102 (tagged_opt -> ABSTRACT TAGGED .)


state 737

    (59) derived_type -> ABSTRACT NEW . subtype_ind WITH PRIVATE
    (60) derived_type -> ABSTRACT NEW . subtype_ind WITH record_def
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 490
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    subtype_ind                    shift and go to state 830
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 738

    (56) derived_type -> NEW subtype_ind .
    (57) derived_type -> NEW subtype_ind . WITH PRIVATE
    (58) derived_type -> NEW subtype_ind . WITH record_def

    ;               reduce using rule 56 (derived_type -> NEW subtype_ind .)
    WITH            shift and go to state 831


state 739

    (65) enumeration_type -> ( enum_id_s . )
    (67) enum_id_s -> enum_id_s . , enum_id

    )               shift and go to state 832
    ,               shift and go to state 833


state 740

    (69) enum_id -> CHARLITERAL .

    )               reduce using rule 69 (enum_id -> CHARLITERAL .)
    ,               reduce using rule 69 (enum_id -> CHARLITERAL .)


state 741

    (68) enum_id -> ID .

    )               reduce using rule 68 (enum_id -> ID .)
    ,               reduce using rule 68 (enum_id -> ID .)


state 742

    (66) enum_id_s -> enum_id .

    )               reduce using rule 66 (enum_id_s -> enum_id .)
    ,               reduce using rule 66 (enum_id_s -> enum_id .)


state 743

    (77) float_type -> DIGITS expression . range_spec_opt
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (73) range_spec_opt -> .
    (74) range_spec_opt -> . range_spec
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE
    (72) range_spec -> . range_constraint
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 73 (range_spec_opt -> .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254
    RANGE           shift and go to state 378

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256
    range_constraint               shift and go to state 612
    range_spec                     shift and go to state 835
    range_spec_opt                 shift and go to state 834

state 744

    (78) fixed_type -> DELTA expression . range_spec
    (79) fixed_type -> DELTA expression . DIGITS expression range_spec_opt
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (72) range_spec -> . range_constraint
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE
    (61) range_constraint -> . RANGE range

    DIGITS          shift and go to state 836
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254
    RANGE           shift and go to state 378

    logical                        shift and go to state 255
    range_constraint               shift and go to state 612
    range_spec                     shift and go to state 837
    short_circuit                  shift and go to state 256

state 745

    (131) access_type -> ACCESS CONSTANT . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 490
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    subtype_ind                    shift and go to state 838
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 746

    (133) access_type -> ACCESS prot_opt . PROCEDURE formal_part_opt
    (134) access_type -> ACCESS prot_opt . FUNCTION formal_part_opt RETURN mark

    PROCEDURE       shift and go to state 840
    FUNCTION        shift and go to state 839


state 747

    (136) prot_opt -> PROTECTED .

    PROCEDURE       reduce using rule 136 (prot_opt -> PROTECTED .)
    FUNCTION        reduce using rule 136 (prot_opt -> PROTECTED .)


state 748

    (132) access_type -> ACCESS ALL . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 490
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    subtype_ind                    shift and go to state 841
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 749

    (130) access_type -> ACCESS subtype_ind .

    ;               reduce using rule 130 (access_type -> ACCESS subtype_ind .)


state 750

    (353) limited_opt -> LIMITED .

    PRIVATE         reduce using rule 353 (limited_opt -> LIMITED .)
    RECORD          reduce using rule 353 (limited_opt -> LIMITED .)
    NuLL            reduce using rule 353 (limited_opt -> LIMITED .)


state 751

    (97) record_type -> tagged_opt limited_opt . record_def
    (351) private_type -> tagged_opt limited_opt . PRIVATE
    (98) record_def -> . RECORD pragma_s comp_list END RECORD
    (99) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 842
    RECORD          shift and go to state 843
    NuLL            shift and go to state 844

    record_def                     shift and go to state 845

state 752

    (71) integer_type -> MOD expression .
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ;               reduce using rule 71 (integer_type -> MOD expression .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 753

    (55) decimal_digits_constraint -> DIGITS expression . range_constr_opt
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (95) range_constr_opt -> .
    (96) range_constr_opt -> . range_constraint
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 95 (range_constr_opt -> .)
    RENAMES         reduce using rule 95 (range_constr_opt -> .)
    ASSIGNMENT      reduce using rule 95 (range_constr_opt -> .)
    WITH            reduce using rule 95 (range_constr_opt -> .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254
    RANGE           shift and go to state 378

    range_constr_opt               shift and go to state 846
    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256
    range_constraint               shift and go to state 799

state 754

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .

    TASK            reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PROTECTED       reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    error           reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    USE             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PRAGMA          reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PACKAGE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    TYPE            reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    SUBTYPE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    FOR             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PROCEDURE       reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    FUNCTION        reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    GENERIC         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    ID              reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    BEGIN           reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    END             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PRIVATE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)


state 755

    (90) iter_index_constraint -> ( iter_discrete_range_s . )
    (92) iter_discrete_range_s -> iter_discrete_range_s . , discrete_range

    )               shift and go to state 847
    ,               shift and go to state 848


state 756

    (87) index_s -> index .

    )               reduce using rule 87 (index_s -> index .)
    ,               reduce using rule 87 (index_s -> index .)


state 757

    (82) unconstr_array_type -> ARRAY ( index_s . ) OF component_subtype_def
    (88) index_s -> index_s . , index

    )               shift and go to state 849
    ,               shift and go to state 850


state 758

    (91) iter_discrete_range_s -> discrete_range .

    )               reduce using rule 91 (iter_discrete_range_s -> discrete_range .)
    ,               reduce using rule 91 (iter_discrete_range_s -> discrete_range .)


state 759

    (89) index -> name . RANGE BOX
    (93) discrete_range -> name . range_constr_opt
    (63) range -> name . SINGLEQUOTE RANGE
    (64) range -> name . SINGLEQUOTE RANGE ( expression )
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id
    (240) primary -> name .
    (246) qualified -> name . SINGLEQUOTE parenthesized_primary
    (95) range_constr_opt -> .
    (96) range_constr_opt -> . range_constraint
    (61) range_constraint -> . RANGE range

    RANGE           shift and go to state 851
    SINGLEQUOTE     shift and go to state 379
    (               shift and go to state 249
    .               shift and go to state 250
    DOUBLESTAR      reduce using rule 240 (primary -> name .)
    *               reduce using rule 240 (primary -> name .)
    /               reduce using rule 240 (primary -> name .)
    MOD             reduce using rule 240 (primary -> name .)
    REM             reduce using rule 240 (primary -> name .)
    DOUBLEDOT       reduce using rule 240 (primary -> name .)
    +               reduce using rule 240 (primary -> name .)
    -               reduce using rule 240 (primary -> name .)
    &               reduce using rule 240 (primary -> name .)
    )               reduce using rule 95 (range_constr_opt -> .)
    ,               reduce using rule 95 (range_constr_opt -> .)

    range_constr_opt               shift and go to state 798
    range_constraint               shift and go to state 799

state 760

    (83) constr_array_type -> ARRAY iter_index_constraint OF . component_subtype_def
    (84) component_subtype_def -> . aliased_opt subtype_ind
    (85) aliased_opt -> .
    (86) aliased_opt -> . ALIASED

    ID              reduce using rule 85 (aliased_opt -> .)
    STRLITERAL      reduce using rule 85 (aliased_opt -> .)
    ALIASED         shift and go to state 852

    aliased_opt                    shift and go to state 853
    component_subtype_def          shift and go to state 854

state 761

    (34) init_opt -> ASSIGNMENT expression .
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ;               reduce using rule 34 (init_opt -> ASSIGNMENT expression .)
    )               reduce using rule 34 (init_opt -> ASSIGNMENT expression .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 762

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .

    TASK            reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PROTECTED       reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    error           reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    USE             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PRAGMA          reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PACKAGE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    TYPE            reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    SUBTYPE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    FOR             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PROCEDURE       reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    FUNCTION        reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    GENERIC         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    ID              reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    BEGIN           reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PRIVATE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    END             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)


state 763

    (358) rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .

    error           reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    USE             reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PRAGMA          reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    TYPE            reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    SUBTYPE         reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    TASK            reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PACKAGE         reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PROTECTED       reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    FOR             reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    GENERIC         reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PROCEDURE       reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    FUNCTION        reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    ID              reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PRIVATE         reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    END             reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    BEGIN           reduce using rule 358 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)


state 764

    (462) body_stub -> PROTECTED BODY simple_name IS . SEPARATE ;

    SEPARATE        shift and go to state 543


state 765

    (342) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .

    ;               reduce using rule 342 (pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .)


state 766

    (459) body_stub -> TASK BODY simple_name IS . SEPARATE ;

    SEPARATE        shift and go to state 601


state 767

    (460) body_stub -> PACKAGE BODY compound_name IS . SEPARATE ;

    SEPARATE        shift and go to state 606


state 768

    (482) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name . subp_default ;
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id
    (489) subp_default -> .
    (490) subp_default -> . IS name
    (491) subp_default -> . IS BOX

    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260
    ;               reduce using rule 489 (subp_default -> .)
    IS              shift and go to state 655

    subp_default                   shift and go to state 855

state 769

    (483) generic_formal -> WITH PACKAGE simple_name IS NEW name . ( BOX ) ;
    (484) generic_formal -> WITH PACKAGE simple_name IS NEW name . ;
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    (               shift and go to state 856
    ;               shift and go to state 857
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 770

    (491) subp_default -> IS BOX .

    ;               reduce using rule 491 (subp_default -> IS BOX .)


state 771

    (490) subp_default -> IS name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    ;               reduce using rule 490 (subp_default -> IS name .)
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 772

    (481) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .

    PACKAGE         reduce using rule 481 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    PROCEDURE       reduce using rule 481 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    FUNCTION        reduce using rule 481 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    TYPE            reduce using rule 481 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    WITH            reduce using rule 481 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    error           reduce using rule 481 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    USE             reduce using rule 481 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    ID              reduce using rule 481 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)


state 773

    (504) generic_derived_type -> ABSTRACT NEW . subtype_ind WITH PRIVATE
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 490
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    subtype_ind                    shift and go to state 858
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 774

    (480) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .

    PACKAGE         reduce using rule 480 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    PROCEDURE       reduce using rule 480 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    FUNCTION        reduce using rule 480 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    TYPE            reduce using rule 480 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    WITH            reduce using rule 480 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    error           reduce using rule 480 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    USE             reduce using rule 480 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    ID              reduce using rule 480 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)


state 775

    (502) generic_derived_type -> NEW subtype_ind .
    (503) generic_derived_type -> NEW subtype_ind . WITH PRIVATE

    ;               reduce using rule 502 (generic_derived_type -> NEW subtype_ind .)
    WITH            shift and go to state 859


state 776

    (497) generic_type_def -> DIGITS BOX .

    ;               reduce using rule 497 (generic_type_def -> DIGITS BOX .)


state 777

    (492) generic_type_def -> ( BOX . )

    )               shift and go to state 860


state 778

    (493) generic_type_def -> RANGE BOX .

    ;               reduce using rule 493 (generic_type_def -> RANGE BOX .)


state 779

    (351) private_type -> tagged_opt limited_opt . PRIVATE

    PRIVATE         shift and go to state 842


state 780

    (495) generic_type_def -> DELTA BOX .
    (496) generic_type_def -> DELTA BOX . DIGITS BOX

    ;               reduce using rule 495 (generic_type_def -> DELTA BOX .)
    DIGITS          shift and go to state 861


state 781

    (494) generic_type_def -> MOD BOX .

    ;               reduce using rule 494 (generic_type_def -> MOD BOX .)


state 782

    (64) range -> name SINGLEQUOTE RANGE ( expression . )
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    )               shift and go to state 862
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 783

    (196) aggregate -> ( expression WITH NuLL RECORD ) .

    DOUBLESTAR      reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    *               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    /               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    MOD             reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    REM             reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    =               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    NOTEQUAL        reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    <               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    LEQUAL          reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    >               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    GEQUAL          reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    IN              reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    NOT             reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    +               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    -               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    &               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    AND             reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    OR              reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    XOR             reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    )               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ,               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    DOUBLEDOT       reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    WITH            reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ARROW           reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    |               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ;               reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    IS              reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    THEN            reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    LOOP            reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    RANGE           reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    DIGITS          reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    RENAMES         reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ASSIGNMENT      reduce using rule 196 (aggregate -> ( expression WITH NuLL RECORD ) .)


state 784

    (390) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt ;
    (391) prot_op_body_s -> . pragma_s
    (392) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    prot_op_body_s                 shift and go to state 544
    pragma_s                       shift and go to state 545

state 785

    (373) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (348) pkg_body -> . pkg_start decl_part body_opt END c_id_opt ;
    (373) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (390) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (337) subprog_spec_is_push -> . subprog_spec IS
    (347) pkg_start -> . PACKAGE BODY compound_name IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (26) def_id -> . ID

    BEGIN           reduce using rule 137 (decl_part -> .)
    TASK            shift and go to state 68
    PROTECTED       shift and go to state 52
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    PACKAGE         shift and go to state 73
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 64
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    GENERIC         shift and go to state 21
    ID              shift and go to state 91

    decl                           shift and go to state 51
    subprog_body                   shift and go to state 60
    task_decl                      shift and go to state 61
    type_decl                      shift and go to state 57
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 62
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    decl_item                      shift and go to state 54
    subprog_spec_is_push           shift and go to state 24
    decl_part                      shift and go to state 602
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    def_id                         shift and go to state 88
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 86
    def_id_s                       shift and go to state 87
    decl_item_or_body_s1           shift and go to state 72
    task_spec                      shift and go to state 66
    body                           shift and go to state 63
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    pkg_spec                       shift and go to state 38
    rename_decl                    shift and go to state 89
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 75
    rename_unit                    shift and go to state 90
    generic_formal_part            shift and go to state 34
    subprog_decl                   shift and go to state 59
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    pkg_start                      shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 786

    (395) prot_op_body -> subprog_spec ; .

    PRAGMA          reduce using rule 395 (prot_op_body -> subprog_spec ; .)
    END             reduce using rule 395 (prot_op_body -> subprog_spec ; .)
    ENTRY           reduce using rule 395 (prot_op_body -> subprog_spec ; .)
    PROCEDURE       reduce using rule 395 (prot_op_body -> subprog_spec ; .)
    FUNCTION        reduce using rule 395 (prot_op_body -> subprog_spec ; .)


state 787

    (390) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt . ;

    ;               shift and go to state 863


state 788

    (392) prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 392 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    ENTRY           reduce using rule 392 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    PROCEDURE       reduce using rule 392 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    FUNCTION        reduce using rule 392 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 789

    (400) entry_body -> ENTRY ID . formal_part_opt WHEN condition entry_body_part
    (401) entry_body -> ENTRY ID . ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (325) formal_part_opt -> .
    (326) formal_part_opt -> . formal_part
    (327) formal_part -> . ( param_s )

    (               shift and go to state 864
    WHEN            reduce using rule 325 (formal_part_opt -> .)

    formal_part                    shift and go to state 191
    formal_part_opt                shift and go to state 865

state 790

    (110) comp_decl -> def_id_s . : component_subtype_def init_opt ;
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 866
    ,               shift and go to state 182


state 791

    (389) prot_elem_decl -> comp_decl .

    error           reduce using rule 389 (prot_elem_decl -> comp_decl .)
    ENTRY           reduce using rule 389 (prot_elem_decl -> comp_decl .)
    PROCEDURE       reduce using rule 389 (prot_elem_decl -> comp_decl .)
    FUNCTION        reduce using rule 389 (prot_elem_decl -> comp_decl .)
    PRAGMA          reduce using rule 389 (prot_elem_decl -> comp_decl .)
    FOR             reduce using rule 389 (prot_elem_decl -> comp_decl .)
    ID              reduce using rule 389 (prot_elem_decl -> comp_decl .)
    END             reduce using rule 389 (prot_elem_decl -> comp_decl .)


state 792

    (388) prot_elem_decl -> prot_op_decl .

    error           reduce using rule 388 (prot_elem_decl -> prot_op_decl .)
    ENTRY           reduce using rule 388 (prot_elem_decl -> prot_op_decl .)
    PROCEDURE       reduce using rule 388 (prot_elem_decl -> prot_op_decl .)
    FUNCTION        reduce using rule 388 (prot_elem_decl -> prot_op_decl .)
    PRAGMA          reduce using rule 388 (prot_elem_decl -> prot_op_decl .)
    FOR             reduce using rule 388 (prot_elem_decl -> prot_op_decl .)
    ID              reduce using rule 388 (prot_elem_decl -> prot_op_decl .)
    END             reduce using rule 388 (prot_elem_decl -> prot_op_decl .)


state 793

    (387) prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .

    error           reduce using rule 387 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    ENTRY           reduce using rule 387 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    PROCEDURE       reduce using rule 387 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    FUNCTION        reduce using rule 387 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    PRAGMA          reduce using rule 387 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    FOR             reduce using rule 387 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    ID              reduce using rule 387 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    END             reduce using rule 387 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)


state 794

    (111) comp_decl -> error . ;

    ;               shift and go to state 867


state 795

    (377) prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .

    ;               reduce using rule 377 (prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .)


state 796

    (399) entry_decl -> ENTRY ID ( . discrete_range ) formal_part_opt ;
    (327) formal_part -> ( . param_s )
    (93) discrete_range -> . name range_constr_opt
    (94) discrete_range -> . range
    (328) param_s -> . param
    (329) param_s -> . param_s ; param
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (330) param -> . def_id_s : mode mark init_opt
    (331) param -> . error
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (26) def_id -> . ID
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 110
    ID              shift and go to state 869
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    param                          shift and go to state 347
    simple_expression              shift and go to state 366
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    param_s                        shift and go to state 348
    literal                        shift and go to state 137
    def_id_s                       shift and go to state 106
    factor                         shift and go to state 138
    def_id                         shift and go to state 88
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    discrete_range                 shift and go to state 868
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 691
    operator_symbol                shift and go to state 139
    range                          shift and go to state 692

state 797

    (398) entry_decl -> ENTRY ID formal_part_opt . ;

    ;               shift and go to state 870


state 798

    (93) discrete_range -> name range_constr_opt .

    )               reduce using rule 93 (discrete_range -> name range_constr_opt .)
    ,               reduce using rule 93 (discrete_range -> name range_constr_opt .)
    LOOP            reduce using rule 93 (discrete_range -> name range_constr_opt .)


state 799

    (96) range_constr_opt -> range_constraint .

    ;               reduce using rule 96 (range_constr_opt -> range_constraint .)
    RENAMES         reduce using rule 96 (range_constr_opt -> range_constraint .)
    ASSIGNMENT      reduce using rule 96 (range_constr_opt -> range_constraint .)
    WITH            reduce using rule 96 (range_constr_opt -> range_constraint .)
    LOOP            reduce using rule 96 (range_constr_opt -> range_constraint .)
    )               reduce using rule 96 (range_constr_opt -> range_constraint .)
    ,               reduce using rule 96 (range_constr_opt -> range_constraint .)


state 800

    (290) loop_stmt -> label_opt iteration m basic_loop id_opt . ;

    ;               shift and go to state 871


state 801

    (299) basic_loop -> LOOP statement_s . END LOOP
    (250) statement_s -> statement_s . m statement
    (519) m -> .

    END             shift and go to state 872
    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)

    m                              shift and go to state 461

state 802

    (302) block -> label_opt block_decl block_body END id_opt . ;

    ;               shift and go to state 873


state 803

    (411) entry_name -> entry_name ( expression ) .

    (               reduce using rule 411 (entry_name -> entry_name ( expression ) .)
    ;               reduce using rule 411 (entry_name -> entry_name ( expression ) .)
    DO              reduce using rule 411 (entry_name -> entry_name ( expression ) .)


state 804

    (430) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s . END SELECT ;
    (250) statement_s -> statement_s . m statement
    (519) m -> .

    END             shift and go to state 874
    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)

    m                              shift and go to state 461

state 805

    (429) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt . stmts_opt END SELECT ;
    (431) stmts_opt -> .
    (432) stmts_opt -> . statement_s
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    END             reduce using rule 431 (stmts_opt -> .)
    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 571
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    stmts_opt                      shift and go to state 875
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 806

    (428) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s . END SELECT ;
    (250) statement_s -> statement_s . m statement
    (519) m -> .

    END             shift and go to state 876
    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)

    m                              shift and go to state 461

state 807

    (424) select_alt -> delay_stmt . stmts_opt
    (431) stmts_opt -> .
    (432) stmts_opt -> . statement_s
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    OR              reduce using rule 431 (stmts_opt -> .)
    ELSE            reduce using rule 431 (stmts_opt -> .)
    END             reduce using rule 431 (stmts_opt -> .)
    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 571
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    stmts_opt                      shift and go to state 877
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 808

    (420) guarded_select_alt -> WHEN condition ARROW select_alt .

    OR              reduce using rule 420 (guarded_select_alt -> WHEN condition ARROW select_alt .)
    ELSE            reduce using rule 420 (guarded_select_alt -> WHEN condition ARROW select_alt .)
    END             reduce using rule 420 (guarded_select_alt -> WHEN condition ARROW select_alt .)


state 809

    (418) select_wait -> SELECT guarded_select_alt or_select else_opt END . SELECT ;

    SELECT          shift and go to state 878


state 810

    (422) or_select -> or_select OR guarded_select_alt .

    OR              reduce using rule 422 (or_select -> or_select OR guarded_select_alt .)
    ELSE            reduce using rule 422 (or_select -> or_select OR guarded_select_alt .)
    END             reduce using rule 422 (or_select -> or_select OR guarded_select_alt .)


state 811

    (285) case_stmt -> case_hdr pragma_s alternative_s END CASE . ;

    ;               shift and go to state 879


state 812

    (289) alternative -> WHEN choice_s . ARROW statement_s
    (124) choice_s -> choice_s . | choice

    ARROW           shift and go to state 880
    |               shift and go to state 373


state 813

    (474) requeue_stmt -> REQUEUE name WITH ABORT ; .

    EXCEPTION       reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    LEFTLABEL       reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    error           reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    PRAGMA          reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    NuLL            reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    EXIT            reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    RETURN          reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    GOTO            reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    DELAY           reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ABORT           reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    RAISE           reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    REQUEUE         reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    IF              reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    CASE            reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ID              reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ACCEPT          reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    SELECT          reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    STRLITERAL      reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    WHILE           reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    DECLARE         reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    FOR             reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    LOOP            reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    BEGIN           reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    END             reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    OR              reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ELSE            reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    THEN            reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ELSIF           reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    WHEN            reduce using rule 474 (requeue_stmt -> REQUEUE name WITH ABORT ; .)


state 814

    (408) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt . ;

    ;               shift and go to state 881


state 815

    (466) exception_handler -> WHEN except_choice_s ARROW . statement_s
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 882
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 816

    (469) except_choice_s -> except_choice_s | . except_choice
    (470) except_choice -> . name
    (471) except_choice -> . OTHERS
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    OTHERS          shift and go to state 716
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 718
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    except_choice                  shift and go to state 883
    simple_name                    shift and go to state 160

state 817

    (467) exception_handler -> WHEN ID : . except_choice_s ARROW statement_s
    (468) except_choice_s -> . except_choice
    (469) except_choice_s -> . except_choice_s | except_choice
    (470) except_choice -> . name
    (471) except_choice -> . OTHERS
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    OTHERS          shift and go to state 716
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 718
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    except_choice_s                shift and go to state 884
    except_choice                  shift and go to state 715
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 818

    (284) else_opt -> ELSE m statement_s .
    (250) statement_s -> statement_s . m statement
    (519) m -> .

    END             reduce using rule 284 (else_opt -> ELSE m statement_s .)
    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)

    m                              shift and go to state 461

state 819

    (277) if_stmt -> IF cond_clause_s else_opt END IF . ;

    ;               shift and go to state 885


state 820

    (279) cond_clause_s -> cond_clause ELSIF m cond_clause_s .

    ELSE            reduce using rule 279 (cond_clause_s -> cond_clause ELSIF m cond_clause_s .)
    END             reduce using rule 279 (cond_clause_s -> cond_clause ELSIF m cond_clause_s .)


state 821

    (280) cond_clause -> cond_part m statement_s n .

    ELSIF           reduce using rule 280 (cond_clause -> cond_part m statement_s n .)
    ELSE            reduce using rule 280 (cond_clause -> cond_part m statement_s n .)
    END             reduce using rule 280 (cond_clause -> cond_part m statement_s n .)


state 822

    (512) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END . RECORD ;

    RECORD          shift and go to state 886


state 823

    (516) comp_loc_s -> comp_loc_s mark . AT expression RANGE range ;
    (161) mark -> mark . SINGLEQUOTE attribute_id
    (162) mark -> mark . . simple_name

    AT              shift and go to state 887
    SINGLEQUOTE     shift and go to state 318
    .               shift and go to state 319


state 824

    (514) align_opt -> AT MOD expression . ;
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    ;               shift and go to state 888
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 825

    (373) task_body -> TASK BODY simple_name IS decl_part block_body END . id_opt ;
    (300) id_opt -> .
    (301) id_opt -> . designator
    (323) designator -> . compound_name
    (324) designator -> . STRLITERAL
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ;               reduce using rule 300 (id_opt -> .)
    STRLITERAL      shift and go to state 114
    ID              shift and go to state 41

    designator                     shift and go to state 471
    id_opt                         shift and go to state 889
    compound_name                  shift and go to state 116
    simple_name                    shift and go to state 42

state 826

    (405) rep_spec_s -> rep_spec_s rep_spec pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    FOR             reduce using rule 405 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    END             reduce using rule 405 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    PRIVATE         reduce using rule 405 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 827

    (372) task_private_opt -> PRIVATE entry_decl_s . rep_spec_s
    (397) entry_decl_s -> entry_decl_s . entry_decl pragma_s
    (404) rep_spec_s -> .
    (405) rep_spec_s -> . rep_spec_s rep_spec pragma_s
    (398) entry_decl -> . ENTRY ID formal_part_opt ;
    (399) entry_decl -> . ENTRY ID ( discrete_range ) formal_part_opt ;

    FOR             reduce using rule 404 (rep_spec_s -> .)
    END             reduce using rule 404 (rep_spec_s -> .)
    ENTRY           shift and go to state 553

    rep_spec_s                     shift and go to state 890
    entry_decl                     shift and go to state 605

state 828

    (370) task_def -> IS entry_decl_s rep_spec_s task_private_opt END . id_opt
    (300) id_opt -> .
    (301) id_opt -> . designator
    (323) designator -> . compound_name
    (324) designator -> . STRLITERAL
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ;               reduce using rule 300 (id_opt -> .)
    STRLITERAL      shift and go to state 114
    ID              shift and go to state 41

    designator                     shift and go to state 471
    id_opt                         shift and go to state 891
    compound_name                  shift and go to state 116
    simple_name                    shift and go to state 42

state 829

    (115) discrim_spec -> def_id_s : access_opt mark . init_opt
    (161) mark -> mark . SINGLEQUOTE attribute_id
    (162) mark -> mark . . simple_name
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    SINGLEQUOTE     shift and go to state 318
    .               shift and go to state 319
    )               reduce using rule 33 (init_opt -> .)
    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 643

    init_opt                       shift and go to state 892

state 830

    (59) derived_type -> ABSTRACT NEW subtype_ind . WITH PRIVATE
    (60) derived_type -> ABSTRACT NEW subtype_ind . WITH record_def

    WITH            shift and go to state 893


state 831

    (57) derived_type -> NEW subtype_ind WITH . PRIVATE
    (58) derived_type -> NEW subtype_ind WITH . record_def
    (98) record_def -> . RECORD pragma_s comp_list END RECORD
    (99) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 894
    RECORD          shift and go to state 843
    NuLL            shift and go to state 844

    record_def                     shift and go to state 895

state 832

    (65) enumeration_type -> ( enum_id_s ) .

    ;               reduce using rule 65 (enumeration_type -> ( enum_id_s ) .)


state 833

    (67) enum_id_s -> enum_id_s , . enum_id
    (68) enum_id -> . ID
    (69) enum_id -> . CHARLITERAL

    ID              shift and go to state 741
    CHARLITERAL     shift and go to state 740

    enum_id                        shift and go to state 896

state 834

    (77) float_type -> DIGITS expression range_spec_opt .

    ;               reduce using rule 77 (float_type -> DIGITS expression range_spec_opt .)


state 835

    (74) range_spec_opt -> range_spec .

    ;               reduce using rule 74 (range_spec_opt -> range_spec .)


state 836

    (79) fixed_type -> DELTA expression DIGITS . expression range_spec_opt
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 897

state 837

    (78) fixed_type -> DELTA expression range_spec .

    ;               reduce using rule 78 (fixed_type -> DELTA expression range_spec .)


state 838

    (131) access_type -> ACCESS CONSTANT subtype_ind .

    ;               reduce using rule 131 (access_type -> ACCESS CONSTANT subtype_ind .)


state 839

    (134) access_type -> ACCESS prot_opt FUNCTION . formal_part_opt RETURN mark
    (325) formal_part_opt -> .
    (326) formal_part_opt -> . formal_part
    (327) formal_part -> . ( param_s )

    RETURN          reduce using rule 325 (formal_part_opt -> .)
    (               shift and go to state 192

    formal_part                    shift and go to state 191
    formal_part_opt                shift and go to state 898

state 840

    (133) access_type -> ACCESS prot_opt PROCEDURE . formal_part_opt
    (325) formal_part_opt -> .
    (326) formal_part_opt -> . formal_part
    (327) formal_part -> . ( param_s )

    ;               reduce using rule 325 (formal_part_opt -> .)
    (               shift and go to state 192

    formal_part                    shift and go to state 191
    formal_part_opt                shift and go to state 899

state 841

    (132) access_type -> ACCESS ALL subtype_ind .

    ;               reduce using rule 132 (access_type -> ACCESS ALL subtype_ind .)


state 842

    (351) private_type -> tagged_opt limited_opt PRIVATE .

    ;               reduce using rule 351 (private_type -> tagged_opt limited_opt PRIVATE .)


state 843

    (98) record_def -> RECORD . pragma_s comp_list END RECORD
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    NuLL            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    error           reduce using rule 8 (pragma_s -> .)
    ID              reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 900

state 844

    (99) record_def -> NuLL . RECORD

    RECORD          shift and go to state 901


state 845

    (97) record_type -> tagged_opt limited_opt record_def .

    ;               reduce using rule 97 (record_type -> tagged_opt limited_opt record_def .)


state 846

    (55) decimal_digits_constraint -> DIGITS expression range_constr_opt .

    ;               reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    RENAMES         reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    ASSIGNMENT      reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    WITH            reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)


state 847

    (90) iter_index_constraint -> ( iter_discrete_range_s ) .

    OF              reduce using rule 90 (iter_index_constraint -> ( iter_discrete_range_s ) .)


state 848

    (92) iter_discrete_range_s -> iter_discrete_range_s , . discrete_range
    (93) discrete_range -> . name range_constr_opt
    (94) discrete_range -> . range
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    simple_expression              shift and go to state 366
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    discrete_range                 shift and go to state 902
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 691
    operator_symbol                shift and go to state 139
    range                          shift and go to state 692

state 849

    (82) unconstr_array_type -> ARRAY ( index_s ) . OF component_subtype_def

    OF              shift and go to state 903


state 850

    (88) index_s -> index_s , . index
    (89) index -> . name RANGE BOX
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    index                          shift and go to state 904
    name                           shift and go to state 905
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 851

    (89) index -> name RANGE . BOX
    (61) range_constraint -> RANGE . range
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    BOX             shift and go to state 906
    +               shift and go to state 135
    -               shift and go to state 136
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    simple_expression              shift and go to state 366
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 529
    operator_symbol                shift and go to state 139
    range                          shift and go to state 530

state 852

    (86) aliased_opt -> ALIASED .

    ID              reduce using rule 86 (aliased_opt -> ALIASED .)
    STRLITERAL      reduce using rule 86 (aliased_opt -> ALIASED .)


state 853

    (84) component_subtype_def -> aliased_opt . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    name                           shift and go to state 490
    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    operator_symbol                shift and go to state 139
    subtype_ind                    shift and go to state 907
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160

state 854

    (83) constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .

    ASSIGNMENT      reduce using rule 83 (constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .)
    ;               reduce using rule 83 (constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .)


state 855

    (482) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default . ;

    ;               shift and go to state 908


state 856

    (483) generic_formal -> WITH PACKAGE simple_name IS NEW name ( . BOX ) ;
    (170) indexed_comp -> name ( . value_s )
    (171) value_s -> . value
    (172) value_s -> . value_s , value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (200) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    BOX             shift and go to state 909
    error           shift and go to state 238
    OTHERS          shift and go to state 228
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    value_s                        shift and go to state 388
    simple_expression              shift and go to state 389
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    choice_s                       shift and go to state 230
    operator_symbol                shift and go to state 139
    comp_assoc                     shift and go to state 390
    factor                         shift and go to state 138
    choice                         shift and go to state 232
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    discrete_with_range            shift and go to state 234
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 235
    value                          shift and go to state 391
    range                          shift and go to state 237
    expression                     shift and go to state 392

state 857

    (484) generic_formal -> WITH PACKAGE simple_name IS NEW name ; .

    PACKAGE         reduce using rule 484 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    PROCEDURE       reduce using rule 484 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    FUNCTION        reduce using rule 484 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    TYPE            reduce using rule 484 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    WITH            reduce using rule 484 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    error           reduce using rule 484 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    USE             reduce using rule 484 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    ID              reduce using rule 484 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)


state 858

    (504) generic_derived_type -> ABSTRACT NEW subtype_ind . WITH PRIVATE

    WITH            shift and go to state 910


state 859

    (503) generic_derived_type -> NEW subtype_ind WITH . PRIVATE

    PRIVATE         shift and go to state 911


state 860

    (492) generic_type_def -> ( BOX ) .

    ;               reduce using rule 492 (generic_type_def -> ( BOX ) .)


state 861

    (496) generic_type_def -> DELTA BOX DIGITS . BOX

    BOX             shift and go to state 912


state 862

    (64) range -> name SINGLEQUOTE RANGE ( expression ) .

    AND             reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    OR              reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    XOR             reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    )               reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    ,               reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    WITH            reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    ARROW           reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    |               reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    ;               reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    IS              reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    THEN            reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    LOOP            reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    RANGE           reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    DIGITS          reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    RENAMES         reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)
    ASSIGNMENT      reduce using rule 64 (range -> name SINGLEQUOTE RANGE ( expression ) .)


state 863

    (390) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .

    TASK            reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PROTECTED       reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    error           reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    USE             reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PRAGMA          reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PACKAGE         reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    TYPE            reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    SUBTYPE         reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    FOR             reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PROCEDURE       reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    FUNCTION        reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    GENERIC         reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    ID              reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    BEGIN           reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PRIVATE         reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    WITH            reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    SEPARATE        reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    $end            reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    END             reduce using rule 390 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)


state 864

    (401) entry_body -> ENTRY ID ( . iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (327) formal_part -> ( . param_s )
    (296) iter_part -> . FOR ID IN
    (328) param_s -> . param
    (329) param_s -> . param_s ; param
    (330) param -> . def_id_s : mode mark init_opt
    (331) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . ID

    FOR             shift and go to state 425
    error           shift and go to state 110
    ID              shift and go to state 91

    def_id                         shift and go to state 88
    param_s                        shift and go to state 348
    iter_part                      shift and go to state 913
    param                          shift and go to state 347
    def_id_s                       shift and go to state 106

state 865

    (400) entry_body -> ENTRY ID formal_part_opt . WHEN condition entry_body_part

    WHEN            shift and go to state 914


state 866

    (110) comp_decl -> def_id_s : . component_subtype_def init_opt ;
    (84) component_subtype_def -> . aliased_opt subtype_ind
    (85) aliased_opt -> .
    (86) aliased_opt -> . ALIASED

    ID              reduce using rule 85 (aliased_opt -> .)
    STRLITERAL      reduce using rule 85 (aliased_opt -> .)
    ALIASED         shift and go to state 852

    aliased_opt                    shift and go to state 853
    component_subtype_def          shift and go to state 915

state 867

    (111) comp_decl -> error ; .

    error           reduce using rule 111 (comp_decl -> error ; .)
    ENTRY           reduce using rule 111 (comp_decl -> error ; .)
    PROCEDURE       reduce using rule 111 (comp_decl -> error ; .)
    FUNCTION        reduce using rule 111 (comp_decl -> error ; .)
    PRAGMA          reduce using rule 111 (comp_decl -> error ; .)
    FOR             reduce using rule 111 (comp_decl -> error ; .)
    ID              reduce using rule 111 (comp_decl -> error ; .)
    END             reduce using rule 111 (comp_decl -> error ; .)
    CASE            reduce using rule 111 (comp_decl -> error ; .)
    WHEN            reduce using rule 111 (comp_decl -> error ; .)


state 868

    (399) entry_decl -> ENTRY ID ( discrete_range . ) formal_part_opt ;

    )               shift and go to state 916


state 869

    (163) simple_name -> ID .
    (26) def_id -> ID .

    SINGLEQUOTE     reduce using rule 163 (simple_name -> ID .)
    (               reduce using rule 163 (simple_name -> ID .)
    .               reduce using rule 163 (simple_name -> ID .)
    RANGE           reduce using rule 163 (simple_name -> ID .)
    )               reduce using rule 163 (simple_name -> ID .)
    DOUBLESTAR      reduce using rule 163 (simple_name -> ID .)
    *               reduce using rule 163 (simple_name -> ID .)
    /               reduce using rule 163 (simple_name -> ID .)
    MOD             reduce using rule 163 (simple_name -> ID .)
    REM             reduce using rule 163 (simple_name -> ID .)
    DOUBLEDOT       reduce using rule 163 (simple_name -> ID .)
    +               reduce using rule 163 (simple_name -> ID .)
    -               reduce using rule 163 (simple_name -> ID .)
    &               reduce using rule 163 (simple_name -> ID .)
    :               reduce using rule 26 (def_id -> ID .)
    ,               reduce using rule 26 (def_id -> ID .)


state 870

    (398) entry_decl -> ENTRY ID formal_part_opt ; .

    PRIVATE         reduce using rule 398 (entry_decl -> ENTRY ID formal_part_opt ; .)
    ENTRY           reduce using rule 398 (entry_decl -> ENTRY ID formal_part_opt ; .)
    PROCEDURE       reduce using rule 398 (entry_decl -> ENTRY ID formal_part_opt ; .)
    FUNCTION        reduce using rule 398 (entry_decl -> ENTRY ID formal_part_opt ; .)
    PRAGMA          reduce using rule 398 (entry_decl -> ENTRY ID formal_part_opt ; .)
    FOR             reduce using rule 398 (entry_decl -> ENTRY ID formal_part_opt ; .)
    END             reduce using rule 398 (entry_decl -> ENTRY ID formal_part_opt ; .)
    error           reduce using rule 398 (entry_decl -> ENTRY ID formal_part_opt ; .)
    ID              reduce using rule 398 (entry_decl -> ENTRY ID formal_part_opt ; .)


state 871

    (290) loop_stmt -> label_opt iteration m basic_loop id_opt ; .

    LEFTLABEL       reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    error           reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    PRAGMA          reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    NuLL            reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    EXIT            reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    RETURN          reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    GOTO            reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    DELAY           reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    ABORT           reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    RAISE           reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    REQUEUE         reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    IF              reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    CASE            reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    ID              reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    ACCEPT          reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    SELECT          reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    STRLITERAL      reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    WHILE           reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    DECLARE         reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    FOR             reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    LOOP            reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    BEGIN           reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    OR              reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    ELSE            reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    END             reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    EXCEPTION       reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    THEN            reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    ELSIF           reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    WHEN            reduce using rule 290 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)


state 872

    (299) basic_loop -> LOOP statement_s END . LOOP

    LOOP            shift and go to state 917


state 873

    (302) block -> label_opt block_decl block_body END id_opt ; .

    END             reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    LEFTLABEL       reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    error           reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    PRAGMA          reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    NuLL            reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    EXIT            reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    RETURN          reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    GOTO            reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    DELAY           reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    ABORT           reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    RAISE           reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    REQUEUE         reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    IF              reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    CASE            reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    ID              reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    ACCEPT          reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    SELECT          reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    STRLITERAL      reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    WHILE           reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    DECLARE         reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    FOR             reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    LOOP            reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    BEGIN           reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    THEN            reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    OR              reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    ELSE            reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    EXCEPTION       reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    ELSIF           reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)
    WHEN            reduce using rule 302 (block -> label_opt block_decl block_body END id_opt ; .)


state 874

    (430) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END . SELECT ;

    SELECT          shift and go to state 918


state 875

    (429) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt . END SELECT ;

    END             shift and go to state 919


state 876

    (428) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END . SELECT ;

    SELECT          shift and go to state 920


state 877

    (424) select_alt -> delay_stmt stmts_opt .

    OR              reduce using rule 424 (select_alt -> delay_stmt stmts_opt .)
    ELSE            reduce using rule 424 (select_alt -> delay_stmt stmts_opt .)
    END             reduce using rule 424 (select_alt -> delay_stmt stmts_opt .)


state 878

    (418) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT . ;

    ;               shift and go to state 921


state 879

    (285) case_stmt -> case_hdr pragma_s alternative_s END CASE ; .

    END             reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    LEFTLABEL       reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    error           reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    PRAGMA          reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    NuLL            reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    EXIT            reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    RETURN          reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    GOTO            reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    DELAY           reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ABORT           reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    RAISE           reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    REQUEUE         reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    IF              reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    CASE            reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ID              reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ACCEPT          reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    SELECT          reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    STRLITERAL      reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    WHILE           reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    DECLARE         reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    FOR             reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    LOOP            reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    BEGIN           reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    OR              reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ELSE            reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    WHEN            reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    EXCEPTION       reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    THEN            reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ELSIF           reduce using rule 285 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)


state 880

    (289) alternative -> WHEN choice_s ARROW . statement_s
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 922
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    attribute                      shift and go to state 122
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 881

    (408) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .

    LEFTLABEL       reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    error           reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    PRAGMA          reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    NuLL            reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    EXIT            reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    RETURN          reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    GOTO            reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    DELAY           reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ABORT           reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    RAISE           reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    REQUEUE         reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    IF              reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    CASE            reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ID              reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ACCEPT          reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    SELECT          reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    STRLITERAL      reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    WHILE           reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    DECLARE         reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    FOR             reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    LOOP            reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    BEGIN           reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    OR              reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ELSE            reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    END             reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    EXCEPTION       reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    THEN            reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ELSIF           reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    WHEN            reduce using rule 408 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)


state 882

    (466) exception_handler -> WHEN except_choice_s ARROW statement_s .
    (250) statement_s -> statement_s . m statement
    (519) m -> .

    WHEN            reduce using rule 466 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
    END             reduce using rule 466 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)

    m                              shift and go to state 461

state 883

    (469) except_choice_s -> except_choice_s | except_choice .

    ARROW           reduce using rule 469 (except_choice_s -> except_choice_s | except_choice .)
    |               reduce using rule 469 (except_choice_s -> except_choice_s | except_choice .)


state 884

    (467) exception_handler -> WHEN ID : except_choice_s . ARROW statement_s
    (469) except_choice_s -> except_choice_s . | except_choice

    ARROW           shift and go to state 923
    |               shift and go to state 816


state 885

    (277) if_stmt -> IF cond_clause_s else_opt END IF ; .

    LEFTLABEL       reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    error           reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    PRAGMA          reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    NuLL            reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    EXIT            reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    RETURN          reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    GOTO            reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    DELAY           reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ABORT           reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    RAISE           reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    REQUEUE         reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    IF              reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    CASE            reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ID              reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ACCEPT          reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    SELECT          reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    STRLITERAL      reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    WHILE           reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    DECLARE         reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    FOR             reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    LOOP            reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    BEGIN           reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    WHEN            reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    END             reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ELSIF           reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ELSE            reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    OR              reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    EXCEPTION       reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    THEN            reduce using rule 277 (if_stmt -> IF cond_clause_s else_opt END IF ; .)


state 886

    (512) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD . ;

    ;               shift and go to state 924


state 887

    (516) comp_loc_s -> comp_loc_s mark AT . expression RANGE range ;
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 925

state 888

    (514) align_opt -> AT MOD expression ; .

    END             reduce using rule 514 (align_opt -> AT MOD expression ; .)
    ID              reduce using rule 514 (align_opt -> AT MOD expression ; .)


state 889

    (373) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt . ;

    ;               shift and go to state 926


state 890

    (372) task_private_opt -> PRIVATE entry_decl_s rep_spec_s .
    (405) rep_spec_s -> rep_spec_s . rep_spec pragma_s
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 372 (task_private_opt -> PRIVATE entry_decl_s rep_spec_s .)
    FOR             shift and go to state 64

    record_type_spec               shift and go to state 69
    rep_spec                       shift and go to state 728
    attrib_def                     shift and go to state 71
    address_spec                   shift and go to state 53

state 891

    (370) task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .

    ;               reduce using rule 370 (task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .)


state 892

    (115) discrim_spec -> def_id_s : access_opt mark init_opt .

    )               reduce using rule 115 (discrim_spec -> def_id_s : access_opt mark init_opt .)
    ;               reduce using rule 115 (discrim_spec -> def_id_s : access_opt mark init_opt .)


state 893

    (59) derived_type -> ABSTRACT NEW subtype_ind WITH . PRIVATE
    (60) derived_type -> ABSTRACT NEW subtype_ind WITH . record_def
    (98) record_def -> . RECORD pragma_s comp_list END RECORD
    (99) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 927
    RECORD          shift and go to state 843
    NuLL            shift and go to state 844

    record_def                     shift and go to state 928

state 894

    (57) derived_type -> NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 57 (derived_type -> NEW subtype_ind WITH PRIVATE .)


state 895

    (58) derived_type -> NEW subtype_ind WITH record_def .

    ;               reduce using rule 58 (derived_type -> NEW subtype_ind WITH record_def .)


state 896

    (67) enum_id_s -> enum_id_s , enum_id .

    )               reduce using rule 67 (enum_id_s -> enum_id_s , enum_id .)
    ,               reduce using rule 67 (enum_id_s -> enum_id_s , enum_id .)


state 897

    (79) fixed_type -> DELTA expression DIGITS expression . range_spec_opt
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (73) range_spec_opt -> .
    (74) range_spec_opt -> . range_spec
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE
    (72) range_spec -> . range_constraint
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 73 (range_spec_opt -> .)
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254
    RANGE           shift and go to state 378

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256
    range_constraint               shift and go to state 612
    range_spec                     shift and go to state 835
    range_spec_opt                 shift and go to state 929

state 898

    (134) access_type -> ACCESS prot_opt FUNCTION formal_part_opt . RETURN mark

    RETURN          shift and go to state 930


state 899

    (133) access_type -> ACCESS prot_opt PROCEDURE formal_part_opt .

    ;               reduce using rule 133 (access_type -> ACCESS prot_opt PROCEDURE formal_part_opt .)


state 900

    (98) record_def -> RECORD pragma_s . comp_list END RECORD
    (9) pragma_s -> pragma_s . pragma
    (103) comp_list -> . comp_decl_s variant_part_opt
    (104) comp_list -> . variant_part pragma_s
    (105) comp_list -> . NuLL ; pragma_s
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (106) comp_decl_s -> . comp_decl
    (107) comp_decl_s -> . comp_decl_s pragma_s comp_decl
    (119) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (110) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (111) comp_decl -> . error ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . ID

    NuLL            shift and go to state 936
    PRAGMA          shift and go to state 4
    CASE            shift and go to state 932
    error           shift and go to state 794
    ID              shift and go to state 91

    def_id_s                       shift and go to state 790
    comp_list                      shift and go to state 933
    comp_decl                      shift and go to state 934
    def_id                         shift and go to state 88
    variant_part                   shift and go to state 935
    pragma                         shift and go to state 14
    comp_decl_s                    shift and go to state 931

state 901

    (99) record_def -> NuLL RECORD .

    ;               reduce using rule 99 (record_def -> NuLL RECORD .)


state 902

    (92) iter_discrete_range_s -> iter_discrete_range_s , discrete_range .

    )               reduce using rule 92 (iter_discrete_range_s -> iter_discrete_range_s , discrete_range .)
    ,               reduce using rule 92 (iter_discrete_range_s -> iter_discrete_range_s , discrete_range .)


state 903

    (82) unconstr_array_type -> ARRAY ( index_s ) OF . component_subtype_def
    (84) component_subtype_def -> . aliased_opt subtype_ind
    (85) aliased_opt -> .
    (86) aliased_opt -> . ALIASED

    ID              reduce using rule 85 (aliased_opt -> .)
    STRLITERAL      reduce using rule 85 (aliased_opt -> .)
    ALIASED         shift and go to state 852

    aliased_opt                    shift and go to state 853
    component_subtype_def          shift and go to state 937

state 904

    (88) index_s -> index_s , index .

    )               reduce using rule 88 (index_s -> index_s , index .)
    ,               reduce using rule 88 (index_s -> index_s , index .)


state 905

    (89) index -> name . RANGE BOX
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . SINGLEQUOTE attribute_id

    RANGE           shift and go to state 938
    (               shift and go to state 249
    .               shift and go to state 250
    SINGLEQUOTE     shift and go to state 260


state 906

    (89) index -> name RANGE BOX .

    )               reduce using rule 89 (index -> name RANGE BOX .)
    ,               reduce using rule 89 (index -> name RANGE BOX .)


state 907

    (84) component_subtype_def -> aliased_opt subtype_ind .

    ASSIGNMENT      reduce using rule 84 (component_subtype_def -> aliased_opt subtype_ind .)
    ;               reduce using rule 84 (component_subtype_def -> aliased_opt subtype_ind .)


state 908

    (482) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .

    PACKAGE         reduce using rule 482 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    PROCEDURE       reduce using rule 482 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    FUNCTION        reduce using rule 482 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    TYPE            reduce using rule 482 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    WITH            reduce using rule 482 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    error           reduce using rule 482 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    USE             reduce using rule 482 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    ID              reduce using rule 482 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)


state 909

    (483) generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX . ) ;

    )               shift and go to state 939


state 910

    (504) generic_derived_type -> ABSTRACT NEW subtype_ind WITH . PRIVATE

    PRIVATE         shift and go to state 940


state 911

    (503) generic_derived_type -> NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 503 (generic_derived_type -> NEW subtype_ind WITH PRIVATE .)


state 912

    (496) generic_type_def -> DELTA BOX DIGITS BOX .

    ;               reduce using rule 496 (generic_type_def -> DELTA BOX DIGITS BOX .)


state 913

    (401) entry_body -> ENTRY ID ( iter_part . discrete_range ) formal_part_opt WHEN condition entry_body_part
    (93) discrete_range -> . name range_constr_opt
    (94) discrete_range -> . range
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    simple_expression              shift and go to state 366
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    allocator                      shift and go to state 131
    factor                         shift and go to state 138
    parenthesized_primary          shift and go to state 142
    discrete_range                 shift and go to state 941
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 691
    operator_symbol                shift and go to state 139
    range                          shift and go to state 692
    qualified                      shift and go to state 151

state 914

    (400) entry_body -> ENTRY ID formal_part_opt WHEN . condition entry_body_part
    (282) condition -> . expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    allocator                      shift and go to state 131
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    condition                      shift and go to state 942
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    expression                     shift and go to state 470

state 915

    (110) comp_decl -> def_id_s : component_subtype_def . init_opt ;
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 643

    init_opt                       shift and go to state 943

state 916

    (399) entry_decl -> ENTRY ID ( discrete_range ) . formal_part_opt ;
    (325) formal_part_opt -> .
    (326) formal_part_opt -> . formal_part
    (327) formal_part -> . ( param_s )

    ;               reduce using rule 325 (formal_part_opt -> .)
    (               shift and go to state 192

    formal_part                    shift and go to state 191
    formal_part_opt                shift and go to state 944

state 917

    (299) basic_loop -> LOOP statement_s END LOOP .

    STRLITERAL      reduce using rule 299 (basic_loop -> LOOP statement_s END LOOP .)
    ID              reduce using rule 299 (basic_loop -> LOOP statement_s END LOOP .)
    ;               reduce using rule 299 (basic_loop -> LOOP statement_s END LOOP .)


state 918

    (430) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT . ;

    ;               shift and go to state 945


state 919

    (429) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END . SELECT ;

    SELECT          shift and go to state 946


state 920

    (428) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT . ;

    ;               shift and go to state 947


state 921

    (418) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .

    LEFTLABEL       reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    error           reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    PRAGMA          reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    NuLL            reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    EXIT            reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    RETURN          reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    GOTO            reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    DELAY           reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ABORT           reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    RAISE           reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    REQUEUE         reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    IF              reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    CASE            reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ID              reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ACCEPT          reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    SELECT          reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    STRLITERAL      reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    WHILE           reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    DECLARE         reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    FOR             reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    LOOP            reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    BEGIN           reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    END             reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    WHEN            reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    EXCEPTION       reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    OR              reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ELSE            reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    THEN            reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ELSIF           reduce using rule 418 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)


state 922

    (289) alternative -> WHEN choice_s ARROW statement_s .
    (250) statement_s -> statement_s . m statement
    (519) m -> .

    END             reduce using rule 289 (alternative -> WHEN choice_s ARROW statement_s .)
    WHEN            reduce using rule 289 (alternative -> WHEN choice_s ARROW statement_s .)
    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)

    m                              shift and go to state 461

state 923

    (467) exception_handler -> WHEN ID : except_choice_s ARROW . statement_s
    (249) statement_s -> . statement
    (250) statement_s -> . statement_s m statement
    (251) statement -> . unlabeled
    (252) statement -> . label statement
    (253) unlabeled -> . simple_stmt
    (254) unlabeled -> . compound_stmt
    (255) unlabeled -> . pragma
    (274) label -> . LEFTLABEL ID RIGHTLABEL
    (256) simple_stmt -> . null_stmt
    (257) simple_stmt -> . assign_stmt
    (258) simple_stmt -> . exit_stmt
    (259) simple_stmt -> . return_stmt
    (260) simple_stmt -> . goto_stmt
    (261) simple_stmt -> . procedure_call
    (262) simple_stmt -> . delay_stmt
    (263) simple_stmt -> . abort_stmt
    (264) simple_stmt -> . raise_stmt
    (265) simple_stmt -> . code_stmt
    (266) simple_stmt -> . requeue_stmt
    (267) simple_stmt -> . error ;
    (268) compound_stmt -> . if_stmt
    (269) compound_stmt -> . case_stmt
    (270) compound_stmt -> . loop_stmt
    (271) compound_stmt -> . block
    (272) compound_stmt -> . accept_stmt
    (273) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (275) null_stmt -> . NuLL ;
    (276) assign_stmt -> . name ASSIGNMENT expression ;
    (309) exit_stmt -> . EXIT name_opt when_opt ;
    (314) return_stmt -> . RETURN ;
    (315) return_stmt -> . RETURN expression ;
    (316) goto_stmt -> . GOTO name ;
    (339) procedure_call -> . name ;
    (412) delay_stmt -> . DELAY expression ;
    (413) delay_stmt -> . DELAY UNTIL expression ;
    (433) abort_stmt -> . ABORT name_s ;
    (472) raise_stmt -> . RAISE name_opt ;
    (518) code_stmt -> . qualified ;
    (473) requeue_stmt -> . REQUEUE name ;
    (474) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (277) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (285) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (290) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (302) block -> . label_opt block_decl block_body END id_opt ;
    (407) accept_stmt -> . accept_hdr ;
    (408) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (414) select_stmt -> . select_wait
    (415) select_stmt -> . async_select
    (416) select_stmt -> . timed_entry_call
    (417) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (286) case_hdr -> . CASE expression IS
    (291) label_opt -> .
    (292) label_opt -> . ID :
    (409) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (418) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (428) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (429) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (430) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL

    LEFTLABEL       shift and go to state 307
    error           shift and go to state 303
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 278
    EXIT            shift and go to state 302
    RETURN          shift and go to state 280
    GOTO            shift and go to state 271
    DELAY           shift and go to state 267
    ABORT           shift and go to state 277
    RAISE           shift and go to state 290
    REQUEUE         shift and go to state 294
    IF              shift and go to state 312
    CASE            shift and go to state 293
    WHILE           reduce using rule 291 (label_opt -> .)
    DECLARE         reduce using rule 291 (label_opt -> .)
    FOR             reduce using rule 291 (label_opt -> .)
    LOOP            reduce using rule 291 (label_opt -> .)
    BEGIN           reduce using rule 291 (label_opt -> .)
    ID              shift and go to state 311
    ACCEPT          shift and go to state 281
    SELECT          shift and go to state 283
    STRLITERAL      shift and go to state 150

    indexed_comp                   shift and go to state 130
    accept_stmt                    shift and go to state 279
    label_opt                      shift and go to state 270
    select_wait                    shift and go to state 310
    abort_stmt                     shift and go to state 304
    return_stmt                    shift and go to state 291
    procedure_call                 shift and go to state 282
    assign_stmt                    shift and go to state 315
    statement_s                    shift and go to state 948
    simple_name                    shift and go to state 160
    code_stmt                      shift and go to state 306
    case_stmt                      shift and go to state 284
    selected_comp                  shift and go to state 121
    operator_symbol                shift and go to state 139
    label                          shift and go to state 285
    exit_stmt                      shift and go to state 309
    select_stmt                    shift and go to state 269
    statement                      shift and go to state 295
    attribute                      shift and go to state 122
    compound_stmt                  shift and go to state 286
    case_hdr                       shift and go to state 288
    delay_stmt                     shift and go to state 296
    unlabeled                      shift and go to state 308
    simple_stmt                    shift and go to state 272
    loop_stmt                      shift and go to state 273
    qualified                      shift and go to state 274
    pragma                         shift and go to state 298
    async_select                   shift and go to state 268
    requeue_stmt                   shift and go to state 299
    raise_stmt                     shift and go to state 300
    name                           shift and go to state 276
    if_stmt                        shift and go to state 275
    accept_hdr                     shift and go to state 297
    cond_entry_call                shift and go to state 313
    timed_entry_call               shift and go to state 301
    goto_stmt                      shift and go to state 287
    null_stmt                      shift and go to state 314
    block                          shift and go to state 289

state 924

    (512) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .

    error           reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    USE             reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PRAGMA          reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    TYPE            reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    SUBTYPE         reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    TASK            reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PACKAGE         reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PROTECTED       reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    FOR             reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    GENERIC         reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PROCEDURE       reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    FUNCTION        reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    ID              reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PRIVATE         reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    END             reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    BEGIN           reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    ENTRY           reduce using rule 512 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)


state 925

    (516) comp_loc_s -> comp_loc_s mark AT expression . RANGE range ;
    (202) expression -> expression . logical m relation
    (203) expression -> expression . short_circuit m relation
    (204) logical -> . AND
    (205) logical -> . OR
    (206) logical -> . XOR
    (207) short_circuit -> . AND THEN
    (208) short_circuit -> . OR ELSE

    RANGE           shift and go to state 949
    AND             shift and go to state 253
    OR              shift and go to state 257
    XOR             shift and go to state 254

    logical                        shift and go to state 255
    short_circuit                  shift and go to state 256

state 926

    (373) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .

    TASK            reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PROTECTED       reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    error           reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    USE             reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PRAGMA          reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PACKAGE         reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    TYPE            reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    SUBTYPE         reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    FOR             reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    GENERIC         reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    ID              reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    BEGIN           reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    END             reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PRIVATE         reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    WITH            reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    SEPARATE        reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    $end            reduce using rule 373 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)


state 927

    (59) derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 59 (derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .)


state 928

    (60) derived_type -> ABSTRACT NEW subtype_ind WITH record_def .

    ;               reduce using rule 60 (derived_type -> ABSTRACT NEW subtype_ind WITH record_def .)


state 929

    (79) fixed_type -> DELTA expression DIGITS expression range_spec_opt .

    ;               reduce using rule 79 (fixed_type -> DELTA expression DIGITS expression range_spec_opt .)


state 930

    (134) access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN . mark
    (160) mark -> . simple_name
    (161) mark -> . mark SINGLEQUOTE attribute_id
    (162) mark -> . mark . simple_name
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 168
    mark                           shift and go to state 950

state 931

    (103) comp_list -> comp_decl_s . variant_part_opt
    (107) comp_decl_s -> comp_decl_s . pragma_s comp_decl
    (108) variant_part_opt -> . pragma_s
    (109) variant_part_opt -> . pragma_s variant_part pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    error           reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ID              reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 951
    variant_part_opt               shift and go to state 952

state 932

    (119) variant_part -> CASE . simple_name IS pragma_s variant_s END CASE ;
    (163) simple_name -> . ID

    ID              shift and go to state 41

    simple_name                    shift and go to state 953

state 933

    (98) record_def -> RECORD pragma_s comp_list . END RECORD

    END             shift and go to state 954


state 934

    (106) comp_decl_s -> comp_decl .

    error           reduce using rule 106 (comp_decl_s -> comp_decl .)
    CASE            reduce using rule 106 (comp_decl_s -> comp_decl .)
    PRAGMA          reduce using rule 106 (comp_decl_s -> comp_decl .)
    ID              reduce using rule 106 (comp_decl_s -> comp_decl .)
    END             reduce using rule 106 (comp_decl_s -> comp_decl .)
    WHEN            reduce using rule 106 (comp_decl_s -> comp_decl .)


state 935

    (104) comp_list -> variant_part . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 955

state 936

    (105) comp_list -> NuLL . ; pragma_s

    ;               shift and go to state 956


state 937

    (82) unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .

    ASSIGNMENT      reduce using rule 82 (unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .)
    ;               reduce using rule 82 (unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .)


state 938

    (89) index -> name RANGE . BOX

    BOX             shift and go to state 906


state 939

    (483) generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) . ;

    ;               shift and go to state 957


state 940

    (504) generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 504 (generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .)


state 941

    (401) entry_body -> ENTRY ID ( iter_part discrete_range . ) formal_part_opt WHEN condition entry_body_part

    )               shift and go to state 958


state 942

    (400) entry_body -> ENTRY ID formal_part_opt WHEN condition . entry_body_part
    (402) entry_body_part -> . ;
    (403) entry_body_part -> . IS decl_part block_body END id_opt ;

    ;               shift and go to state 961
    IS              shift and go to state 960

    entry_body_part                shift and go to state 959

state 943

    (110) comp_decl -> def_id_s : component_subtype_def init_opt . ;

    ;               shift and go to state 962


state 944

    (399) entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt . ;

    ;               shift and go to state 963


state 945

    (430) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .

    LEFTLABEL       reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    error           reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    PRAGMA          reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    NuLL            reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    EXIT            reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    RETURN          reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    GOTO            reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    DELAY           reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ABORT           reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    RAISE           reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    REQUEUE         reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    IF              reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    CASE            reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ID              reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ACCEPT          reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    SELECT          reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    STRLITERAL      reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    WHILE           reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    DECLARE         reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    FOR             reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    LOOP            reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    BEGIN           reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    END             reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    OR              reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ELSE            reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ELSIF           reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    WHEN            reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    EXCEPTION       reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    THEN            reduce using rule 430 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)


state 946

    (429) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT . ;

    ;               shift and go to state 964


state 947

    (428) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .

    LEFTLABEL       reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    error           reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    PRAGMA          reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    NuLL            reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    EXIT            reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    RETURN          reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    GOTO            reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    DELAY           reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ABORT           reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    RAISE           reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    REQUEUE         reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    IF              reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    CASE            reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ID              reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ACCEPT          reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    SELECT          reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    STRLITERAL      reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    WHILE           reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    DECLARE         reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    FOR             reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    LOOP            reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    BEGIN           reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    OR              reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ELSE            reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    END             reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    EXCEPTION       reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    THEN            reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ELSIF           reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    WHEN            reduce using rule 428 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)


state 948

    (467) exception_handler -> WHEN ID : except_choice_s ARROW statement_s .
    (250) statement_s -> statement_s . m statement
    (519) m -> .

    WHEN            reduce using rule 467 (exception_handler -> WHEN ID : except_choice_s ARROW statement_s .)
    END             reduce using rule 467 (exception_handler -> WHEN ID : except_choice_s ARROW statement_s .)
    LEFTLABEL       reduce using rule 519 (m -> .)
    error           reduce using rule 519 (m -> .)
    PRAGMA          reduce using rule 519 (m -> .)
    NuLL            reduce using rule 519 (m -> .)
    EXIT            reduce using rule 519 (m -> .)
    RETURN          reduce using rule 519 (m -> .)
    GOTO            reduce using rule 519 (m -> .)
    DELAY           reduce using rule 519 (m -> .)
    ABORT           reduce using rule 519 (m -> .)
    RAISE           reduce using rule 519 (m -> .)
    REQUEUE         reduce using rule 519 (m -> .)
    IF              reduce using rule 519 (m -> .)
    CASE            reduce using rule 519 (m -> .)
    ID              reduce using rule 519 (m -> .)
    ACCEPT          reduce using rule 519 (m -> .)
    SELECT          reduce using rule 519 (m -> .)
    STRLITERAL      reduce using rule 519 (m -> .)
    WHILE           reduce using rule 519 (m -> .)
    DECLARE         reduce using rule 519 (m -> .)
    FOR             reduce using rule 519 (m -> .)
    LOOP            reduce using rule 519 (m -> .)
    BEGIN           reduce using rule 519 (m -> .)

    m                              shift and go to state 461

state 949

    (516) comp_loc_s -> comp_loc_s mark AT expression RANGE . range ;
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    simple_expression              shift and go to state 366
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    factor                         shift and go to state 138
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 529
    operator_symbol                shift and go to state 139
    range                          shift and go to state 965

state 950

    (134) access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark .
    (161) mark -> mark . SINGLEQUOTE attribute_id
    (162) mark -> mark . . simple_name

    ;               reduce using rule 134 (access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark .)
    SINGLEQUOTE     shift and go to state 318
    .               shift and go to state 319


state 951

    (107) comp_decl_s -> comp_decl_s pragma_s . comp_decl
    (108) variant_part_opt -> pragma_s .
    (109) variant_part_opt -> pragma_s . variant_part pragma_s
    (9) pragma_s -> pragma_s . pragma
    (110) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (111) comp_decl -> . error ;
    (119) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . ID

    END             reduce using rule 108 (variant_part_opt -> pragma_s .)
    WHEN            reduce using rule 108 (variant_part_opt -> pragma_s .)
    error           shift and go to state 794
    CASE            shift and go to state 932
    PRAGMA          shift and go to state 4
    ID              shift and go to state 91

    comp_decl                      shift and go to state 966
    def_id                         shift and go to state 88
    def_id_s                       shift and go to state 790
    pragma                         shift and go to state 14
    variant_part                   shift and go to state 967

state 952

    (103) comp_list -> comp_decl_s variant_part_opt .

    END             reduce using rule 103 (comp_list -> comp_decl_s variant_part_opt .)
    WHEN            reduce using rule 103 (comp_list -> comp_decl_s variant_part_opt .)


state 953

    (119) variant_part -> CASE simple_name . IS pragma_s variant_s END CASE ;

    IS              shift and go to state 968


state 954

    (98) record_def -> RECORD pragma_s comp_list END . RECORD

    RECORD          shift and go to state 969


state 955

    (104) comp_list -> variant_part pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 104 (comp_list -> variant_part pragma_s .)
    WHEN            reduce using rule 104 (comp_list -> variant_part pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 956

    (105) comp_list -> NuLL ; . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 970

state 957

    (483) generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .

    PACKAGE         reduce using rule 483 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
    PROCEDURE       reduce using rule 483 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
    FUNCTION        reduce using rule 483 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
    TYPE            reduce using rule 483 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
    WITH            reduce using rule 483 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
    error           reduce using rule 483 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
    USE             reduce using rule 483 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
    ID              reduce using rule 483 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)


state 958

    (401) entry_body -> ENTRY ID ( iter_part discrete_range ) . formal_part_opt WHEN condition entry_body_part
    (325) formal_part_opt -> .
    (326) formal_part_opt -> . formal_part
    (327) formal_part -> . ( param_s )

    WHEN            reduce using rule 325 (formal_part_opt -> .)
    (               shift and go to state 192

    formal_part                    shift and go to state 191
    formal_part_opt                shift and go to state 971

state 959

    (400) entry_body -> ENTRY ID formal_part_opt WHEN condition entry_body_part .

    PRAGMA          reduce using rule 400 (entry_body -> ENTRY ID formal_part_opt WHEN condition entry_body_part .)
    END             reduce using rule 400 (entry_body -> ENTRY ID formal_part_opt WHEN condition entry_body_part .)
    ENTRY           reduce using rule 400 (entry_body -> ENTRY ID formal_part_opt WHEN condition entry_body_part .)
    PROCEDURE       reduce using rule 400 (entry_body -> ENTRY ID formal_part_opt WHEN condition entry_body_part .)
    FUNCTION        reduce using rule 400 (entry_body -> ENTRY ID formal_part_opt WHEN condition entry_body_part .)


state 960

    (403) entry_body_part -> IS . decl_part block_body END id_opt ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (338) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (348) pkg_body -> . pkg_start decl_part body_opt END c_id_opt ;
    (373) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (390) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . pkg_decl
    (15) decl -> . task_decl
    (16) decl -> . prot_decl
    (17) decl -> . exception_decl
    (18) decl -> . rename_decl
    (19) decl -> . generic_decl
    (20) decl -> . body_stub
    (21) decl -> . error ;
    (22) decl -> . subprog_decl
    (354) use_clause -> . USE name_s ;
    (355) use_clause -> . USE TYPE name_s ;
    (508) rep_spec -> . attrib_def
    (509) rep_spec -> . record_type_spec
    (510) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (337) subprog_spec_is_push -> . subprog_spec IS
    (347) pkg_start -> . PACKAGE BODY compound_name IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE ID discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE ID IS subtype_ind ;
    (340) pkg_decl -> . pkg_spec ;
    (341) pkg_decl -> . generic_pkg_inst ;
    (366) task_decl -> . task_spec ;
    (374) prot_decl -> . prot_spec ;
    (463) exception_decl -> . def_id_s : EXCEPTION ;
    (358) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (359) rename_decl -> . def_id_s : EXCEPTION renames ;
    (360) rename_decl -> . rename_unit
    (475) generic_decl -> . generic_formal_part subprog_spec ;
    (476) generic_decl -> . generic_formal_part pkg_spec ;
    (459) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (460) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (461) body_stub -> . subprog_spec IS SEPARATE ;
    (462) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (317) subprog_decl -> . subprog_spec ;
    (318) subprog_decl -> . generic_subp_inst ;
    (319) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (511) attrib_def -> . FOR mark USE expression ;
    (512) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (517) address_spec -> . FOR mark USE AT expression ;
    (320) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (321) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (322) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (342) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (506) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (367) task_spec -> . TASK simple_name task_def
    (368) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (375) prot_spec -> . PROTECTED ID prot_def
    (376) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (361) rename_unit -> . PACKAGE compound_name renames ;
    (362) rename_unit -> . subprog_spec renames ;
    (363) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (364) rename_unit -> . generic_formal_part subprog_spec renames ;
    (477) generic_formal_part -> . GENERIC
    (478) generic_formal_part -> . generic_formal_part generic_formal
    (505) generic_subp_inst -> . subprog_spec IS generic_inst
    (26) def_id -> . ID

    BEGIN           reduce using rule 137 (decl_part -> .)
    TASK            shift and go to state 68
    PROTECTED       shift and go to state 52
    error           shift and go to state 78
    USE             shift and go to state 47
    PRAGMA          shift and go to state 4
    PACKAGE         shift and go to state 73
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 64
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 37
    GENERIC         shift and go to state 21
    ID              shift and go to state 91

    decl                           shift and go to state 51
    subprog_body                   shift and go to state 60
    task_decl                      shift and go to state 61
    type_decl                      shift and go to state 57
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 62
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 53
    subprog_spec_is_push           shift and go to state 24
    decl_part                      shift and go to state 972
    prot_decl                      shift and go to state 56
    record_type_spec               shift and go to state 69
    generic_decl                   shift and go to state 70
    def_id                         shift and go to state 88
    attrib_def                     shift and go to state 71
    subprog_spec                   shift and go to state 86
    def_id_s                       shift and go to state 87
    decl_item_or_body_s1           shift and go to state 72
    decl_item                      shift and go to state 54
    task_spec                      shift and go to state 66
    body                           shift and go to state 63
    object_decl                    shift and go to state 65
    body_stub                      shift and go to state 74
    pkg_spec                       shift and go to state 38
    rename_decl                    shift and go to state 89
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 75
    rename_unit                    shift and go to state 90
    generic_formal_part            shift and go to state 34
    subprog_decl                   shift and go to state 59
    pkg_decl                       shift and go to state 58
    prot_spec                      shift and go to state 76
    pkg_start                      shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 67
    generic_pkg_inst               shift and go to state 35
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 961

    (402) entry_body_part -> ; .

    PRAGMA          reduce using rule 402 (entry_body_part -> ; .)
    END             reduce using rule 402 (entry_body_part -> ; .)
    ENTRY           reduce using rule 402 (entry_body_part -> ; .)
    PROCEDURE       reduce using rule 402 (entry_body_part -> ; .)
    FUNCTION        reduce using rule 402 (entry_body_part -> ; .)


state 962

    (110) comp_decl -> def_id_s : component_subtype_def init_opt ; .

    error           reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    ENTRY           reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    PROCEDURE       reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    FUNCTION        reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    PRAGMA          reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    FOR             reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    ID              reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    END             reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    CASE            reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    WHEN            reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)


state 963

    (399) entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt ; .

    PRIVATE         reduce using rule 399 (entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt ; .)
    ENTRY           reduce using rule 399 (entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt ; .)
    PROCEDURE       reduce using rule 399 (entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt ; .)
    FUNCTION        reduce using rule 399 (entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt ; .)
    PRAGMA          reduce using rule 399 (entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt ; .)
    FOR             reduce using rule 399 (entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt ; .)
    END             reduce using rule 399 (entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt ; .)
    error           reduce using rule 399 (entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt ; .)
    ID              reduce using rule 399 (entry_decl -> ENTRY ID ( discrete_range ) formal_part_opt ; .)


state 964

    (429) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .

    LEFTLABEL       reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    error           reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    PRAGMA          reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    NuLL            reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    EXIT            reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    RETURN          reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    GOTO            reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    DELAY           reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ABORT           reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    RAISE           reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    REQUEUE         reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    IF              reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    CASE            reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ID              reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ACCEPT          reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    SELECT          reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    STRLITERAL      reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    WHILE           reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    DECLARE         reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    FOR             reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    LOOP            reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    BEGIN           reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    OR              reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ELSE            reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    END             reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    EXCEPTION       reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    THEN            reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ELSIF           reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    WHEN            reduce using rule 429 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)


state 965

    (516) comp_loc_s -> comp_loc_s mark AT expression RANGE range . ;

    ;               shift and go to state 973


state 966

    (107) comp_decl_s -> comp_decl_s pragma_s comp_decl .

    error           reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    CASE            reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    PRAGMA          reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    ID              reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    END             reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    WHEN            reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)


state 967

    (109) variant_part_opt -> pragma_s variant_part . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 974

state 968

    (119) variant_part -> CASE simple_name IS . pragma_s variant_s END CASE ;
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 975

state 969

    (98) record_def -> RECORD pragma_s comp_list END RECORD .

    ;               reduce using rule 98 (record_def -> RECORD pragma_s comp_list END RECORD .)


state 970

    (105) comp_list -> NuLL ; pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 105 (comp_list -> NuLL ; pragma_s .)
    WHEN            reduce using rule 105 (comp_list -> NuLL ; pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 971

    (401) entry_body -> ENTRY ID ( iter_part discrete_range ) formal_part_opt . WHEN condition entry_body_part

    WHEN            shift and go to state 976


state 972

    (403) entry_body_part -> IS decl_part . block_body END id_opt ;
    (305) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 165

    block_body                     shift and go to state 977

state 973

    (516) comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .

    END             reduce using rule 516 (comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .)
    ID              reduce using rule 516 (comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .)


state 974

    (109) variant_part_opt -> pragma_s variant_part pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 109 (variant_part_opt -> pragma_s variant_part pragma_s .)
    WHEN            reduce using rule 109 (variant_part_opt -> pragma_s variant_part pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 975

    (119) variant_part -> CASE simple_name IS pragma_s . variant_s END CASE ;
    (9) pragma_s -> pragma_s . pragma
    (120) variant_s -> . variant
    (121) variant_s -> . variant_s variant
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (122) variant -> . WHEN choice_s ARROW pragma_s comp_list

    PRAGMA          shift and go to state 4
    WHEN            shift and go to state 979

    variant_s                      shift and go to state 978
    variant                        shift and go to state 980
    pragma                         shift and go to state 14

state 976

    (401) entry_body -> ENTRY ID ( iter_part discrete_range ) formal_part_opt WHEN . condition entry_body_part
    (282) condition -> . expression
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 130
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    allocator                      shift and go to state 131
    factor                         shift and go to state 138
    operator_symbol                shift and go to state 139
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    condition                      shift and go to state 981
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 149
    qualified                      shift and go to state 151
    expression                     shift and go to state 470

state 977

    (403) entry_body_part -> IS decl_part block_body . END id_opt ;

    END             shift and go to state 982


state 978

    (119) variant_part -> CASE simple_name IS pragma_s variant_s . END CASE ;
    (121) variant_s -> variant_s . variant
    (122) variant -> . WHEN choice_s ARROW pragma_s comp_list

    END             shift and go to state 983
    WHEN            shift and go to state 979

    variant                        shift and go to state 984

state 979

    (122) variant -> WHEN . choice_s ARROW pragma_s comp_list
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (201) expression -> . relation
    (202) expression -> . expression logical m relation
    (203) expression -> . expression short_circuit m relation
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (209) relation -> . simple_expression
    (210) relation -> . simple_expression relational simple_expression
    (211) relation -> . simple_expression membership range
    (212) relation -> . simple_expression membership name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOUBLEDOT simple_expression
    (63) range -> . name SINGLEQUOTE RANGE
    (64) range -> . name SINGLEQUOTE RANGE ( expression )
    (221) simple_expression -> . unary term
    (222) simple_expression -> . term
    (223) simple_expression -> . simple_expression adding term
    (163) simple_name -> . ID
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name SINGLEQUOTE attribute_id
    (169) operator_symbol -> . STRLITERAL
    (224) unary -> . +
    (225) unary -> . -
    (229) term -> . factor
    (230) term -> . term multiplying factor
    (235) factor -> . primary
    (236) factor -> . NOT primary
    (237) factor -> . primary DOUBLESTAR primary
    (238) factor -> . ABS primary
    (239) primary -> . literal
    (240) primary -> . name
    (241) primary -> . allocator
    (242) primary -> . qualified
    (243) primary -> . parenthesized_primary
    (190) literal -> . numeric_lit
    (191) literal -> . used_char
    (192) literal -> . NuLL
    (247) allocator -> . NEW name
    (248) allocator -> . NEW qualified
    (246) qualified -> . name SINGLEQUOTE parenthesized_primary
    (244) parenthesized_primary -> . aggregate
    (245) parenthesized_primary -> . ( expression )
    (186) numeric_lit -> . NUMLITERAL_BASE_INT
    (187) numeric_lit -> . NUMLITERAL_BASE_FLOAT
    (188) numeric_lit -> . NUMLITERAL_INT
    (189) numeric_lit -> . NUMLITERAL_FLOAT
    (168) used_char -> . CHARLITERAL
    (193) aggregate -> . ( comp_assoc )
    (194) aggregate -> . ( value_s_2 )
    (195) aggregate -> . ( expression WITH value_s )
    (196) aggregate -> . ( expression WITH NuLL RECORD )
    (197) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 228
    ID              shift and go to state 41
    STRLITERAL      shift and go to state 150
    +               shift and go to state 135
    -               shift and go to state 136
    NOT             shift and go to state 152
    ABS             shift and go to state 141
    NuLL            shift and go to state 153
    NEW             shift and go to state 128
    (               shift and go to state 134
    NUMLITERAL_BASE_INT shift and go to state 133
    NUMLITERAL_BASE_FLOAT shift and go to state 144
    NUMLITERAL_INT  shift and go to state 127
    NUMLITERAL_FLOAT shift and go to state 143
    CHARLITERAL     shift and go to state 155

    selected_comp                  shift and go to state 121
    attribute                      shift and go to state 122
    primary                        shift and go to state 123
    used_char                      shift and go to state 146
    unary                          shift and go to state 125
    relation                       shift and go to state 126
    simple_expression              shift and go to state 389
    indexed_comp                   shift and go to state 130
    allocator                      shift and go to state 131
    simple_name                    shift and go to state 160
    literal                        shift and go to state 137
    choice_s                       shift and go to state 985
    operator_symbol                shift and go to state 139
    factor                         shift and go to state 138
    choice                         shift and go to state 232
    qualified                      shift and go to state 151
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 145
    discrete_with_range            shift and go to state 525
    term                           shift and go to state 147
    numeric_lit                    shift and go to state 148
    name                           shift and go to state 235
    range                          shift and go to state 237
    expression                     shift and go to state 526

state 980

    (120) variant_s -> variant .

    END             reduce using rule 120 (variant_s -> variant .)
    WHEN            reduce using rule 120 (variant_s -> variant .)


state 981

    (401) entry_body -> ENTRY ID ( iter_part discrete_range ) formal_part_opt WHEN condition . entry_body_part
    (402) entry_body_part -> . ;
    (403) entry_body_part -> . IS decl_part block_body END id_opt ;

    ;               shift and go to state 961
    IS              shift and go to state 960

    entry_body_part                shift and go to state 986

state 982

    (403) entry_body_part -> IS decl_part block_body END . id_opt ;
    (300) id_opt -> .
    (301) id_opt -> . designator
    (323) designator -> . compound_name
    (324) designator -> . STRLITERAL
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . ID

    ;               reduce using rule 300 (id_opt -> .)
    STRLITERAL      shift and go to state 114
    ID              shift and go to state 41

    designator                     shift and go to state 471
    id_opt                         shift and go to state 987
    compound_name                  shift and go to state 116
    simple_name                    shift and go to state 42

state 983

    (119) variant_part -> CASE simple_name IS pragma_s variant_s END . CASE ;

    CASE            shift and go to state 988


state 984

    (121) variant_s -> variant_s variant .

    END             reduce using rule 121 (variant_s -> variant_s variant .)
    WHEN            reduce using rule 121 (variant_s -> variant_s variant .)


state 985

    (122) variant -> WHEN choice_s . ARROW pragma_s comp_list
    (124) choice_s -> choice_s . | choice

    ARROW           shift and go to state 989
    |               shift and go to state 373


state 986

    (401) entry_body -> ENTRY ID ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .

    PRAGMA          reduce using rule 401 (entry_body -> ENTRY ID ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    END             reduce using rule 401 (entry_body -> ENTRY ID ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    ENTRY           reduce using rule 401 (entry_body -> ENTRY ID ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    PROCEDURE       reduce using rule 401 (entry_body -> ENTRY ID ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    FUNCTION        reduce using rule 401 (entry_body -> ENTRY ID ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)


state 987

    (403) entry_body_part -> IS decl_part block_body END id_opt . ;

    ;               shift and go to state 990


state 988

    (119) variant_part -> CASE simple_name IS pragma_s variant_s END CASE . ;

    ;               shift and go to state 991


state 989

    (122) variant -> WHEN choice_s ARROW . pragma_s comp_list
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    NuLL            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    error           reduce using rule 8 (pragma_s -> .)
    ID              reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 992

state 990

    (403) entry_body_part -> IS decl_part block_body END id_opt ; .

    PRAGMA          reduce using rule 403 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    END             reduce using rule 403 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    ENTRY           reduce using rule 403 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 403 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 403 (entry_body_part -> IS decl_part block_body END id_opt ; .)


state 991

    (119) variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .

    PRAGMA          reduce using rule 119 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)
    END             reduce using rule 119 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)
    WHEN            reduce using rule 119 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)


state 992

    (122) variant -> WHEN choice_s ARROW pragma_s . comp_list
    (9) pragma_s -> pragma_s . pragma
    (103) comp_list -> . comp_decl_s variant_part_opt
    (104) comp_list -> . variant_part pragma_s
    (105) comp_list -> . NuLL ; pragma_s
    (2) pragma -> . PRAGMA ID ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (106) comp_decl_s -> . comp_decl
    (107) comp_decl_s -> . comp_decl_s pragma_s comp_decl
    (119) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (110) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (111) comp_decl -> . error ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . ID

    NuLL            shift and go to state 936
    PRAGMA          shift and go to state 4
    CASE            shift and go to state 932
    error           shift and go to state 794
    ID              shift and go to state 91

    def_id_s                       shift and go to state 790
    comp_list                      shift and go to state 993
    comp_decl                      shift and go to state 934
    def_id                         shift and go to state 88
    variant_part                   shift and go to state 935
    pragma                         shift and go to state 14
    comp_decl_s                    shift and go to state 931

state 993

    (122) variant -> WHEN choice_s ARROW pragma_s comp_list .

    END             reduce using rule 122 (variant -> WHEN choice_s ARROW pragma_s comp_list .)
    WHEN            reduce using rule 122 (variant -> WHEN choice_s ARROW pragma_s comp_list .)

